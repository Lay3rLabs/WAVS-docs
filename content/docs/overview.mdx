---
title: Overview (WIP)
---
import { HomeIcon, AppWindow, CircuitBoard, Layers, Microscope, Grid2x2, ChevronRight } from 'lucide-react';
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';

## What is WAVS?


WAVS is a next-generation AVS (Actively Validated Service) platform, making it easy to create, manage, and operate high-performance AVSs. By providing a base layer of AVS infrastructure, WAVS allows builders to focus solely on implementing the core logic of their services, which are written in Rust (with support for more languages coming soon), compiled to WASM, and deployed as lightweight service components. Triggered by onchain events or timed tasks, these components are run offchain by operators in the WAVS (WASI-AVS) runtime at near-native speed, and the results are brought verifiably onchain.

WAVS will initially be launched as a service on EigenLayer, utilizing EigneLayer restaking to secure AVSs built on WAVS. A service of services, WAVS allows an AVS to dynamically run and manage multiple components that work together to build flexible and intelligent applications.


{/* WAVS is a WASI AVS Runtime for building AVSs (Actively Validated Service). With WAVS, you can create, manage, and operate high-performance 

 that harness the power of WASM and composability, enabling 



WHat are AVSs built with WAVS?
- High performance
- low cost




composable service components
Service of service (meta service)
intellegent protocols
dynamic
Service components get triggered
Operators run the component in the WASI AVS runtime
Makes it easy to build an AVS
multichain
The power of wasm */}

> In simple terms, WAVS makes it easy to build and manage an AVS.


## Use cases

- Decentralized AI: WAVS unlocks decentralized AI agents that are deterministic and verifiable, enabling trustless decision-making and autonomous governance through DAO controlled AI agents.{/* todo: link to ai example and blog post*/}
- Oracles: thanks to lightweight service components that can be dynamically deployed, launching a new oracle service is as easy as uploading a few lines of code. Use WAVS to aggregate and validate data from on and offchain sources.
{/* todo: link to oracle example */}
- Zero Knowledge Proofs: build ZK verifiers, ZK Prover Marketplaces, and ZK aggregation layers with WAVS 
- Data Availability: 
- Crosschain Bridges: 
- Dynamic applications: 
- Intellegent protocols: 

{/* >A decentralized application Layer for the multichain

> Bringing offchain onchain. */}

## Building with WAVS

WAVS takes the guess work out of building an AVS, making it easy to build and deploy a custom service. By providing a base layer of AVS infrastructure and and developer tooling, WAVS enables a new multichain ecosystem of decentralized applications that are composable, decentralized, and verifiable onchain.

### 1. Define triggers

Triggers are the actions or events that prompt your service to be run.

WAVS is built for flexibilty, so there are a few different types of triggers to choose from:

- Onchain events: events emitted from smart contracts.
- Cron jobs: triggers that run at specific times or intervals.
- Offchain events: external services, http events, user input, etc.

Both onchain and offchain event triggers can be used to pass arbitrary data as the inputs for service components to be run.

<img alt="WAVS" src="/diagrams/triggers.png" />

### 2. Build service components

Service components are the core logic of your AVS.

Once triggered, what do you want your service to do?

These components are written in Rust (with more languages coming soon!) and compile to WASM as lightweight WASI components. Instead of configuring multiple custom contracts with thousands of lines of code, WAVS provides the base layer of infrastructure, allowing you to focus solely on the core logic of your service.

Service components can also contain logic for processing input data from triggers. If an onchain trigger passes data, a service can use that data as input for the service component. For example, a simple service component could contain logic for receiving a number as input and returning the square of that number as output.

<img alt="WAVS" src="/diagrams/service.png" />

Visit the WAVS tutorial to learn how to create a service component.

### 3. Deploy your Service

You can deploy your service component to wavs by uploading a service component and deploying your necessary service manager, trigger, and core contracts. Then, you'll need to find operators to register to participate in running your service.

Operators that have registered for your service run WAVS nodes and listen for the triggers specified by your service. Once triggered, operators will run your service offchain in the WAVS WASI runtime, verify the result of the service computation, and return the result as an onchain response.

<img alt="WAVS" src="/diagrams/wavs-flow.png" />


{/* Link to info about WASI and the runtime */}


If you need to update your service, don't worry! WAVS makes it possible to update Service component logic without having to coordinate with operators. Simply deploy a new service component and update your [Service Manifest](./how-it-works#service-manifest). Operators only need to upgrade if there is a change to the WAVS node software itself.

## Composability (WIP)


Not only can services be chained together, but service components themselves are composable. Thanks to WASI, . Because components are compiled into wasm, code written in different languages is composable.

WASI components

## Multichain capability

WAVS is built for the multichain. Although initially be launched as a service on Ethereum, WAVS is compatible with crosschain communication. Service components built using WAVS can be designed to be triggered by both on and offchain events, including events from other chains if configured correctly. Multichain services can be triggered by events on one chain, be run by operators offchain, and have the verified response written to another chain. This interoperability is what makes WAVS so flexible, creating a decentralized computational Layer that can function across multiple chains.

## Security

The WAVS platform is secured via Ethereum restaking on EigenLayer, which provides a base security Layer for AVSs built using WAVS. Restaking refers to the utilization of staked Ethereum to secure other AVSs, by imposing additional slashing terms on the staked Ethereum for operator misbehavior. In this way, the cryptoeconomic security of Ethereum can be extended to WAVS AVSs. Commitments extend EigenLayer restaking by enabling the creation of programmable restaking flows that can be used to create interwoven mesh networks of cryotoeconomic security.

## Full-stack Decentralization



<img alt="WAVS" src="/diagrams/security.png" />

