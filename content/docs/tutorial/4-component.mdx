---
title: Weather Service Component Walkthrough
---

import { HoverContainer } from "@/components/hover-container"
import { Callout } from 'fumadocs-ui/components/callout';
import { Scrollycoding } from "@/components/scrollycoding";
import { link } from "@/components/link.tsx"

This page provides a detailed walkthrough of the Weather Service Component, explaining its functionality step-by-step. The component processes on-chain triggers to fetch weather data using the OpenWeather API.


<HoverContainer>
<Scrollycoding>

## !!steps The Weather Component

This example will use code from a weather service, which takes a location input and returns the weather for that area.



```rust ! lib.rs
#[allow(warnings)]
mod bindings;
use bindings::Guest;
use layer_wasi::{block_on, Reactor, Request, WasiPollable};
use serde::{Deserialize, Serialize};

struct Component;

impl Guest for Component {
    fn process_eth_trigger(input: Vec<u8>) -> std::result::Result<Vec<u8>, String> {
        println!("process_eth_trigger Received input: {:?}", input); // Nashville,TN as input

        if !input.contains(&b',') {
            return Err("Input must be in the format of City,State".to_string());
        }
        let input = std::str::from_utf8(&input).unwrap(); // TODO:

        // open weather API, not wavs specific -- https://github.com/Lay3rLabs/WAVS/issues/10
        // Or just hardcode it (bad practice / high risk - testing only)

        let api_key = std::env::var("WAVS_ENGINE_ENV_OPEN_WEATHER_API_KEY")
            .or(Err("missing env var WAVS_ENGINE_ENV_OPEN_WEATHER_API_KEY".to_string()))?;

        block_on(|reactor| async move {
            let loc: Result<LocDataNested, String> =
                get_location(&reactor, api_key.clone(), input).await;
            let location = match loc {
                Ok(data) => data,
                Err(e) => return Err(e),
            };

            let weather_data = get_weather(&reactor, location, api_key).await;

            match weather_data {
                Ok(data) => {
                    let output: Vec<u8> = data.into();
                    Ok(output)
                }
                Err(e) => Err(e),
            }
        })
    }
}

async fn get_location(
    reactor: &Reactor,
    app_key: String,
    loc_input: &str,
) -> Result<LocDataNested, String> {
      // !link[/http://api.openweathermap.org/geo/1.0/direct/] https://openweathermap.org/
    let url: &str = "http://api.openweathermap.org/geo/1.0/direct";
    let loc_input_formatted = format!("{},US", loc_input);
    let params = [
        ("q", loc_input_formatted.as_str()),
        ("appid", app_key.as_str()),
    ];

    let url_with_params = reqwest::Url::parse_with_params(url, &params).unwrap();
    let mut req = Request::get(url_with_params.as_str())?;
    req.headers = vec![
        ("Accept".to_string(), "application/json".to_string()),
        ("Content-Type".to_string(), "application/json".to_string()),
    ];

    let response = reactor.send(req).await;

    match response {
        Ok(response) => {
            println!("{:?}", response);
            let finalresp = response.json::<LocationData>().map_err(|e| {
                let resp_body = response.body;
                let resp_str = String::from_utf8_lossy(&resp_body);
                format!(
                    "Error debugging location response to JSON. Error: {:?}. had response: {:?} | using URL: {:?}",
                    e, resp_str, url_with_params,
                )
            })?;
            println!("{:?}", finalresp);
            return Ok(finalresp[0].clone());
        }
        Err(e) => {
            println!("{:?}", e);
            return Err(e.to_string());
        }
    }
}

async fn get_weather(
    reactor: &Reactor,
    location: LocDataNested,
    app_key: String,
) -> Result<WeatherResponse, String> {
    let url: &str = "https://api.openweathermap.org/data/2.5/weather";
    let params = [
        ("lat", location.lat.to_string()),
        ("lon", location.lon.to_string()),
        ("appid", app_key),
        ("units", "imperial".to_string()),
    ];

    let url_with_params = reqwest::Url::parse_with_params(url, &params).unwrap();
    let mut req = Request::get(url_with_params.as_str())?;
    req.headers = vec![
        ("Accept".to_string(), "application/json".to_string()),
        ("Content-Type".to_string(), "application/json".to_string()),
    ];

    let response = reactor.send(req).await;


    match response {
        // print out either option
        Ok(response) => {
            println!("{:?}", response);
            let finalresp = response.json::<WeatherResponse>().map_err(|e| {
                let resp_body = response.body;
                let resp_str = String::from_utf8_lossy(&resp_body);
                format!(
                    "Error debugging weather response to JSON. Error: {:?}. had response: {:?} | using URL: {:?}",
                    e, resp_str, url_with_params,
                )
            })?;
            println!("{:?}", finalresp.main.temp);
            return Ok(finalresp);
        }
        Err(e) => {
            println!("{:?}", e);
            return Err(e.to_string());
        }
    }
}

/// -----
/// Given the JSON response, use an unescape tool like: https://jsonformatter.org/json-unescape
/// {\"coord\":{\"lon\":-86.7743,\"lat\":36.1623},\"weather\":[{\"id\":804,\"main\":\"Clouds\",\"description\":\"overcast clouds\",\"icon\":\"04d\"}],\"base\":\"stations\",\"main\":{\"temp\":28.13,\"feels_like\":16.21,\"temp_min\":26.17,\"temp_max\":29.34,\"pressure\":1018,\"humidity\":76,\"sea_level\":1018,\"grnd_level\":995},\"visibility\":10000,\"clouds\":{\"all\":100},\"dt\":1736193327,\"sys\":{\"type\":1,\"id\":3477,\"country\":\"US\",\"sunrise\":1736168310,\"sunset\":1736203634},\"timezone\":-21600,\"id\":4644585,\"name\":\"Nashville\",\"cod\":200}
///
/// Then put that into a JSON to struct converter: https://transform.tools/json-to-rust-serde
/// some types will not entirely convert as expected, so you can just ignore them if you get issues or properly convert to the types.
/// -----

// location based
pub type LocationData = Vec<LocDataNested>;

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LocDataNested {
    pub name: String,
    pub lat: f64,
    pub lon: f64,
    pub country: String,
    pub state: String,
}

//

#[derive(Serialize, Deserialize, Debug)]
pub struct WeatherResponse {
    coord: Coord,
    weather: Vec<Weather>,
    base: String,
    main: Main,
    visibility: i64,
    // wind: Wind, // this needs to be a floating point / string
    clouds: Clouds,
    dt: i64, // the unix time this was taken, in UTC.
    sys: Sys,
    timezone: i64,
    id: i64,
    name: String,
    cod: i64,
}

// convert WeatherResponse to bytes
impl Into<Vec<u8>> for WeatherResponse {
    fn into(self) -> Vec<u8> {
        let s = serde_json::to_string(&self).unwrap();
        s.into_bytes()
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Clouds {
    all: i64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Coord {
    lon: f64,
    lat: f64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Main {
    temp: f64,
    feels_like: f64,
    temp_min: f64,
    temp_max: f64,
    pressure: i64,
    humidity: i64,
    sea_level: i64,
    grnd_level: i64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Sys {
    #[serde(rename = "type")]
    sys_type: i64,
    id: i64,
    country: String,
    sunrise: i64,
    sunset: i64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Weather {
    id: i64,
    main: String,
    description: String,
    icon: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Wind {
    speed: i64,
    deg: i64,
}

bindings::export!(Component with_types_in bindings);
```

## !!steps The trigger

An onchain trigger is added to the trigger contract location data in the form of City,State (Nashville,TN for example) and the trigger contract emmits an event.


```rust ! lib.rs
#[allow(warnings)]
mod bindings;
use bindings::Guest;
use layer_wasi::{block_on, Reactor, Request, WasiPollable};
use serde::{Deserialize, Serialize};

// !focus(1:10)
struct Component;

impl Guest for Component {
    fn process_eth_trigger(input: Vec<u8>) -> std::result::Result<Vec<u8>, String> {
        println!("process_eth_trigger Received input: {:?}", input); // Nashville,TN as input

        if !input.contains(&b',') {
            return Err("Input must be in the format of City,State".to_string());
        }
        let input = std::str::from_utf8(&input).unwrap(); // TODO:

        // open weather API, not wavs specific -- https://github.com/Lay3rLabs/WAVS/issues/10
        // Or just hardcode it (bad practice / high risk - testing only)

        let api_key = std::env::var("WAVS_ENGINE_ENV_OPEN_WEATHER_API_KEY")
            .or(Err("missing env var WAVS_ENGINE_ENV_OPEN_WEATHER_API_KEY".to_string()))?;

        block_on(|reactor| async move {
            let loc: Result<LocDataNested, String> =
                get_location(&reactor, api_key.clone(), input).await;
            let location = match loc {
                Ok(data) => data,
                Err(e) => return Err(e),
            };

            let weather_data = get_weather(&reactor, location, api_key).await;

            match weather_data {
                Ok(data) => {
                    let output: Vec<u8> = data.into();
                    Ok(output)
                }
                Err(e) => Err(e),
            }
        })
    }
}

async fn get_location(
    reactor: &Reactor,
    app_key: String,
    loc_input: &str,
) -> Result<LocDataNested, String> {
    let url: &str = "http://api.openweathermap.org/geo/1.0/direct";
    let loc_input_formatted = format!("{},US", loc_input);
    let params = [
        ("q", loc_input_formatted.as_str()),
        ("appid", app_key.as_str()),
    ];

    let url_with_params = reqwest::Url::parse_with_params(url, &params).unwrap();
    let mut req = Request::get(url_with_params.as_str())?;
    req.headers = vec![
        ("Accept".to_string(), "application/json".to_string()),
        ("Content-Type".to_string(), "application/json".to_string()),
    ];

    let response = reactor.send(req).await;

    match response {
        Ok(response) => {
            println!("{:?}", response);
            let finalresp = response.json::<LocationData>().map_err(|e| {
                let resp_body = response.body;
                let resp_str = String::from_utf8_lossy(&resp_body);
                format!(
                    "Error debugging location response to JSON. Error: {:?}. had response: {:?} | using URL: {:?}",
                    e, resp_str, url_with_params,
                )
            })?;
            println!("{:?}", finalresp);
            return Ok(finalresp[0].clone());
        }
        Err(e) => {
            println!("{:?}", e);
            return Err(e.to_string());
        }
    }
}

async fn get_weather(
    reactor: &Reactor,
    location: LocDataNested,
    app_key: String,
) -> Result<WeatherResponse, String> {
    let url: &str = "https://api.openweathermap.org/data/2.5/weather";
    let params = [
        ("lat", location.lat.to_string()),
        ("lon", location.lon.to_string()),
        ("appid", app_key),
        ("units", "imperial".to_string()),
    ];

    let url_with_params = reqwest::Url::parse_with_params(url, &params).unwrap();
    let mut req = Request::get(url_with_params.as_str())?;
    req.headers = vec![
        ("Accept".to_string(), "application/json".to_string()),
        ("Content-Type".to_string(), "application/json".to_string()),
    ];

    let response = reactor.send(req).await;


    match response {
        // print out either option
        Ok(response) => {
            println!("{:?}", response);
            let finalresp = response.json::<WeatherResponse>().map_err(|e| {
                let resp_body = response.body;
                let resp_str = String::from_utf8_lossy(&resp_body);
                format!(
                    "Error debugging weather response to JSON. Error: {:?}. had response: {:?} | using URL: {:?}",
                    e, resp_str, url_with_params,
                )
            })?;
            println!("{:?}", finalresp.main.temp);
            return Ok(finalresp);
        }
        Err(e) => {
            println!("{:?}", e);
            return Err(e.to_string());
        }
    }
}

/// -----
/// Given the JSON response, use an unescape tool like: https://jsonformatter.org/json-unescape
/// {\"coord\":{\"lon\":-86.7743,\"lat\":36.1623},\"weather\":[{\"id\":804,\"main\":\"Clouds\",\"description\":\"overcast clouds\",\"icon\":\"04d\"}],\"base\":\"stations\",\"main\":{\"temp\":28.13,\"feels_like\":16.21,\"temp_min\":26.17,\"temp_max\":29.34,\"pressure\":1018,\"humidity\":76,\"sea_level\":1018,\"grnd_level\":995},\"visibility\":10000,\"clouds\":{\"all\":100},\"dt\":1736193327,\"sys\":{\"type\":1,\"id\":3477,\"country\":\"US\",\"sunrise\":1736168310,\"sunset\":1736203634},\"timezone\":-21600,\"id\":4644585,\"name\":\"Nashville\",\"cod\":200}
///
/// Then put that into a JSON to struct converter: https://transform.tools/json-to-rust-serde
/// some types will not entirely convert as expected, so you can just ignore them if you get issues or properly convert to the types.
/// -----

// location based
pub type LocationData = Vec<LocDataNested>;

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LocDataNested {
    pub name: String,
    pub lat: f64,
    pub lon: f64,
    pub country: String,
    pub state: String,
}

//

#[derive(Serialize, Deserialize, Debug)]
pub struct WeatherResponse {
    coord: Coord,
    weather: Vec<Weather>,
    base: String,
    main: Main,
    visibility: i64,
    // wind: Wind, // this needs to be a floating point / string
    clouds: Clouds,
    dt: i64, // the unix time this was taken, in UTC.
    sys: Sys,
    timezone: i64,
    id: i64,
    name: String,
    cod: i64,
}

// convert WeatherResponse to bytes
impl Into<Vec<u8>> for WeatherResponse {
    fn into(self) -> Vec<u8> {
        let s = serde_json::to_string(&self).unwrap();
        s.into_bytes()
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Clouds {
    all: i64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Coord {
    lon: f64,
    lat: f64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Main {
    temp: f64,
    feels_like: f64,
    temp_min: f64,
    temp_max: f64,
    pressure: i64,
    humidity: i64,
    sea_level: i64,
    grnd_level: i64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Sys {
    #[serde(rename = "type")]
    sys_type: i64,
    id: i64,
    country: String,
    sunrise: i64,
    sunset: i64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Weather {
    id: i64,
    main: String,
    description: String,
    icon: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Wind {
    speed: i64,
    deg: i64,
}

bindings::export!(Component with_types_in bindings);
```



## !!steps process_eth_trigger

The `Guest` trait is implemented with the [`process_eth_trigger`](hover:one) method.

This function processes Ethereum triggers, validates the input, and coordinates subsequent API calls.


```rust ! lib.rs
impl Guest for Component {
    // !hover one
    fn process_eth_trigger(input: Vec<u8>) -> std::result::Result<Vec<u8>, String> {
        println!("process_eth_trigger Received input: {:?}", input); // Example: Nashville,TN as input

        // !hover input-validation Ensure input contains a comma in the format `City,State`.
        if !input.contains(&b',') {
            return Err("Input must be in the format of City,State".to_string());
        }
        let input = std::str::from_utf8(&input).unwrap();

        // Fetch the API key from environment variables.
        let api_key = std::env::var("WAVS_ENGINE_ENV_OPEN_WEATHER_API_KEY")
            .or(Err("missing env var `WAVS_ENGINE_ENV_OPEN_WEATHER_API_KEY`".to_string()))?;

        // !hover async-block Use block_on to handle asynchronous tasks.
        block_on(|reactor| async move {
            let loc: Result<LocDataNested, String> =
                get_location(&reactor, api_key.clone(), input).await;

            let location = match loc {
                Ok(data) => data,
                Err(e) => return Err(e),
            };

            let weather_data = get_weather(&reactor, location, api_key).await;

            match weather_data {
                Ok(data) => {
                    let output: Vec<u8> = data.into();
                    Ok(output)
                }
                Err(e) => Err(e),
            }
        })
    }
}
```


## !!steps Service Logic

The `get_location` function retrieves latitude and longitude for a given location string (`City,State`) by querying the OpenWeather Geo API. This retrieves the latitude and longitude for the specified location using the OpenWeather Geo API.

```rust ! lib.rs
async fn get_location(
    reactor: &Reactor,
    app_key: String,
    loc_input: &str,
) -> Result<LocDataNested, String> {
    let url: &str = "http://api.openweathermap.org/geo/1.0/direct";

    // Format the input location for API requests.
    let loc_input_formatted = format!("{},US", loc_input);
    let params = [
        ("q", loc_input_formatted.as_str()),
        ("appid", app_key.as_str()),
    ];

    let url_with_params = reqwest::Url::parse_with_params(url, &params).unwrap();
    let mut req = Request::get(url_with_params.as_str())?;
    req.headers = vec![
        ("Accept".to_string(), "application/json".to_string()),
        ("Content-Type".to_string(), "application/json".to_string()),
    ];

    let response = reactor.send(req).await;

    match response {
        Ok(response) => {
            let finalresp = response.json::<LocationData>().map_err(|e| {
                let resp_body = response.body;
                let resp_str = String::from_utf8_lossy(&resp_body);
                format!(
                    "Error parsing location response to JSON: {:?}. Response: {:?} | URL: {:?}",
                    e, resp_str, url_with_params,
                )
            })?;
            Ok(finalresp[0].clone())
        }
        Err(e) => Err(e.to_string()),
    }
}
```


## !!steps

Operators running the weather service listen for the event, and run the location data specified in the [Open Weather API](https://openweathermap.org/api).

```rust ! lib.rs
        let api_key = std::env::var("WAVS_ENGINE_ENV_OPEN_WEATHER_API_KEY")
            .or(Err("missing env var WAVS_ENGINE_ENV_OPEN_WEATHER_API_KEY".to_string()))?;

        block_on(|reactor| async move {
            let loc: Result<LocDataNested, String> =
                get_location(&reactor, api_key.clone(), input).await;
            let location = match loc {
                Ok(data) => data,
                Err(e) => return Err(e),
            };

            let weather_data = get_weather(&reactor, location, api_key).await;

            match weather_data {
                Ok(data) => {
                    let output: Vec<u8> = data.into();
                    Ok(output)
                }
                Err(e) => Err(e),
            }
        })

```

## !!steps Response

Operators receive the result from the weather API and return it onchain as a signed payload.

```rust ! lib.rs

    let url_with_params = reqwest::Url::parse_with_params(url, &params).unwrap();
    let mut req = Request::get(url_with_params.as_str())?;
    req.headers = vec![
        ("Accept".to_string(), "application/json".to_string()),
        ("Content-Type".to_string(), "application/json".to_string()),
    ];

    let response = reactor.send(req).await;


    match response {
        // print out either option
        Ok(response) => {
            println!("{:?}", response);
            let finalresp = response.json::<WeatherResponse>().map_err(|e| {
                let resp_body = response.body;
                let resp_str = String::from_utf8_lossy(&resp_body);
                format!(
                    "Error debugging weather response to JSON. Error: {:?}. had response: {:?} | using URL: {:?}",
                    e, resp_str, url_with_params,
                )
            })?;
            println!("{:?}", finalresp.main.temp);
            return Ok(finalresp);
        }
        Err(e) => {
            println!("{:?}", e);
            return Err(e.to_string());
        }
    }
```

## !!steps Fetching Weather Data

The `get_weather` function uses the coordinates from `get_location` to fetch current weather data from the OpenWeather API. This retrieves weather data for the given coordinates.


```rust ! lib.rs
async fn get_weather(
    reactor: &Reactor,
    location: LocDataNested,
    app_key: String,
) -> Result<WeatherResponse, String> {
    let url: &str = "https://api.openweathermap.org/data/2.5/weather";
    let params = [
        ("lat", location.lat.to_string()),
        ("lon", location.lon.to_string()),
        ("appid", app_key),
        ("units", "imperial".to_string()),
    ];

    let url_with_params = reqwest::Url::parse_with_params(url, &params).unwrap();
    let mut req = Request::get(url_with_params.as_str())?;
    req.headers = vec![
        ("Accept".to_string(), "application/json".to_string()),
        ("Content-Type".to_string(), "application/json".to_string()),
    ];

    let response = reactor.send(req).await;

    match response {
        Ok(response) => {
            let finalresp = response.json::<WeatherResponse>().map_err(|e| {
                let resp_body = response.body;
                let resp_str = String::from_utf8_lossy(&resp_body);
                format!(
                    "Error parsing weather response to JSON: {:?}. Response: {:?} | URL: {:?}",
                    e, resp_str, url_with_params,
                )
            })?;
            Ok(finalresp)
        }
        Err(e) => Err(e.to_string()),
    }
}
```


## !!steps

Define data structures to deserialize JSON responses and prepare them for submission.


```rust ! lib.rs
#[derive(Serialize, Deserialize, Debug)]
pub struct LocDataNested {
    pub name: String,
    pub lat: f64,
    pub lon: f64,
    pub country: String,
    pub state: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct WeatherResponse {
    pub coord: Coord,
    pub weather: Vec<Weather>,
    pub main: Main,
    pub name: String,
}

impl Into<Vec<u8>> for WeatherResponse {
    fn into(self) -> Vec<u8> {
        let s = serde_json::to_string(&self).unwrap();
        s.into_bytes()
    }
}
```


## !!steps Debugging JSON Responses

1. **Unescape JSON**: Use tools like [jsonformatter.org/json-unescape](https://jsonformatter.org/json-unescape) for debugging. Example:
2. **Generate Structs**: Convert JSON to Rust structs using [transform.tools/json-to-rust-serde](https://transform.tools/json-to-rust-serde).
3. **Refine Structs**: Adjust struct definitions as needed for proper deserialization.

```json ! JSON
    {\"coord\":{\"lon\":-86.7743,\"lat\":36.1623},\"weather\":[{\"id\":804,\"main\":\"Clouds\",\"description\":\"overcast clouds\",\"icon\":\"04d\"}],\"main\":{\"temp\":28.13}}
```


</Scrollycoding>
</HoverContainer>
