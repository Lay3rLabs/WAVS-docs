---
title: Under the hood
---
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

This page discusses the technical details of how WAVS currently works.

The contents of this page follow the flow of the [e2e test](https://github.com/Lay3rLabs/WAVS/blob/main/packages/wavs/tests/e2e.rs) and the diagram in the [Overall Message and Channels Flow document](https://github.com/Lay3rLabs/WAVS/blob/main/docs/architecture/channels-runtimes.md).

The following flow is specific to AVSs on Ethereum.

1. First, a chain is launched (anvil local chain in this case).

2. Technical configuration is set up and passed to the core dispatcher.



## Architecture

see notes here: https://github.com/Lay3rLabs/WAVS/blob/main/packages/wavs/src/apis/mod.rs

## Service lifecycle

1. An EVM event is emmited.

2. The Trigger Manager filters event and checks that it’s for a registered contract address, etc. it get’s service info from wavs internal database


## Aggregator

The aggregator is not a part of WAVS directly: it is run separately with the purpose of lowering gas costs for operators when posting results.








## Notes from David

## starting with e2e tests:

On Ethereum (we support eth and cosmos)

1. launch a local anvil chain
2. sets up config, and data storage nitty gritty
3. Config is passed into Core Dispatcher
    1. [channels-runtimes.md](http://channels-runtimes.md) is how things work (but a bit different, we’re uasing tokio instead of crossbeam)
    2. aggregator is not actually part of anything wavs. It is there to save gas (it’s currently run globally right now, kind of an open question). 
4. user emits an event, trigger manager filters event and checks that it’s for a registered contract address, etc. it get’s service info from wavs internal database
5. trigger manager can look up a trigger id, which  contains a service id and workflow id. (everything has a service id and workflow id)
    1. is a service and a trigger 1 to 1? yes? Each individual event that happens has its own trigger id, but internally it is associated with a trigger, service and submission. 
        1. A service can be composed of multiple workflows. A workflow is a 1:1 trigger and component
6. Dispatcher: dispatches things between subsystems. It connects things together. trigger send to dispatcher, dispatcher sends to engine. Everything from trigger goes to the engine. The dispatcher takes things and routes them to places, all in different channels. All parts are decoupled, but the dispatcher is what connects them all together. The dispatcher basically transforms a trigger into a “trigger action” (tells engine what to do in a necessary format). 
7. trigger action gets passed to engine.  engine knows service and workflow id from trigger manager, and knows which workflow and which component to run. 
    1. a component is an application: a wasm file.
8. The engine runs the component with the data it got from the trigger. 
9. Engine executes and gets the result back. It knows  from the submission. 
    1. the workflow contains the submissions, which details where to submit the result of a service. 
10. result goes to submissions manager (operator-signer), which submits response onchain 

HTTP server is not exposed to the outside world, it is an internal thing for administration. 

### Multiple chains

- listen on 1, write to the other eventually
- 1st version will be listen to ethereum/write to ethereum or listen to cosmos/write to cosmos. not cross-chain.
    - it’s easier to debug and test on ethereum, and commitments aren’t integrated yet.
- 

## Services

A service can be composed of multiple workflows. A workflow is a single component, trigger and submission. 

### Web assembly development: composability

Web assembly component model: as a developer, you can take wasm components and compose them into a new component. This ismuch more powerful way to compose, but it’s not there yet for devs. it’s hard to do. 

For development, you hit the http service to register your service. (ids are hardcoded, we only support default right now). 

## Service manifest (TBD)

- just as we listen to triggers, we’ll listen to service registrations
- OPerators can then register to different services.

Think as I’m writing the docs how we want to do this in the future. 

## Core contracts

1. Eigenlayer core contracts are specific to eigenlayer, the main point is that we need to register the operator to eigenlayer when we launch wavs
2. Delegation manager is something that we do interact with: most is boiler plate, but it registers you as a user on the system. 
3. Then you 

1. deploy core contracts
2. register operator on core
3. deploy service contracts (mainly 1 contract, but it makes you describe restaking/delegations/eigenlayer specific stuff) 
4. register as an operator on your service
5. Hits the http server. it doesn’t hit wavs directly. The service modifies data in dispatcher, trigger manager, submission manager

## aggregator

when you create a service, you specify whether it needs aggregation
