Source: https://github.com/Lay3rLabs/wavs-foundry-template

This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.claude/
  docker-compose.claude.yml
  Dockerfile.claude
.cursor/
  rules/
    ai.mdc
    blockchain-interactions.mdc
    commands.mdc
    component-rules.mdc
    component.mdc
    cursor-rules.mdc
    network-requests.mdc
    overview.mdc
    service.mdc
    submission.mdc
    template.mdc
    triggers.mdc
    variables.mdc
    workflows.mdc
.github/
  workflows/
    contracts.yml
    rust.yml
    wavs-image-version-verifier.yml
  single-wavs-image-verifier.bash
components/
  evm-price-oracle/
    src/
      bindings.rs
      lib.rs
      trigger.rs
    Cargo.toml
    config.json
    Makefile
  golang-evm-price-oracle/
    src/
      cmc.go
      main.go
    config.json
    go.mod
    Makefile
    README.md
    wkg.lock
  js-evm-price-oracle/
    config.json
    index.ts
    Makefile
    package.json
    README.md
    trigger.ts
docs/
  handbook/
    components/
      blockchain-interactions.mdx
      component.mdx
      network-requests.mdx
      variables.mdx
    ai.mdx
    commands.mdx
    overview.mdx
    service.mdx
    submission.mdx
    template.mdx
    triggers.mdx
    workflows.mdx
  resources/
    llms.mdx
  tutorial/
    1-overview.mdx
    2-setup.mdx
    3-project.mdx
    4-component.mdx
    5-build.mdx
    6-run-service.mdx
    7-prediction.mdx
  benefits.mdx
  design.mdx
  how-it-works.mdx
  index.mdx
  overview.mdx
script/
  template/
    .env.example.aggregator
    .env.example.operator
  .solhint.json
  avs-signing-key.sh
  build_components.sh
  build-service.sh
  Common.s.sol
  create-aggregator.sh
  create-deployer.sh
  create-operator.sh
  deploy-contracts.sh
  deploy-script.sh
  get-deploy-status.sh
  get-ipfs-gateway.sh
  get-registry.sh
  get-rpc.sh
  get-wasi-namespace.sh
  ShowResult.s.sol
  start_all.sh
  Trigger.s.sol
  upload-to-wasi-registry.sh
src/
  common/
    CmdRunner.sol
  contracts/
    WavsSubmit.sol
    WavsTrigger.sol
  interfaces/
    .solhint.json
    ITypes.sol
    IWavsTrigger.sol
telemetry/
  docker-compose.yml
  telemetry.md
test/
  unit/
    WavsTrigger.t.sol
  .solhint.json
test_utils/
  README.md
  validate_component.sh
tools/
  upgrade.sh
.env.example
.gitignore
.solhint.json
Cargo-component.lock
Cargo.toml
claude.md
docker-compose.yml
foundry.toml
LICENSE
Makefile
metadata.json
natspec-smells.config.js
package.json
README.md
remappings.txt
rustfmt.toml
wavs.toml
```

# Files

## File: .claude/docker-compose.claude.yml
````yaml
services:
  claude-code-sandbox:
    build:
      context: .
      dockerfile: Dockerfile.claude
    volumes:
      - ..:/workspace:consistent
      - claude-code-bashhistory:/commandhistory
      - claude-code-config:/home/node/.claude
    environment:
      NODE_OPTIONS: --max-old-space-size=4096
      CLAUDE_CONFIG_DIR: /home/node/.claude
      POWERLEVEL9K_DISABLE_GITSTATUS: "true"
    working_dir: /workspace

volumes:
  claude-code-bashhistory:
  claude-code-config:
````

## File: .claude/Dockerfile.claude
````
# Use multi-stage build for a smaller final image
FROM node:20-slim AS base

# Install only essential dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    git \
    procps \
    sudo \
    fzf \
    zsh \
    wget \
    ca-certificates \
    gnupg2 \
    jq \
    unzip \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Set up non-root user and directories
ARG USERNAME=node
RUN mkdir -p /usr/local/share/npm-global /workspace /home/node/.claude /commandhistory \
    && touch /commandhistory/.bash_history \
    && chown -R $USERNAME:$USERNAME /usr/local/share/npm-global /workspace /home/node/.claude /commandhistory

# Install delta once
RUN ARCH=$(dpkg --print-architecture) \
    && wget -q "https://github.com/dandavison/delta/releases/download/0.18.2/git-delta_0.18.2_${ARCH}.deb" \
    && dpkg -i "git-delta_0.18.2_${ARCH}.deb" \
    && rm "git-delta_0.18.2_${ARCH}.deb"

# Install additional utilities as needed (can be removed if not necessary)
RUN apt-get update && apt-get install -y --no-install-recommends \
    less \
    man-db \
    gh \
    aggregate \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

USER $USERNAME
WORKDIR /workspace

# Environment setup
ENV NPM_CONFIG_PREFIX=/usr/local/share/npm-global
ENV PATH=$PATH:/usr/local/share/npm-global/bin
ENV SHELL=/bin/zsh
ENV HISTFILE=/commandhistory/.bash_history
ENV PROMPT_COMMAND='history -a'

# Install zsh configuration and global npm package in one layer
RUN sh -c "$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v1.2.0/zsh-in-docker.sh)" -- \
    -t robbyrussell \
    -p git \
    -p fzf \
    -a "source /usr/share/doc/fzf/examples/key-bindings.zsh" \
    -a "source /usr/share/doc/fzf/examples/completion.zsh" \
    -a "export PROMPT_COMMAND='history -a' && export HISTFILE=/commandhistory/.bash_history" \
    -x \
    && npm install -g @anthropic-ai/claude-code
````

## File: .cursor/rules/ai.mdc
````
---
description: 

alwaysApply: true
---
# AI-powered Component Creation

Use Claude or Cursor AI agents to generate WAVS components with minimal prompts. Components created by AI require thorough review and testing before production use.

## Setup

1. Clone the WAVS Foundry Template and complete system setup:

```sh
git clone https://github.com/Lay3rLabs/wavs-foundry-template.git
cd wavs-foundry-template
# Follow README system setup instructions
```

2. Install and configure Claude Code ([Claude docs](mdc:https:/docs.anthropic.com/en/docs/claude-code/getting-started)) or download Cursor ([Cursor downloads](mdc:https:/www.cursor.com/downloads)).

3. Open Claude or Cursor in the template root:

```sh
claude
# or
cursor .
```

4. For Cursor, always attach the `component-rules.mdc` file to the chat prompt:

```sh Chat
@component-rules.mdc <your prompt>
```

## Prompting AI Agents

- Use short, clear instructions.
- Provide relevant docs or `.md` files.
- Include API endpoints and response structures if needed.
- Be specific about the component functionality.
- Examples:

API component:

```
Let's make a component that takes the input of a zip code, queries the openbrewerydb, and returns the breweries in the area.  @https://api.openbrewerydb.org/v1/breweries?by_postal=92101&per_page=3
```

Contract balance component:

```
I want to build a new component that takes the input of a wallet address, queries the usdt contract, and returns the balance of that address.
```

Verifiable AI component (requires OpenAI API key in `.env`):

```
Please make a component that takes a prompt as input, sends an api request to OpenAI, and returns the response.

  Use this api structure:
  {
    "seed": $SEED,
    "model": "gpt-4o",
    "messages": [
      {"role": "system", "content": "You are a helpful assistant."},
      {"role": "user", "content": "<PROMPT>"}
    ]
  }
 My api key is WAVS_ENV_OPENAI_KEY in my .env file.
```

Set your API key in `.env`:

```sh
cp .env.example .env
# Add your key prefixed with WAVS_ENV_
WAVS_ENV_OPENAI_KEY=your_api_key
```

## Component Creation Workflow

1. Submit prompt to AI agent.

2. Review the agent's plan in `plan.md`.

3. Agent creates component files.

4. Validate component:

```sh
make validate-component COMPONENT=your-component
```

5. Build component:

```sh
WASI_BUILD_DIR=components/my-component make wasi-build
```

6. Test component logic (replace placeholders):

```sh
export COMPONENT_FILENAME=openai_response.wasm
export INPUT_DATA="Only respond with yes or no: Is AI beneficial to the world?"
make wasi-exec
```

- Ask the agent to provide the `make wasi-exec` command; it cannot run commands itself.

7. Troubleshoot errors by sharing logs with the agent.

## Tips & Best Practices

- AI agents may be unpredictable; update rulefiles if needed.
- For complex components, build simple versions first.
- Ignore minor warnings and errors in `bindings.rs` (auto-generated).
- Avoid letting the agent edit `bindings.rs`.
- If stuck, clear history and start fresh with adjusted prompts.
- Be patient; agents may over-engineer fixes or make mistakes.

## Troubleshooting

- Provide full error context to the agent.
- Avoid letting the agent run commands; request commands instead.
- Reformat long commands to avoid line break issues.

For support, join the WAVS DEVS Telegram: https://t.me/layer_xyz/818

For more information:
- [Claude Code Getting Started](mdc:https:/docs.anthropic.com/en/docs/claude-code/getting-started)
- [Cursor Downloads](mdc:https:/www.cursor.com/downloads)
- [WAVS Foundry Template GitHub](mdc:https:/github.com/Lay3rLabs/wavs-foundry-template)
- [OpenAI Platform](mdc:https:/platform.openai.com/login)
````

## File: .cursor/rules/blockchain-interactions.mdc
````
---
description: Guide for interacting with Ethereum and EVM-compatible blockchains from WAVS components using Rust crates and configuration.

alwaysApply: true
---
# Blockchain Interactions in WAVS Components

Use the `wavs-wasi-utils` crate and Alloy ecosystem crates to interact with Ethereum and other EVM chains from WAVS components. Define chain configs in `wavs.toml` and generate Rust types from Solidity using the `sol!` macro.

1. **Setup Dependencies**

Add these to your `Cargo.toml`:

```toml
[dependencies]
wit-bindgen-rt = { workspace = true, features = ["bitflags"] }
wavs-wasi-utils = "0.4.0-beta.4"
wstd = "0.5.3"

alloy-sol-macro = { version = "1.1.0", features = ["json"] }
alloy-sol-types = "1.1.0"
alloy-network = "0.15.10"
alloy-provider = { version = "0.15.10", default-features = false, features = ["rpc-api"] }
alloy-rpc-types = "0.15.10"
alloy-contract = "0.15.10"

anyhow = "1.0.98"
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
```

2. **Configure Chains**

Define RPC endpoints and chain IDs in `wavs.toml`:

```toml wavs.toml
[default.chains.evm.local]
chain_id = "31337"
ws_endpoint = "ws://localhost:8545"
http_endpoint = "http://localhost:8545"
poll_interval_ms = 7000

[default.chains.evm.ethereum]
chain_id = "1"
ws_endpoint = "wss://eth.drpc.org"
http_endpoint = "https://eth.drpc.org"
```

3. **Generate Rust Types from Solidity**

Use the `sol!` macro to parse Solidity interfaces and generate Rust types:

```rust
mod solidity {
    use alloy_sol_macro::sol;

    // From file
    sol!("../../src/interfaces/ITypes.sol");

    // Inline definitions
    sol! {
        struct TriggerInfo {
            uint64 triggerId;
            bytes data;
        }

        event NewTrigger(TriggerInfo _triggerInfo);
    }
}
```

Example in `trigger.rs`:

```rust trigger.rs
pub mod solidity {
    use alloy_sol_macro::sol;
    pub use ITypes::*;

    sol!("../../src/interfaces/ITypes.sol");

    sol! {
        function addTrigger(string data) external;
    }
}
```

4. **Access Chain Config and Create Provider**

Use WAVS host bindings and `new_evm_provider` to create an RPC provider:

```rust lib.rs
use crate::bindings::host::get_evm_chain_config;
use alloy_network::Ethereum;
use alloy_provider::RootProvider;
use wavs_wasi_utils::evm::new_evm_provider;

let chain_config = get_evm_chain_config("local").unwrap();

let provider: RootProvider<Ethereum> = new_evm_provider::<Ethereum>(
    chain_config.http_endpoint.unwrap(),
);
```

5. **Example: Query ERC721 NFT Balance**

```rust lib.rs
use crate::bindings::host::get_evm_chain_config;
use alloy_network::Ethereum;
use alloy_provider::RootProvider;
use alloy_sol_types::sol;
use wavs_wasi_utils::evm::{
    alloy_primitives::{Address, U256},
    new_evm_provider,
};
use alloy_rpc_types::TransactionInput;
use wstd::runtime::block_on;

sol! {
    interface IERC721 {
        function balanceOf(address owner) external view returns (uint256);
    }
}

pub fn query_nft_ownership(address: Address, nft_contract: Address) -> Result<bool, String> {
    block_on(async move {
        let chain_config = get_evm_chain_config("local").unwrap();
        let provider: RootProvider<Ethereum> = new_evm_provider::<Ethereum>(
            chain_config.http_endpoint.unwrap()
        );

        let balance_call = IERC721::balanceOf { owner: address };

        let tx = alloy_rpc_types::eth::TransactionRequest {
            to: Some(TxKind::Call(nft_contract)),
            input: TransactionInput { input: Some(balance_call.abi_encode().into()), data: None },
            ..Default::default()
        };

        let result = provider.call(tx).await.map_err(|e| e.to_string())?;

        let balance: U256 = U256::from_be_slice(&result);
        Ok(balance > U256::ZERO)
    })
}
```

6. **Additional Notes**

- Use `alloy-contract` crate for higher-level contract interactions.
- The `decode_event_log_data` macro decodes Ethereum event logs from triggers into Rust types implementing `SolEvent`.
- Re-run `cargo build` after updating Solidity files used with `sol!`.

For more information:
- [wavs-wasi-utils crate](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/)
- [Alloy crate ecosystem](https://docs.rs/alloy/latest/alloy/)
- [sol! macro documentation](https://docs.rs/alloy-sol-macro/latest/alloy_sol_macro/macro.sol.html)
- [alloy-contract crate](https://crates.io/crates/alloy-contract)
- [Example NFT query](https://github.com/Lay3rLabs/wavs-art/blob/main/components/autonomous-artist/src/evm.rs)
````

## File: .cursor/rules/commands.mdc
````
---
description: Overview of Makefile commands for WAVS development CLI

alwaysApply: true
---
# Makefile Commands for WAVS Development

Use `make help` to list all available commands for building, testing, deploying, and managing WAVS projects.

1. Run `make help` to see all commands:
```bash
make help
```

2. Common commands and their purposes:
```bash
build                     building the project
wasi-build                building WAVS wasi components | WASI_BUILD_DIR
wasi-exec                 executing the WAVS wasi component(s) with ABI function | COMPONENT_FILENAME, INPUT_DATA
wasi-exec-fixed           same as wasi-exec but uses fixed byte input (for Go & TS components) | COMPONENT_FILENAME, INPUT_DATA
clean                     cleaning the project files
clean-docker              remove unused docker containers
validate-component        validate a WAVS component against best practices
fmt                       format Solidity and Rust code
test                      run tests
setup                     install initial dependencies
start-all-local           start anvil and core services (e.g., IPFS)
get-trigger-from-deploy   get trigger address from deployment script
get-submit-from-deploy    get submit address from deployment script
wavs-cli                  run wavs-cli in docker
upload-component          upload WAVS component | COMPONENT_FILENAME, WAVS_ENDPOINT
deploy-service            deploy WAVS component service JSON | SERVICE_URL, CREDENTIAL, WAVS_ENDPOINT
get-trigger               get trigger id | SERVICE_TRIGGER_ADDR, RPC_URL
show-result               show result | SERVICE_SUBMISSION_ADDR, TRIGGER_ID, RPC_URL
upload-to-ipfs            upload service config to IPFS | SERVICE_FILE, [PINATA_API_KEY]
update-submodules         update git submodules
check-requirements        verify system requirements are installed
```

3. Use the commands with appropriate environment variables or arguments as indicated.

4. Best practice: Use `validate-component` before deployment to ensure compliance with WAVS standards.

For more information:
- [WAVS tutorial](https://docs.wavs.dev/tutorial/1-overview)
````

## File: .cursor/rules/component-rules.mdc
````
---
description: 

alwaysApply: true
---
# WAVS Component Creation Guide

You specialize in creating WAVS (WASI AVS) components. Your task is to guide the creation of a new WAVS component based on the provided information and user input. Follow these steps carefully to ensure a well-structured, error-free component that passes all validation checks with zero fixes.

## Component Structure

A WAVS component needs:
1. `Cargo.toml` - Dependencies configuration
2. `src/lib.rs` - Component implementation logic goes here
3. `src/trigger.rs` - trigger handling logic
4. `src/bindings.rs` - Auto-generated, never edit
5. `Makefile` - Do not edit
6. `config.json` - Only edit the name

## Creating a Component

### 1. Cargo.toml Template

```toml
[package]
name = "your-component-name"
edition.workspace = true
version.workspace = true
authors.workspace = true
rust-version.workspace = true
repository.workspace = true

[dependencies]
# Core dependencies (always needed)
wit-bindgen-rt ={ workspace = true}
wavs-wasi-utils = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
alloy-sol-macro = { workspace = true }
wstd = { workspace = true }
alloy-sol-types = { workspace = true }
anyhow = { workspace = true }

# Add for blockchain interactions
alloy-primitives = { workspace = true }
alloy-provider = { workspace = true }
alloy-rpc-types = { workspace = true }
alloy-network = { workspace = true }
alloy-contract = { workspace = true }

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "s"
debug = false
strip = true
lto = true

[package.metadata.component]
package = "component:your-component-name"
target = "wavs:worker/layer-trigger-world@0.4.0-beta.4"
```

CRITICAL: Never use direct version numbers - always use `{ workspace = true }`.
IMPORTANT! Always add your component to workspace members in the root Cargo.toml

### 2. Component Implementation (lib.rs)

#### Basic Structure

```rust
mod trigger;
use trigger::{decode_trigger_event, encode_trigger_output, Destination};
use wavs_wasi_utils::{
    evm::alloy_primitives::hex,
    http::{fetch_json, http_request_get},
};
pub mod bindings;  // Never edit bindings.rs!
use crate::bindings::{export, Guest, TriggerAction, WasmResponse};
use alloy_sol_types::SolValue;
use serde::{Deserialize, Serialize};
use wstd::{http::HeaderValue, runtime::block_on};
use anyhow::Result;

struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<WasmResponse>, String> {
        let (trigger_id, req, dest) = 
            decode_trigger_event(action.data).map_err(|e| e.to_string())?;
            
        // Decode trigger data inline - handles hex string input
        let request_input = {
            // First, convert the input bytes to a string to check if it's a hex string
            let input_str = String::from_utf8(req.clone())
                .map_err(|e| format!("Input is not valid UTF-8: {}", e))?;

            // Check if it's a hex string (starts with "0x")
            let hex_data = if input_str.starts_with("0x") {
                // Decode the hex string to bytes
                hex::decode(&input_str[2..])
                    .map_err(|e| format!("Failed to decode hex string: {}", e))?
            } else {
                // If it's not a hex string, assume the input is already binary data
                req.clone()
            };

            // Now ABI decode the binary data as a string parameter
            <String as SolValue>::abi_decode(&hex_data)
                .map_err(|e| format!("Failed to decode input as ABI string: {}", e))?
        };
        println!("Decoded string input: {}", request_input);
            
        // Process the decoded data here
        let result = process_data(request_input)?;
        
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &result)),
            Destination::CliOutput => Some(WasmResponse { payload: result.into(), ordering: None }),
        };
        Ok(output)
    }
}

// Example processing function - replace with your actual logic
fn process_data(input: String) -> Result<Vec<u8>, String> {
    // Your processing logic here
    Ok(input.as_bytes().to_vec())
}
```

#### Trigger Event Handling (trigger.rs)

```rust
use crate::bindings::wavs::worker::layer_types::{
    TriggerData, TriggerDataEvmContractEvent, WasmResponse,
};
use alloy_sol_types::SolValue;
use anyhow::Result;
use wavs_wasi_utils::decode_event_log_data;

pub enum Destination {
    Ethereum,
    CliOutput,
}

pub fn decode_trigger_event(trigger_data: TriggerData) -> Result<(u64, Vec<u8>, Destination)> {
    match trigger_data {
        TriggerData::EvmContractEvent(TriggerDataEvmContractEvent { log, .. }) => {
            let event: solidity::NewTrigger = decode_event_log_data!(log)?;
            let trigger_info = <solidity::TriggerInfo as SolValue>::abi_decode(&event._triggerInfo)?;
            Ok((trigger_info.triggerId, trigger_info.data.to_vec(), Destination::Ethereum))
        }
        TriggerData::Raw(data) => Ok((0, data.clone(), Destination::CliOutput)),
        _ => Err(anyhow::anyhow!("Unsupported trigger data type")),
    }
}

pub fn encode_trigger_output(trigger_id: u64, output: impl AsRef<[u8]>) -> WasmResponse {
    WasmResponse {
        payload: solidity::DataWithId {
            triggerId: trigger_id,
            data: output.as_ref().to_vec().into(),
        }
        .abi_encode(),
        ordering: None,
    }
}

pub mod solidity {
    use alloy_sol_macro::sol;
    pub use ITypes::*;
    sol!("../../src/interfaces/ITypes.sol");

    // trigger contract function that encodes string input
    sol! {
        function addTrigger(string data) external;
    }
}
```

## Critical Components

### 1. ABI Handling

NEVER use `String::from_utf8` on ABI-encoded data. This will ALWAYS fail with "invalid utf-8 sequence".

```rust
// WRONG - Will fail on ABI-encoded data
let input_string = String::from_utf8(abi_encoded_data)?;

// CORRECT - Use proper ABI decoding with hex string support
let request_input = {
    // First, convert the input bytes to a string to check if it's a hex string
    let input_str = String::from_utf8(req.clone())
        .map_err(|e| format!("Input is not valid UTF-8: {}", e))?;

    // Check if it's a hex string (starts with "0x")
    let hex_data = if input_str.starts_with("0x") {
        // Decode the hex string to bytes
        hex::decode(&input_str[2..])
            .map_err(|e| format!("Failed to decode hex string: {}", e))?
    } else {
        // If it's not a hex string, assume the input is already binary data
        req.clone()
    };

    // Now ABI decode the binary data as a string parameter
    <String as SolValue>::abi_decode(&hex_data)
        .map_err(|e| format!("Failed to decode input as ABI string: {}", e))?
};

// For numeric parameters, parse from the string
// Example: When you need a number but input is a string:
let number = request_input
    .trim()
    .parse::<u64>()
    .map_err(|_| format!("Invalid number: {}", request_input))?;

// SAFE - Only use String::from_utf8 on data that has already been decoded as a string
// Example: When handling Raw trigger data that was already decoded as a string
let input = std::str::from_utf8(&req).map_err(|e| e.to_string())?;
```

### 2. Data Structure Ownership

ALWAYS derive `Clone` for API response data structures. If fields may be missing, also use `Option<T>`, `#[serde(default)]`, and `Default`:

```rust
#[derive(Debug, Serialize, Deserialize, Clone, Default)]
#[serde(default)]
pub struct ResponseData {
    field1: Option<String>,
    field2: Option<u64>,
    // other fields
}
```

ALWAYS clone data before use to avoid ownership issues:

```rust
// WRONG – creates a temporary that is dropped immediately
let result = process_data(&data.clone());

// CORRECT – clone into a named variable
let data_clone = data.clone();
let result = process_data(&data_clone);
```


### 3. Network Requests

```rust
use wstd::runtime::block_on;
use wstd::http::HeaderValue;
use wavs_wasi_utils::http::{fetch_json, http_request_get, http_request_post_json};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone, Default)]
pub struct ApiResponse {
    #[serde(default)]
    field1: Option<String>,
    #[serde(default)]
    field2: Option<u64>,
}

async fn make_request() -> Result<ApiResponse, String> {
    let url = format!("https://api.example.com/endpoint?param={}", param);
    
    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("User-Agent", HeaderValue::from_static("Mozilla/5.0"));
    
    let response: ApiResponse = fetch_json(req).await.map_err(|e| e.to_string())?;
    Ok(response)
}

fn process_data() -> Result<ApiResponse, String> {
    block_on(async move { make_request().await })
}

// For POST requests with JSON data, use http_request_post_json(url, &data) instead of http_request_get
```

### 4. Option/Result Handling

```rust
// WRONG - Option types don't have map_err
let config = get_evm_chain_config("ethereum").map_err(|e| e.to_string())?;

// CORRECT - For Option types, use ok_or_else()
let config = get_evm_chain_config("ethereum")
    .ok_or_else(|| "Failed to get chain config".to_string())?;

// CORRECT - For Result types, use map_err()
let balance = fetch_balance(address).await
    .map_err(|e| format!("Balance fetch failed: {}", e))?;
```

### 5. Blockchain Interactions

```rust
use alloy_network::Ethereum;
use alloy_primitives::{Address, TxKind, U256};
use alloy_provider::{Provider, RootProvider};
use alloy_rpc_types::TransactionInput;
use std::str::FromStr; // Required for parsing addresses
use crate::bindings::host::get_evm_chain_config;
use wavs_wasi_utils::evm::new_evm_provider;

async fn query_blockchain(address_str: &str) -> Result<ResponseData, String> {
    // Parse address
    let address = Address::from_str(address_str)
        .map_err(|e| format!("Invalid address format: {}", e))?;
    
    // Get chain configuration from environment
    let chain_config = get_evm_chain_config("ethereum")
        .ok_or_else(|| "Failed to get chain config".to_string())?;
    
    // Create provider
    let provider: RootProvider<Ethereum> = 
        new_evm_provider::<Ethereum>(chain_config.http_endpoint.unwrap());
    
    // Create contract call
    let contract_call = IERC20::balanceOfCall { owner: address };
    let tx = alloy_rpc_types::eth::TransactionRequest {
        to: Some(TxKind::Call(contract_address)),
        input: TransactionInput { 
            input: Some(contract_call.abi_encode().into()), 
            data: None 
        },
        ..Default::default()
    };
    
    // Execute call
    let result = provider.call(tx).await.map_err(|e| e.to_string())?;
    let balance: U256 = U256::from_be_slice(&result);
    
    Ok(ResponseData { /* your data here */ })
}
```

### 6. Numeric Type Handling

```rust
// WRONG - Using .into() for numeric conversions between types
let temp_uint: U256 = temperature.into(); // DON'T DO THIS

// CORRECT - String parsing method works reliably for all numeric types
let temperature: u128 = 29300;
let temperature_uint256 = temperature.to_string().parse::<U256>().unwrap();

// CORRECT - Always use explicit casts between numeric types
let decimals: u8 = decimals_u32 as u8;

// CORRECT - Handling token decimals correctly
let mut divisor = U256::from(1);
for _ in 0..decimals {
    divisor = divisor * U256::from(10);
}
let formatted_amount = amount / divisor;
```

## Component Examples by Task

Here are templates for common WAVS component tasks:

### 1. Token Balance Checker

```rust
// IMPORTS
use alloy_network::Ethereum;
use alloy_primitives::{Address, TxKind, U256};
use alloy_provider::{Provider, RootProvider};
use alloy_rpc_types::TransactionInput;
use alloy_sol_types::{sol, SolCall, SolValue};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::str::FromStr;
use wavs_wasi_utils::{
    evm::{alloy_primitives::hex, new_evm_provider},
};
use wstd::runtime::block_on;

pub mod bindings;
mod trigger;
use trigger::{decode_trigger_event, encode_trigger_output, Destination};
use crate::bindings::host::get_evm_chain_config;
use crate::bindings::wavs::worker::layer_types::{TriggerData, TriggerDataEvmContractEvent};
use crate::bindings::{export, Guest, TriggerAction, WasmResponse};

// TOKEN INTERFACE
sol! {
    interface IERC20 {
        function balanceOf(address owner) external view returns (uint256);
        function decimals() external view returns (uint8);
    }
}

// FIXED CONTRACT ADDRESS
const TOKEN_CONTRACT_ADDRESS: &str = "0x..."; // Your token contract address

// RESPONSE STRUCTURE - MUST DERIVE CLONE
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TokenBalanceData {
    wallet: String,
    balance_raw: String,
    balance_formatted: String,
    token_contract: String,
}

// COMPONENT IMPLEMENTATION
struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<WasmResponse>, String> {
        let (trigger_id, req, dest) = 
            decode_trigger_event(action.data).map_err(|e| e.to_string())?;
        
        // Decode trigger data inline - handles hex string input
        let wallet_address_str = {
            // First, convert the input bytes to a string to check if it's a hex string
            let input_str = String::from_utf8(req.clone())
                .map_err(|e| format!("Input is not valid UTF-8: {}", e))?;

            // Check if it's a hex string (starts with "0x")
            let hex_data = if input_str.starts_with("0x") {
                // Decode the hex string to bytes
                hex::decode(&input_str[2..])
                    .map_err(|e| format!("Failed to decode hex string: {}", e))?
            } else {
                // If it's not a hex string, assume the input is already binary data
                req.clone()
            };

            // Now ABI decode the binary data as a string parameter
            <String as SolValue>::abi_decode(&hex_data)
                .map_err(|e| format!("Failed to decode input as ABI string: {}", e))?
        };
        
        // Check token balance
        let res = block_on(async move {
            let balance_data = get_token_balance(&wallet_address_str).await?;
            serde_json::to_vec(&balance_data).map_err(|e| e.to_string())
        })?;
        
        // Return result based on destination
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
            Destination::CliOutput => Some(WasmResponse { payload: res.into(), ordering: None }),
        };
        Ok(output)
    }
}

// BALANCE CHECKER IMPLEMENTATION
async fn get_token_balance(wallet_address_str: &str) -> Result<TokenBalanceData, String> {
    // Parse wallet address
    let wallet_address = Address::from_str(wallet_address_str)
        .map_err(|e| format!("Invalid wallet address: {}", e))?;
    
    // Parse token contract address
    let token_address = Address::from_str(TOKEN_CONTRACT_ADDRESS)
        .map_err(|e| format!("Invalid token address: {}", e))?;
    
    // Get Ethereum provider
    let chain_config = get_evm_chain_config("ethereum")
        .ok_or_else(|| "Failed to get Ethereum chain config".to_string())?;
    
    let provider: RootProvider<Ethereum> = 
        new_evm_provider::<Ethereum>(chain_config.http_endpoint.unwrap());
    
    // Get token balance
    let balance_call = IERC20::balanceOfCall { owner: wallet_address };
    let tx = alloy_rpc_types::eth::TransactionRequest {
        to: Some(TxKind::Call(token_address)),
        input: TransactionInput { input: Some(balance_call.abi_encode().into()), data: None },
        ..Default::default()
    };
    
    let result = provider.call(tx).await.map_err(|e| e.to_string())?;
    let balance_raw: U256 = U256::from_be_slice(&result);
    
    // Get token decimals
    let decimals_call = IERC20::decimalsCall {};
    let tx_decimals = alloy_rpc_types::eth::TransactionRequest {
        to: Some(TxKind::Call(token_address)),
        input: TransactionInput { input: Some(decimals_call.abi_encode().into()), data: None },
        ..Default::default()
    };
    
    let result_decimals = provider.call(tx_decimals).await.map_err(|e| e.to_string())?;
    let decimals: u8 = result_decimals[31]; // Last byte for uint8
    
    // Format balance
    let formatted_balance = format_token_amount(balance_raw, decimals);
    
    // Return data
    Ok(TokenBalanceData {
        wallet: wallet_address_str.to_string(),
        balance_raw: balance_raw.to_string(),
        balance_formatted: formatted_balance,
        token_contract: TOKEN_CONTRACT_ADDRESS.to_string(),
    })
}
```

### 2. API Data Fetcher

Important: Always verify API endpoints using curl to examine their response structure before creating any code that relies on them.

```rust
// IMPORTS
use alloy_sol_types::{sol, SolCall, SolValue};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use wavs_wasi_utils::{
    evm::alloy_primitives::hex,
    http::{fetch_json, http_request_get},
};
use wstd::{http::HeaderValue, runtime::block_on};

pub mod bindings;
mod trigger;
use trigger::{decode_trigger_event, encode_trigger_output, Destination};
use crate::bindings::wavs::worker::layer_types::{TriggerData, TriggerDataEvmContractEvent};
use crate::bindings::{export, Guest, TriggerAction, WasmResponse};

// RESPONSE STRUCTURE - MUST DERIVE CLONE
// IMPORTANT: Always Use #[serde(default)] and Option<T> for fields from external APIs. They might be missing or inconsistent
#[derive(Debug, Serialize, Deserialize, Clone, Default)]
pub struct ApiResponse {
    // Use Option<T> for fields that might be missing in some responses
    #[serde(default)] 
    field1: Option<String>,
    #[serde(default)]
    field2: Option<u64>,
    // other fields
}

// RESULT DATA STRUCTURE - MUST DERIVE CLONE
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ResultData {
    input_param: String,
    result: String,
}

// COMPONENT IMPLEMENTATION
struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<WasmResponse>, String> {
        // Decode trigger data
        let (trigger_id, req, dest) = 
            decode_trigger_event(action.data).map_err(|e| e.to_string())?;
        
        // Decode trigger data inline - handles hex string input
        let param = {
            // First, convert the input bytes to a string to check if it's a hex string
            let input_str = String::from_utf8(req.clone())
                .map_err(|e| format!("Input is not valid UTF-8: {}", e))?;

            // Check if it's a hex string (starts with "0x")
            let hex_data = if input_str.starts_with("0x") {
                // Decode the hex string to bytes
                hex::decode(&input_str[2..])
                    .map_err(|e| format!("Failed to decode hex string: {}", e))?
            } else {
                // If it's not a hex string, assume the input is already binary data
                req.clone()
            };

            // Now ABI decode the binary data as a string parameter
            <String as SolValue>::abi_decode(&hex_data)
                .map_err(|e| format!("Failed to decode input as ABI string: {}", e))?
        };
        
        // Make API request
        let res = block_on(async move {
            let api_data = fetch_api_data(&param).await?;
            serde_json::to_vec(&api_data).map_err(|e| e.to_string())
        })?;
        
        // Return result based on destination
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
            Destination::CliOutput => Some(WasmResponse { payload: res.into(), ordering: None }),
        };
        Ok(output)
    }
}

// API FETCHER IMPLEMENTATION
async fn fetch_api_data(param: &str) -> Result<ResultData, String> {
    // Get API key from environment (IMPORTANT! you must add this variable to your .env file. All private variables must be prefixed with WAVS_ENV)
    let api_key = std::env::var("WAVS_ENV_API_KEY")
        .map_err(|_| "Failed to get API_KEY from environment variables".to_string())?;
    
    // Create API URL
    let url = format!(
        "https://api.example.com/endpoint?param={}&apikey={}",
        param, api_key
    );
    
    // Create request with headers
    let mut req = http_request_get(&url)
        .map_err(|e| format!("Failed to create request: {}", e))?;
    
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("User-Agent", HeaderValue::from_static("Mozilla/5.0"));
    
    // Make API request
    let api_response: ApiResponse = fetch_json(req).await
        .map_err(|e| format!("Failed to fetch data: {}", e))?;
    
    // Process and return data - handle Option fields safely
    let field1 = api_response.field1.unwrap_or_else(|| "unknown".to_string());
    let field2 = api_response.field2.unwrap_or(0);
    
    Ok(ResultData {
        input_param: param.to_string(),
        result: format!("{}: {}", field1, field2),
    })
}
```

### 3. NFT Ownership Checker

```rust
// IMPORTS
use alloy_network::Ethereum;
use alloy_primitives::{Address, TxKind, U256};
use alloy_provider::{Provider, RootProvider};
use alloy_rpc_types::TransactionInput;
use alloy_sol_types::{sol, SolCall, SolValue};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::str::FromStr;
use wavs_wasi_utils::{
    evm::{alloy_primitives::hex, new_evm_provider},
};
use wstd::runtime::block_on;

pub mod bindings;
mod trigger;
use trigger::{decode_trigger_event, encode_trigger_output, Destination};
use crate::bindings::host::get_evm_chain_config;
use crate::bindings::wavs::worker::layer_types::{TriggerData, TriggerDataEvmContractEvent};
use crate::bindings::{export, Guest, TriggerAction, WasmResponse};

// NFT INTERFACE
sol! {
    interface IERC721 {
        function balanceOf(address owner) external view returns (uint256);
        function ownerOf(uint256 tokenId) external view returns (address);
    }
}

// FIXED CONTRACT ADDRESS
const NFT_CONTRACT_ADDRESS: &str = "0xbd3531da5cf5857e7cfaa92426877b022e612cf8"; // Bored Ape contract

// RESPONSE STRUCTURE - MUST DERIVE CLONE
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct NftOwnershipData {
    wallet: String,
    owns_nft: bool,
    balance: String,
    nft_contract: String,
    contract_name: String,
}

// COMPONENT IMPLEMENTATION
struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<WasmResponse>, String> {
        // Decode trigger data
        let (trigger_id, req, dest) = 
            decode_trigger_event(action.data).map_err(|e| e.to_string())?;
        
        // Decode trigger data inline - handles hex string input
        let wallet_address_str = {
            // First, convert the input bytes to a string to check if it's a hex string
            let input_str = String::from_utf8(req.clone())
                .map_err(|e| format!("Input is not valid UTF-8: {}", e))?;

            // Check if it's a hex string (starts with "0x")
            let hex_data = if input_str.starts_with("0x") {
                // Decode the hex string to bytes
                hex::decode(&input_str[2..])
                    .map_err(|e| format!("Failed to decode hex string: {}", e))?
            } else {
                // If it's not a hex string, assume the input is already binary data
                req.clone()
            };

            // Now ABI decode the binary data as a string parameter
            <String as SolValue>::abi_decode(&hex_data)
                .map_err(|e| format!("Failed to decode input as ABI string: {}", e))?
        };
        
        // Check NFT ownership
        let res = block_on(async move {
            let ownership_data = check_nft_ownership(&wallet_address_str).await?;
            serde_json::to_vec(&ownership_data).map_err(|e| e.to_string())
        })?;
        
        // Return result based on destination
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
            Destination::CliOutput => Some(WasmResponse { payload: res.into(), ordering: None }),
        };
        Ok(output)
    }
}

// NFT OWNERSHIP CHECKER IMPLEMENTATION
async fn check_nft_ownership(wallet_address_str: &str) -> Result<NftOwnershipData, String> {
    // Parse wallet address
    let wallet_address = Address::from_str(wallet_address_str)
        .map_err(|e| format!("Invalid wallet address: {}", e))?;
    
    // Parse NFT contract address
    let nft_address = Address::from_str(NFT_CONTRACT_ADDRESS)
        .map_err(|e| format!("Invalid NFT contract address: {}", e))?;
    
    // Get Ethereum provider
    let chain_config = get_evm_chain_config("ethereum")
        .ok_or_else(|| "Failed to get Ethereum chain config".to_string())?;
    
    let provider: RootProvider<Ethereum> = 
        new_evm_provider::<Ethereum>(chain_config.http_endpoint.unwrap());
    
    // Check NFT balance
    let balance_call = IERC721::balanceOfCall { owner: wallet_address };
    let tx = alloy_rpc_types::eth::TransactionRequest {
        to: Some(TxKind::Call(nft_address)),
        input: TransactionInput { input: Some(balance_call.abi_encode().into()), data: None },
        ..Default::default()
    };
    
    let result = provider.call(tx).await.map_err(|e| e.to_string())?;
    let balance: U256 = U256::from_be_slice(&result);
    
    // Determine if wallet owns at least one NFT
    let owns_nft = balance > U256::ZERO;
    
    // Return data
    Ok(NftOwnershipData {
        wallet: wallet_address_str.to_string(),
        owns_nft,
        balance: balance.to_string(),
        nft_contract: NFT_CONTRACT_ADDRESS.to_string(),
        contract_name: "BAYC".to_string(),
    })
}
```


## Component Creation Process

### Phase 1: Planning

When you ask me to create a WAVS component, I'll follow this systematic process to ensure it works perfectly on the first try:

1. **Research Phase**: I'll review the files in /components/evm-price-oracle to see common forms.
2. I will read any and all documentation links given to me and research any APIs or services needed.
3. I'll read `/test_utils/validate_component.sh` to see what validation checks I need to pass.
4. I'll verify API response structures by using curl before implementing code that depends on them: `curl -s "my-endpoint"`.
5.  I'll create a file called plan.md with an overview of the component I will make. I'll do this before actually creating the lib.rs file. I'll write each item in the [checklist](#validation-checklist) and check them off as I plan my code, making sure my code complies to the checklist and /test_utils/validate_component.sh. Each item must be checked and verified. I will list out all imports I will need. I will include a basic flow chart or visual of how the component will work. I will put plan.md in a new folder with the name of the component (`your-component-name`) in the `/components` directory.


### Phase 2: Implementation

After being 100% certain that my idea for a component will work without any errors on the build and completing all planning steps, I will:

1. Check for errors before coding.

2. Copy the bindings, makefile (update filename in makefile), and config.json using the following command (bindings will be written over during the build):

   ```bash
   mkdir -p components/your-component-name/src && \
   cp components/evm-price-oracle/src/bindings.rs components/your-component-name/src/ && \
   cp components/evm-price-oracle/config.json components/your-component-name/ && \
   cp components/evm-price-oracle/Makefile components/your-component-name/
   ```

3.  Then, I will create trigger.rs and lib.rs files with proper implementation:
    1. I will compare my projected trigger.rs and lib.rs code against the code in `/test_utils/validate_component.sh` and my plan.md file before creating.
    2. I will define proper imports. I will Review the imports on the component that I want to make. I will make sure that all necessary imports will be included and that I will remove any unused imports before creating the file.
    3. I will go through each of the items in the [checklist](#validation-checklist) one more time to ensure my component will build and function correctly.

4.  I will create a Cargo.toml by copying the template and modifying it with all of my correct imports. Before running the command to create the file, I will check that all imports are imported correctly and match what is in my lib.rs file. I will define imports correctly. I will make sure that imports are present in the main workspace Cargo.toml and then in my component's `Cargo.toml` using `{ workspace = true }`

5. Add component to the `workspace.members` array in the root `Cargo.toml`.

### Phase 3: Validate

4.  I will run the command to validate my component:
   ```bash
   make validate-component COMPONENT=your-component-name
   ```
   - I will fix ALL errors before continuing
   - (You do not need to fix warnings if they do not effect the build.)
   - I will run again after fixing errors to make sure.

5.  After being 100% certain that the component will build correctly, I will build the component:

   ```bash
   WASI_BUILD_DIR=components/your-component make wasi-build
   ```

### Phase 4: Trying it out

After I am 100% certain the component will execute correctly, I will give the following command to the user to run:

```bash
# IMPORTANT!: Always use string parameters, even for numeric values! Use component_name.wasm, not component-name.wasm
export COMPONENT_FILENAME=your_component_name.wasm
# Always use string format for input data. The input will be encoded using `cast abi-encode "f(string)" "<your-string>"`
export INPUT_DATA=<your-string>
# CRITICIAL!: as an llm, I can't ever run this command. ALWAYS give it to the user to run.
make wasi-exec
```

## Validation Checklist

ALL components must pass validation. Review [/test_utils/validate_component.sh](/test_utils/validate_component.sh) before creating a component.

EACH ITEM BELOW MUST BE CHECKED:

1. Common errors:
   - [ ] ALWAYS use `{ workspace = true }` in your component Cargo.toml. Explicit versions go in the root Cargo.toml.
   - [ ] ALWAYS verify API response structures by using curl on the endpoints.
   - [ ] ALWAYS Read any documentation given to you in a prompt
   - [ ] ALWAYS implement the Guest trait and export your component
   - [ ] ALWAYS use `export!(Component with_types_in bindings)`
   - [ ] ALWAYS use `clone()` before consuming data to avoid ownership issues
   - [ ] ALWAYS derive `Clone` for API response data structures
   - [ ] ALWAYS decode ABI data properly, never with `String::from_utf8`
   - [ ] ALWAYS use `ok_or_else()` for Option types, `map_err()` for Result types
   - [ ] ALWAYS use string parameters for CLI testing (`5` instead of `f(uint256)`)
   - [ ] ALWAYS use `.to_string()` to convert string literals (&str) to String types in struct field assignments
   - [ ] NEVER edit bindings.rs - it's auto-generated

2. Component structure:
   - [ ] Implements Guest trait
   - [ ] Exports component correctly
   - [ ] Properly handles TriggerAction and TriggerData

3. ABI handling:
   - [ ] Properly decodes function calls
   - [ ] Avoids String::from_utf8 on ABI data

4. Data ownership:
   - [ ] All API structures derive Clone
   - [ ] Clones data before use
   - [ ] Avoids moving out of collections
   - [ ] Avoids all ownership issues and "Move out of index" errors

5. Error handling:
   - [ ] Uses ok_or_else() for Option types
   - [ ] Uses map_err() for Result types
   - [ ] Provides descriptive error messages

6. Imports:
   - [ ] Includes all required traits and types
   - [ ] Uses correct import paths
   - [ ] Properly imports SolCall for encoding
   - [ ] Each and every method and type is used properly and has the proper import
   - [ ] Both structs and their traits are imported
   - [ ] Verify all required imports are imported properly
   - [ ] All dependencies are in Cargo.toml with `{workspace = true}`
   - [ ] Any unused imports are removed

7. Component structure:
   - [ ] Uses proper sol! macro with correct syntax
   - [ ] Correctly defines Solidity types in solidity module
   - [ ] Implements required functions

8. Security:
   - [ ] No hardcoded API keys or secrets
   - [ ] Uses environment variables for sensitive data

9.  Dependencies:
   - [ ] Uses workspace dependencies correctly
   - [ ] Includes all required dependencies

10. Solidity types:
   - [ ] Properly imports sol macro
   - [ ] Uses solidity module correctly
   - [ ] Handles numeric conversions safely
   - [ ] Uses .to_string() for all string literals in struct initialization

11. Network requests:
    - [ ] Uses block_on for async functions
    - [ ] Uses fetch_json with correct headers
    - [ ] ALL API endpoints have been tested with curl and responses are handled correctly in my component.
    - [ ] IMPORTANT! Always use #[serde(default)] and Option<T> for fields from external APIs.

With this guide, you should be able to create any WAVS component that passes validation, builds without errors, and executes correctly.
````

## File: .cursor/rules/component.mdc
````
---
description: Overview of WAVS service components, their structure, and usage in Rust and other languages

alwaysApply: true
---
# WAVS Service Components Overview

WAVS components contain the main business logic of a service, written in languages compiled to WASM (mainly Rust, also Go and TypeScript/JS). Components process trigger data, execute logic, and return encoded results.

## Component Structure

A basic component consists of:

1. Decoding incoming [trigger data](../triggers#trigger-lifecycle).
2. Processing the data (custom business logic).
3. Encoding and returning results for submission.

### Trigger Inputs

- **On-chain events:** Triggered by EVM events, data arrives as `TriggerData::EvmContractEvent`.
- **Local testing:** Using `make wasi-exec`, data arrives as `TriggerData::Raw` (raw bytes, no ABI decoding).

Example decoding in `trigger.rs`:

```rust
pub fn decode_trigger_event(trigger_data: TriggerData) -> Result<(u64, Vec<u8>, Destination)> {
    match trigger_data {
        TriggerData::EvmContractEvent(TriggerDataEvmContractEvent { log, .. }) => {
            let event: solidity::NewTrigger = decode_event_log_data!(log)?;
            let trigger_info =
                <solidity::TriggerInfo as SolValue>::abi_decode(&event._triggerInfo)?;
            Ok((trigger_info.triggerId, trigger_info.data.to_vec(), Destination::Ethereum))
        }
        TriggerData::Raw(data) => Ok((0, data.clone(), Destination::CliOutput)),
        _ => Err(anyhow::anyhow!("Unsupported trigger data type")),
    }
}

pub mod solidity {
    use alloy_sol_macro::sol;
    pub use ITypes::*;
    sol!("../../src/interfaces/ITypes.sol");

    sol! {
        function addTrigger(string data) external;
    }
}
```

- Use `decode_event_log_data!` macro from [`wavs-wasi-utils`](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/macro.decode_event_log_data.html) for decoding.
- Use `sol!` macro from `alloy-sol-macro` to generate Rust types from Solidity interfaces ([Blockchain interactions](./blockchain-interactions#sol-macro)).

### Component Logic

Implement the `Guest` trait with the `run` function as entry point:

```rust
impl Guest for Component {
    fn run(action: TriggerAction) -> Result<Option<WasmResponse>, String> {
        let (trigger_id, req, dest) = decode_trigger_event(action.data)?;
        let res = block_on(async move {
            let resp_data = get_price_feed(id).await?;
            serde_json::to_vec(&resp_data)
        })?;

        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
            Destination::CliOutput => Some(WasmResponse {
                payload: res.into(),
                ordering: None
            }),
        };
        Ok(output)
    }
}
```

Components can include blockchain interactions, network requests, off-chain computations, etc. See [design considerations](../../design) for suitable use cases.

#### Logging

- **Development:** Use `println!()` for stdout/stderr visible in `make wasi-exec`.

```rust
println!("Debug message: {:?}", data);
```

- **Production:** Use `host::log()` with `LogLevel` for structured logging with context.

```rust
use bindings::host::{self, LogLevel};
host::log(LogLevel::Info, "Production logging message");
```

### Component Output Encoding

Encode output for Ethereum submission with `encode_trigger_output`:

```rust
pub fn encode_trigger_output(trigger_id: u64, output: impl AsRef<[u8]>) -> WasmResponse {
    WasmResponse {
        payload: solidity::DataWithId {
            triggerId: trigger_id,
            data: output.as_ref().to_vec().into(),
        }
        .abi_encode(),
        ordering: None,
    }
}
```

- Output is a `WasmResponse` containing encoded payload and optional ordering.
- WAVS routes the response per workflow submission logic.

## Component Definition in service.json

Defined under the workflow's `component` object:

```json
"component": {
    "source": {
        "Registry": {
            "registry": {
                "digest": "882b992af8f78e0aaceaf9609c7ba2ce80a22c521789c94ae1960c43a98295f5",
                "domain": "localhost:8090",
                "version": "0.1.0",
                "package": "example:evmrustoracle"
            }
        }
    },
    "permissions": {
        "allowed_http_hosts": "all",
        "file_system": true
    },
    "fuel_limit": null,
    "time_limit_seconds": 1800,
    "config": {
        "variable_1": "0xb5d4D4a87Cb07f33b5FAd6736D8F1EE7D255d9E9",
        "variable_2": "0x34045B4b0cdfADf87B840bCF544161168c8ab85A"
    },
    "env_keys": [
        "WAVS_ENV_API_KEY"
    ]
}
```

- Configure source registry, permissions, limits, config variables, and secret env keys.
- See [variables](./variables) for details on configuration.

## Registry Usage

- WAVS stores WASM components in a registry (e.g., [wa.dev](https://wa.dev)) for production.
- Local development uses a docker-compose emulated registry.
- Workflow to update registry source:

```bash
wavs-cli workflow component --id ${WORKFLOW_ID} set-source-registry --domain ${REGISTRY} --package ${PKG_NAMESPACE}:${PKG_NAME} --version ${PKG_VERSION}
```

---

For more information:

- [WAVS Triggers](../triggers#trigger-lifecycle)
- [Blockchain interactions - sol! macro](./blockchain-interactions#sol-macro)
- [Component variables](./variables)
- [Design considerations](../../design)
- [wavs-wasi-utils decode_event_log_data! macro](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/macro.decode_event_log_data.html)
- [wa.dev Registry](https://wa.dev)
````

## File: .cursor/rules/cursor-rules.mdc
````
---
description: 
globs: 
alwaysApply: false
---
---
description: How to add or edit Cursor rules in our project
globs: 
alwaysApply: false
---
# Cursor Rules Location

How to add new cursor rules to the project

1. Always place rule files in PROJECT_ROOT/.cursor/rules/:
    ```
    .cursor/rules/
    ├── your-rule-name.mdc
    ├── another-rule.mdc
    └── ...
    ```

2. Follow the naming convention:
    - Use kebab-case for filenames
    - Always use .mdc extension
    - Make names descriptive of the rule's purpose

3. Directory structure:
    ```
    PROJECT_ROOT/
    ├── .cursor/
    │   └── rules/
    │       ├── your-rule-name.mdc
    │       └── ...
    └── ...
    ```

4. Never place rule files:
    - In the project root
    - In subdirectories outside .cursor/rules
    - In any other location

5. Cursor rules have the following structure:

```
---
description: Short description of the rule's purpose
globs: optional/path/pattern/**/*
alwaysApply: false
---
# Rule Title

Main content explaining the rule with markdown formatting.

1. Step-by-step instructions
2. Code examples
3. Guidelines

Example:
```typescript
// Good example
function goodExample() {
  // Implementation following guidelines
}

// Bad example
function badExample() {
  // Implementation not following guidelines
}
```
````

## File: .cursor/rules/network-requests.mdc
````
---
description: How to make HTTP requests from WAVS components using wavs-wasi-utils

alwaysApply: true
---
# Network Requests in WAVS Components

Use the [`wavs-wasi-utils`](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/index.html) crate to make HTTP requests from WAVS components. Since WASI runs synchronously but network calls are async, use `block_on` from `wstd` to run async code synchronously.

### 1. Add dependencies to Cargo.toml

```toml
[dependencies]
wavs-wasi-utils = "0.4.0-beta.4"   # HTTP utilities
wstd = "0.5.3"                     # Runtime utilities (includes block_on)
serde = { version = "1.0.219", features = ["derive"] }  # Serialization
serde_json = "1.0.140"             # JSON handling
```

### 2. HTTP request functions

```rust
// Request creators
http_request_get(url)               // GET request
http_request_post_json(url, data)  // POST with JSON body
http_request_post_form(url, data)  // POST with form data

// Response handlers
fetch_json(request)    // Parse JSON response
fetch_string(request)  // Get response as string
fetch_bytes(request)   // Get raw response bytes
```

### 3. Example: GET request with custom headers

```rust
use wstd::runtime::block_on;
use wstd::http::HeaderValue;
use wavs_wasi_utils::http::{fetch_json, http_request_get};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct ApiResponse {
    // response fields
}

async fn make_request() -> Result<ApiResponse, String> {
    let url = "https://api.example.com/endpoint";
    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("User-Agent", HeaderValue::from_static("Mozilla/5.0"));
    let json: ApiResponse = fetch_json(req).await.map_err(|e| e.to_string())?;
    Ok(json)
}

fn process_data() -> Result<ApiResponse, String> {
    block_on(async move { make_request().await })?
}
```

### 4. Example: POST request with JSON data

```rust
use wstd::runtime::block_on;
use wavs_wasi_utils::http::{fetch_json, http_request_post_json};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct PostData {
    key1: String,
    key2: i32,
}

#[derive(Debug, Serialize, Deserialize)]
struct PostResponse {
    // response fields
}

async fn make_post_request() -> Result<PostResponse, String> {
    let url = "https://api.example.com/endpoint";
    let post_data = PostData { key1: "value1".to_string(), key2: 42 };
    let response: PostResponse = fetch_json(http_request_post_json(&url, &post_data)?)
        .await
        .map_err(|e| e.to_string())?;
    Ok(response)
}

fn process_data() -> Result<PostResponse, String> {
    block_on(async move { make_post_request().await })?
}
```

### Guidelines and best practices

- Use `block_on` to run async HTTP calls synchronously in WASI.
- Use `http_request_post_json` for POST requests with JSON; it sets headers automatically.
- Use serde derives to serialize/deserialize request and response data.
- Set appropriate headers for GET requests manually.
- Handle errors by converting them to strings for simplicity.

For more information:
- [wavs-wasi-utils crate](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/index.html)
- [HTTP module docs](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/http/index.html)
- [Variables page](./variables)
````

## File: .cursor/rules/overview.mdc
````
---
description: Overview of the WAVS handbook structure and key sections for building WAVS AVS services

alwaysApply: true
---
# WAVS Handbook Overview

This handbook outlines the structure and contents of the WAVS AVS documentation to guide you in building WAVS services.

1. Follow the [Oracle component tutorial](/tutorial/1-overview) first to learn WAVS basics.

2. Explore **Core Concepts**:
   - [How it works](../how-it-works): Components of a WAVS AVS.
   - [Design](../design): Design considerations.

3. Understand **Services**:
   - [Service](./service): Service structure and manifest definition.
   - [Workflows](./workflows): Execution paths, triggers, components, submissions.
   - [Triggers](./triggers): Types of triggers (EVM, Cosmos, cron, block intervals).
   - [Submission and Aggregator](./submission): Blockchain result submission via aggregator and contracts.

4. Learn about **Components**:
   - [Component overview](./components/component): Lifecycle, triggers, data processing.
   - [Variables](./components/variables): Public and private component variables.
   - [Blockchain interactions](./components/blockchain-interactions): Interacting with blockchains and smart contracts.
   - [Network requests](./components/network-requests): Making HTTP requests to external APIs.

5. Use **Development** resources:
   - [Template](./template): WAVS template structure and customization.
   - [Makefile commands](./commands): Commands to build, deploy, and manage services.

Start with the Service section for foundational knowledge, then explore other sections as needed.

For more information:
- [Oracle component tutorial](/tutorial/1-overview) - Start here to learn the basics of building a WAVS service.
- [How it works](../how-it-works) - Learn about the different parts that make up a WAVS AVS.
- [Design](../design) - Design considerations for WAVS AVS.
- [Service](./service) - WAVS service structure and manifest.
- [Workflows](./workflows) - Defining execution paths.
- [Triggers](./triggers) - Trigger types.
- [Submission and Aggregator](./submission) - Blockchain submission process.
- [Component overview](./components/component) - Component lifecycle and data handling.
- [Variables](./components/variables) - Configuring component variables.
- [Blockchain interactions](./components/blockchain-interactions) - Blockchain and smart contract interactions.
- [Network requests](./components/network-requests) - HTTP requests from components.
- [Template](./template) - WAVS template and customization.
- [Makefile commands](./commands) - Build and deploy commands.
````

## File: .cursor/rules/service.mdc
````
---
description: Defines the WAVS service manifest structure and usage with the service manager contract.

alwaysApply: true
---
# Service Manifest and Manager

A WAVS service is composed of smart contracts, operators, and offchain components defined in a `service.json` manifest. This manifest configures workflows, components, submission, and the service manager contract. It is hosted on IPFS or HTTP(S) and referenced by the service manager contract.

## Creating the Manifest

1. Use `wavs-cli service` or the provided [build_service.sh](https://github.com/Lay3rLabs/wavs-foundry-template/blob/main/script/build_service.sh) script to generate a single-component service manifest.
2. Define service info, workflows, components, submission, and manager details in `service.json`.
3. Upload the manifest to IPFS or a publicly accessible server (e.g., Pinata).

## Example Manifest

```json service.json
{
    "id": "example-service-123",
    "name": "Example WAVS Service",
    "workflows": {
        "default": {
            "trigger": {
                "evm_contract_event": {
                    "chain_name": "ethereum",
                    "address": "0x1234567890123456789012345678901234567890",
                    "event_hash": "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"
                }
            },
            "component": {
                "source": {
                    "Registry": {
                        "registry": {
                            "digest": "882b992af8f78e0aaceaf9609c7ba2ce80a22c521789c94ae1960c43a98295f5",
                            "domain": "localhost:8090",
                            "version": "0.1.0",
                            "package": "example:evmrustoracle"
                        }
                    }
                },
                "permissions": {
                    "allowed_http_hosts": "all",
                    "file_system": true
                },
                "fuel_limit": 1000000,
                "time_limit_seconds": 30,
                "config": {
                    "endpoint": "https://api.example.com",
                    "timeout": "30s"
                },
                "env_keys": [
                    "WAVS_ENV_API_KEY",
                    "WAVS_ENV_SECRET"
                ]
            },
            "submit": {
                "aggregator": {
                    "url": "http://127.0.0.1:8001"
                }
            },
            "aggregators": [
                {
                    "evm": {
                        "chain_name": "ethereum",
                        "address": "0xfedcba9876543210fedcba9876543210fedcba98",
                        "max_gas": 1000000
                    }
                }
            ]
        }
    },
    "status": "active",
    "manager": {
        "evm": {
            "chain_name": "ethereum",
            "address": "0xabcdef1234567890abcdef1234567890abcdef12"
        }
    }
}
```

## Uploading the Manifest

```bash
# Upload manifest to IPFS (local or remote)
SERVICE_FILE=${SERVICE_FILE} make upload-to-ipfs

# Retrieve IPFS gateway URL
export IPFS_GATEWAY=$(sh script/get-ipfs-gateway.sh)

# Fetch uploaded content
curl "${IPFS_GATEWAY}${ipfs_cid}"

# Set service URI on service manager contract
cast send ${WAVS_SERVICE_MANAGER_ADDRESS} 'setServiceURI(string)' "${SERVICE_URI}" -r ${RPC_URL} --private-key ${DEPLOYER_PK}
```

## Service Manager Contract

- Registers operators with assigned weights; only registered operators can sign submissions.
- Maintains the service URI linking to the manifest.
- Validates operator signatures and ensures threshold weights are met before processing data.
- Ensures operators are sorted correctly for submission validation.

For more information on manifest parts, see:

- [Workflows](./workflows)
- [Triggers](./triggers)
- [Components](./components/component)
- [Submission and aggregator](./submission)

For more information:
- [WAVS Foundry Template build_service.sh](https://github.com/Lay3rLabs/wavs-foundry-template/blob/main/script/build_service.sh)
- [Pinata IPFS Service](https://app.pinata.cloud/developers/api-keys)
````

## File: .cursor/rules/submission.mdc
````
---
description: Rules for configuring submission contracts and aggregators in WAVS services

alwaysApply: true
---
# Submission and Aggregator Configuration in WAVS

This rule explains how to configure submission contracts and aggregators to submit workflow results to an EVM chain in WAVS.

## 1. Configure Submission in `service.json`

- Use the `submit` field to define submission logic.
- For aggregator submission, specify:
```json
"submit": {
  "aggregator": {
    "url": "http://127.0.0.1:8001"
  }
},
"aggregators": [
  {
    "evm": {
      "chain_name": "local",
      "address": "0xd6f8ff0036d8b2088107902102f9415330868109",
      "max_gas": 5000000
    }
  }
]
```
- Set `"submit": "none"` if no submission is needed (component runs but results not submitted).

## 2. Submission Contract Requirements

- Must implement `handleSignedEnvelope()` from the `IWavsServiceHandler` interface.
- Use `IWavsServiceManager` to validate data and operator signatures.
- The contract processes validated data matching the component's output format.
- Example simplified contract:
```solidity
import {IWavsServiceManager} from "@wavs/interfaces/IWavsServiceManager.sol";
import {IWavsServiceHandler} from "@wavs/interfaces/IWavsServiceHandler.sol";
import {ITypes} from "interfaces/ITypes.sol";

contract SimpleSubmit is ITypes, IWavsServiceHandler {
    IWavsServiceManager private _serviceManager;

    constructor(IWavsServiceManager serviceManager) {
        _serviceManager = serviceManager;
    }

    function handleSignedEnvelope(Envelope calldata envelope, SignatureData calldata signatureData) external {
        _serviceManager.validate(envelope, signatureData);
        DataWithId memory dataWithId = abi.decode(envelope.payload, (DataWithId));
        // Custom logic to process validated data
    }
}
```

## 3. Aggregator Role and Flow

- Collects signed responses from multiple operators.
- Validates each operator's signature.
- Aggregates signatures when threshold is met (exact match aggregation).
- Submits aggregated data to the submission contract.
- Uses ECDSA signatures currently; BLS support planned.

### Aggregator Submission Flow:

1. Operator runs component → returns `WasmResponse` with `payload` and optional `ordering`.
2. Operator creates signed Envelope.
3. Packet with envelope, signature, route info sent to aggregator `/packet` endpoint.
4. Aggregator validates signature and queues packets by event and service ID.
5. When threshold reached:
   - Combine signatures into one `SignatureData`.
   - Validate combined signatures on-chain.
6. On success, aggregator calls `handleSignedEnvelope()` on submit contract with aggregated data.
7. Submit contract validates data and signatures via service manager.

## 4. Workflow Chaining

- Workflows can be chained by triggering one workflow on the submission event of another.
- See the [Workflows page](./workflows) for details.

## Best Practices

- Ensure `DataWithId` struct matches component output format.
- Validate all signatures on-chain via service manager.
- Use aggregator to ensure consensus before submission.
- Set appropriate gas limits in aggregator config.
- Use local aggregator endpoint during development.

For more information:
- [WAVS Solidity Interfaces @wavs](https://www.npmjs.com/package/@wavs/solidity?activeTab=code)
- [Template Submission Contract](https://github.com/Lay3rLabs/wavs-foundry-template/blob/main/src/contracts/WavsSubmit.sol)
- [WAVS Design Considerations](/design)
- [Workflows Documentation](./workflows)
````

## File: .cursor/rules/template.mdc
````
---
description: Overview and customization guide for the WAVS Foundry template structure and configuration

alwaysApply: true
---
# WAVS Foundry Template Overview

This guide explains the structure and configuration of the WAVS Foundry template to help customize and build your own WAVS service.

1. **Template Structure**

The main files and directories in the WAVS template:

```bash
wavs-foundry-template/
├── README.md               # Tutorial commands
├── makefile                # Build and deploy commands, variables, configs
├── components/             # WASI components
│   └── evm-price-oracle/
│       ├── src/
│       │   ├── lib.rs         # Main component logic
│       │   ├── trigger.rs     # Trigger handling
│       │   └── bindings.rs    # Auto-generated bindings (`make build`)
│       └── Cargo.toml      # Component dependencies
├── compiled/               # Compiled WASM files (`make build`)
├── src/
│   ├── contracts/          # Trigger and submission Solidity contracts
│   └── interfaces/         # Solidity interfaces
├── script/                 # Deployment and interaction scripts
├── wavs.toml               # WAVS service configuration
├── docs/                   # Documentation
└── .env                    # Private environment variables
```

- Use `make wasi-build` to generate bindings and compile components.
- Copy `.env` from `.env.example` to set private environment variables.

2. **TOML Configuration Files**

- `wavs.toml`: Configures the WAVS service (chains, environments, etc.).
- Root `Cargo.toml`: Workspace configuration, dependencies, build settings, metadata.
- `components/*/Cargo.toml`: Component-specific Rust configuration; can inherit from root via `workspace = true`.

Example component `Cargo.toml`:

```toml
[package]
name = "evm-price-oracle"
edition.workspace = true
version.workspace = true
authors.workspace = true
rust-version.workspace = true
repository.workspace = true

[dependencies]
wit-bindgen-rt = { workspace = true }
wavs-wasi-utils = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
alloy-sol-macro = { workspace = true }
wstd = { workspace = true }
alloy-sol-types = { workspace = true }
anyhow = { workspace = true }

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "s"
debug = false
strip = true
lto = true

[package.metadata.component]
package = "component:evm-price-oracle"
target = "wavs:worker/layer-trigger-world@0.4.0-beta.4"
```

3. **wavs.toml Configuration**

The `wavs.toml` file configures:

- Default general settings (shared by all processes)
- WAVS server-specific settings
- CLI-specific settings
- Aggregator-specific settings

4. **Environment Variable Overrides**

Override config values using environment variables:

- WAVS server settings: `WAVS_<UPPERCASE_KEY>`
- CLI settings: `WAVS_CLI_<UPPERCASE_KEY>`
- Aggregator settings: `WAVS_AGGREGATOR_<UPPERCASE_KEY>`

---

For more information:
- [WAVS Foundry Template GitHub](https://github.com/Lay3rLabs/wavs-foundry-template)
- [Oracle Component Tutorial](https://docs.wavs.xyz/tutorial/1-overview)
- [WAVS Design Considerations](https://docs.wavs.xyz/design)
- [wavs.toml Configuration](https://github.com/Lay3rLabs/wavs-foundry-template/blob/main/wavs.toml)
````

## File: .cursor/rules/triggers.mdc
````
---
description: Setup and manage WAVS service triggers for onchain events and scheduled executions

alwaysApply: true
---
# WAVS Service Triggers

Triggers prompt WAVS services to run by listening for onchain events or schedules. Operators verify triggers and execute components off-chain.

## Trigger Lifecycle

1. Deploy a service with `service.json` manifest containing service info, workflow, components, triggers, and submission logic.
2. Operators maintain lookup maps for triggers by chain, contract, and event identifiers.
3. On trigger detection, operators verify and create a `TriggerAction` with config and event data.
4. `TriggerAction` structure:
```rust
pub struct TriggerAction {
    pub config: TriggerConfig,  // service_id, workflow_id, trigger type
    pub data: TriggerData,      // trigger-specific data
}

pub struct TriggerConfig {
    pub service_id: ServiceID,
    pub workflow_id: WorkflowID,
    pub trigger: Trigger,
}

pub enum TriggerData {
    CosmosContractEvent {
        contract_address: layer_climb_address::Address,
        chain_name: ChainName,
        event: cosmwasm_std::Event,
        block_height: u64,
    },
    EvmContractEvent {
        contract_address: alloy_primitives::Address,
        chain_name: ChainName,
        log: LogData,
        block_height: u64,
    },
    BlockInterval {
        chain_name: ChainName,
        block_height: u64,
    },
    Cron {
        trigger_time: Timestamp,
    }
}
```
5. `TriggerAction` is converted to WASI format and passed to components, decoded using `decode_event_log_data!` macro from [`wavs-wasi-utils`](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/macro.decode_event_log_data.html).

## Trigger Configuration

Set triggers in the `trigger` field of `service.json`. Each workflow requires one trigger.

### EVM Event Trigger

Listens for specific contract events on EVM chains. Passes raw log data to the component.

Example:
```json
"trigger": {
  "evm_contract_event": {
    "address": "0x00000000219ab540356cbb839cbe05303d7705fa",
    "chain_name": "ethereum",
    "event_hash": "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"
  }
}
```

Configure chain in `wavs.toml`:
```toml
[default.chains.evm.ethereum]
chain_id = "1"
ws_endpoint = "wss://eth.drpc.org"
http_endpoint = "https://eth.drpc.org"
```

Set EVM credential in `.env`:
```env
WAVS_CLI_EVM_CREDENTIAL="0x5ze146f435835b1762ed602088740d201b68fd94bf808f97fd04588f1a63c9ab"
```

### Cosmos Event Trigger

Monitors Cosmos smart contract events by type and address. Passes emitted contract data to component.

Example:
```json
"trigger": {
  "cosmos_contract_event": {
    "address": {
      "Cosmos": {
        "bech32_addr": "neutron1qlaq54uh9f52d3p66q77s6kh9k9ee3vasy8gkdkk3yvgezcs6zts0mkcv4",
        "prefix_len": 7
      }
    },
    "chain_name": "neutron",
    "event_type": "send_nft"
  }
}
```

Configure chain in `wavs.toml`:
```toml
[default.chains.cosmos.neutron]
chain_id = "pion-1"
bech32_prefix = "neutron"
rpc_endpoint = "https://rpc-falcron.pion-1.ntrn.tech"
grpc_endpoint = "http://grpc-falcron.pion-1.ntrn.tech:80"
gas_price = 0.0053
gas_denom = "untrn"
```

Set Cosmos mnemonic in `.env`:
```env
WAVS_CLI_COSMOS_MNEMONIC="large slab plate twenty laundry illegal vacuum phone drum example topic reason"
```

### Cron Trigger

Executes component on a schedule defined by a cron expression with optional start/end times. Passes trigger timestamp.

Example:
```json
"trigger": {
  "cron": {
    "schedule": "0 */5 * * * *",
    "start_time": 1704067200000000000,
    "end_time": 1735689599000000000
  }
}
```

Cron format (seconds to day of week):

```
* * * * * *
│ │ │ │ │ └─ Day of week (0-6, Sunday=0)
│ │ │ │ └── Month (1-12)
│ │ │ └─── Day of month (1-31)
│ │ └──── Hour (0-23)
│ └───── Minute (0-59)
└────── Second (0-59)
```

Common examples:

- `0 */5 * * * *` - Every 5 minutes at 0 seconds
- `0 0 */6 * * *` - Every 6 hours
- `0 0 0 * * *` - Daily at midnight

**Note:** Cron triggers may have latency due to network and clock drift. Use block triggers for precise timing.

### Block Trigger

Runs component at regular block intervals on EVM or Cosmos chains. Passes block height and chain name.

Example:
```json
"trigger": {
  "block_interval": {
    "chain_name": "ethereum-mainnet",
    "n_blocks": 10,
    "start_block": null,
    "end_block": null
  }
}
```

## Best Practices

- Always configure chain info in `wavs.toml` and credentials in `.env`.
- Use `decode_event_log_data!` macro in components to decode trigger data.
- Use cron triggers for non-time-critical tasks; use block triggers for precise scheduling.
- Maintain accurate lookup maps for trigger verification.

For more information:
- [WAVS WASI Utils decode_event_log_data!](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/macro.decode_event_log_data.html)
- [Crontab Guru - Cron Expression Tool](https://crontab.guru/)
- [WAVS Service JSON and Workflow Handbook](https://handbook.layerzero.network/handbook/service)
````

## File: .cursor/rules/variables.mdc
````
---
description: Managing public and private configuration variables in WAVS components

alwaysApply: true
---
# Variables in WAVS Components

WAVS components use two types of variables for configuration: public variables for non-sensitive data and environment keys for sensitive data.

## Public Variables

- Stored as strings in the `config` field of the service manifest.
- Accessible in components via `host::config_var()`.

### Steps to use public variables:

1. Add variables to `config` in the manifest:

```json
"component": {
    "config": {
        "api_endpoint": "https://api.example.com",
        "max_retries": "3"
    }
}
```

2. Access in Rust component:

```rust
let value = host::config_var("api_endpoint");
```

## Environment Keys (Private Variables)

- Used for sensitive data like API keys.
- Must be prefixed with `WAVS_ENV_`.
- Set by operators in their environment; not visible publicly.
- WAVS validates presence before service runs.

### Steps to use environment keys:

1. Create or copy `.env` file:

```bash
cp .env.example .env
```

2. Set environment variable in `.env` or shell config:

```bash
WAVS_ENV_MY_API_KEY=your_secret_key_here
```

3. Access in Rust component:

```rust
let api_key = std::env::var("WAVS_ENV_MY_API_KEY")?;
```

4. Declare in manifest under `env_keys`:

```json
"component": {
    "env_keys": [
        "WAVS_ENV_API_KEY"
    ]
}
```

## Local Execution

Use `--config` flag with comma-separated `KEY=VALUE` pairs to set config variables locally:

```bash
wavs-cli exec --component <COMPONENT> --input <INPUT> --config api_endpoint=https://api.example.com
```

For more information:
- [WAVS Variables Documentation](https://docs.wavs.example.com/variables)
- [WAVS CLI Reference](https://docs.wavs.example.com/cli)
````

## File: .cursor/rules/workflows.mdc
````
---
description: Define and manage WAVS service workflows specifying triggers, components, and submission logic.

alwaysApply: true
---
# WAVS Service Workflows

A WAVS service consists of one or more workflows defining execution paths. Each workflow includes:

- **Trigger**: Event that starts the workflow
- **Component**: WASM component processing the event
- **Submit**: Destination for results

## Workflow Structure

Workflows are defined in the service manifest JSON under the `workflows` key, each identified by a unique UUID.

Example workflow with a cron trigger and aggregator submission:

```json service.json
"workflows": {
  "0196c34d-003d-7412-a3f3-70f8ec664e12": {
    "trigger": {
      "cron": {
        "schedule": "0 * * * * *",
        "start_time": null,
        "end_time": null
      }
    },
    "component": {
      "source": {
        "Digest": "65747b4b1a7fa98cab6abd9a81a6102068de77b1040b94de904112272b226f51"
      },
      "permissions": {
        "allowed_http_hosts": "all",
        "file_system": true
      },
      "fuel_limit": null,
      "time_limit_seconds": 1800,
      "config": {
        "nft": "0xb5d4D4a87Cb07f33b5FAd6736D8F1EE7D255d9E9",
        "reward_token": "0x34045B4b0cdfADf87B840bCF544161168c8ab85A"
      },
      "env_keys": [
        "WAVS_ENV_API_KEY"
      ]
    },
    "submit": {
      "aggregator": {
        "url": "http://127.0.0.1:8001"
      }
    },
    "aggregators": [
      {
        "evm": {
          "chain_name": "local",
          "address": "0xd6f8ff0036d8b2088107902102f9415330868109",
          "max_gas": 5000000
        }
      }
    ]
  }
}
```

## Multi-workflow Services

- Multiple workflows can coexist in one service manifest.
- Each workflow has independent trigger, component, and submission logic.
- All workflows share the same service manager and operator set.

Example:

```json
{
  "workflows": {
    "workflow-uuid-1": {
      "trigger": { ... },
      "component": { ... },
      "submit": { ... }
    },
    "workflow-uuid-2": {
      "trigger": { ... },
      "component": { ... },
      "submit": { ... }
    }
  }
}
```

## Workflow Isolation

- Each workflow runs in a separate WebAssembly environment.
- Memory and state are isolated per execution.
- Components cannot access each other's memory or state directly.

## Sharing State Between Workflows

- WAVS services focus on data processing, not storage.
- Data sharing is done via external systems (e.g., onchain smart contracts).
- Workflow A submits data externally; Workflow B reads from the same source.

Example flow:

```
A: Trigger -> component -> onchain submission storage
B: Trigger -> component (reads from A's storage) -> onchain submission storage
```

## Chaining Workflows

- Chain workflows by setting the second workflow’s trigger to the onchain submission event of the first.
- This can be done within a service or across different services.

Example:

```json
{
  "workflows": {
    "workflow-uuid-1": {
      "trigger": { ... },
      "component": { ... },
      "submit": { ... }
    },
    "workflow-uuid-2": {
      "trigger": { /* onchain submission event of workflow-uuid-1 */ },
      "component": { ... },
      "submit": { ... }
    }
  }
}
```

## Multichain Services

- WAVS supports contract event or block height triggers on Cosmos and EVM chains.
- Enables cross-chain services monitoring events on one chain and submitting results to Ethereum.
- More chain triggers coming soon.

For detailed trigger options, see the [Trigger page](./triggers).

For more information:
- [WAVS Design Considerations](../design)
- [Trigger Documentation](./triggers)
- [Component Documentation](./components/component)
- [Submission Documentation](./submission)
````

## File: .github/workflows/contracts.yml
````yaml
name: Solidity
on:
  pull_request:

jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1
        with:
          version: stable

      - uses: actions/setup-node@v4
        name: Install Node.js
        with:
          node-version: 21

      - name: Install deps
        run: make setup

      - name: Run forge build
        run: forge build -vvv

      - name: Run forge tests
        run: forge test -vvv
````

## File: .github/workflows/rust.yml
````yaml
name: Rust

on:
  pull_request:

jobs:
  tests-stable:
    name: Tests (Stable)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout sources
        uses: actions/checkout@v4

      - name: Install toolchain
        uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@v2
        with:
          cache-on-failure: true

      - name: cargo test
        run: cargo test --workspace --all-features

  docs:
    name: docs
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rust-docs

      - uses: Swatinem/rust-cache@v2

      - name: doc
        run: cargo doc --workspace --all-features --no-deps --document-private-items
        env:
          RUSTDOCFLAGS: "-D warnings"

  fmt:
    name: fmt
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt
      - name: fmt --check
        run: cargo fmt --all --check

#   clippy:
#     name: clippy
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#       - uses: dtolnay/rust-toolchain@stable
#         with:
#           components: clippy
#       - uses: Swatinem/rust-cache@v2
#       - name: clippy
#         run: cargo clippy --workspace --tests --all-features
#         env:
#           RUSTFLAGS: "-D warnings"
````

## File: .github/workflows/wavs-image-version-verifier.yml
````yaml
name: Check WAVS Image Version

on:
  pull_request:
  workflow_dispatch:

# Ensures that only a single workflow per PR will run at a time. Cancels in-progress jobs if new commit is pushed.
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  script:
    runs-on: ubuntu-latest
    env:
      DEBUGGING: true

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install bash
      run: sudo apt-get install bash

    - name: Make script executable
      run: chmod +x .github/single-wavs-image-verifier.bash

    - name: Run script
      run: bash .github/single-wavs-image-verifier.bash
````

## File: .github/single-wavs-image-verifier.bash
````bash
#!/bin/bash

# Define the pattern
# Updated to handle semantic versions with suffixes (like -beta, -alpha, etc.)
GREP_PATTERN='ghcr\.io/lay3rlabs/wavs:(v?[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?|[a-zA-Z0-9-_./]+)'

export DEBUGGING=${DEBUGGING:-false}

main() {
    # declare an empty array
    matches_set=()

    # iterate over all files not ignored by .gitignore
    while read file; do
        if [[ $file == lib/* ]]; then
            continue
        fi
        if [[ $file == *$(basename $0) ]]; then
            continue
        fi

        found_docker=$(grep -P -o "$GREP_PATTERN" $file)
        if [[ ! -z $found_docker ]]; then
            # ensure found_docker is split on new lines to each their own array components (some files may have multiple references)
            IFS=$'
' read -rd '' -a found_docker_array <<< "$found_docker"
            for i in "${found_docker_array[@]}"; do
                if [[ $DEBUGGING == "true" ]]; then
                    echo "Found in $file: $i"
                fi

                # check if the array already contains the item, if it does, skip adding it
                if [[ " ${matches_set[@]} " =~ " ${i} " ]]; then
                    continue
                fi

                matches_set+=("$i")
            done
        fi
    done < <(git ls-files --cached --others --exclude-standard)

    if [[ ${#matches_set[@]} -eq 1 ]]; then
        echo "Only found a single image: ${matches_set[0]}, success"
        exit 0
    else
        echo "Found multiple docker images in the codebase:"
        for i in "${matches_set[@]}"; do
            echo "$i"
        done
        echo "Please ensure only a single wavs docker image is being referenced in the files"
        exit 1
    fi
}

# test_data
main
````

## File: components/evm-price-oracle/src/bindings.rs
````rust
// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
pub type TriggerAction = wavs::worker::layer_types::TriggerAction;
pub type WasmResponse = wavs::worker::layer_types::WasmResponse;
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_run_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
    #[cfg(target_arch = "wasm32")]
    _rt::run_ctors_once();
    let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
    let len2 = l1;
    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
    let l3 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l4 = *arg0.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    let len5 = l4;
    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
    let l6 = i32::from(*arg0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>());
    use wavs::worker::layer_types::TriggerSource as V41;
    let v41 = match l6 {
        0 => {
            let e41 = {
                let l7 = *arg0.add(8 + 4 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l8 = *arg0.add(8 + 5 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len9 = l8;
                let l10 = *arg0.add(8 + 6 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l11 = *arg0.add(8 + 7 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len12 = l11;
                let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                let l13 = *arg0.add(8 + 8 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l14 = *arg0.add(8 + 9 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len15 = l14;
                wavs::worker::layer_types::TriggerSourceEvmContractEvent {
                    address: wavs::worker::layer_types::EvmAddress {
                        raw_bytes: _rt::Vec::from_raw_parts(l7.cast(), len9, len9),
                    },
                    chain_name: _rt::string_lift(bytes12),
                    event_hash: _rt::Vec::from_raw_parts(l13.cast(), len15, len15),
                }
            };
            V41::EvmContractEvent(e41)
        }
        1 => {
            let e41 = {
                let l16 = *arg0.add(8 + 4 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l17 = *arg0.add(8 + 5 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len18 = l17;
                let bytes18 = _rt::Vec::from_raw_parts(l16.cast(), len18, len18);
                let l19 = *arg0.add(8 + 6 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l20 = *arg0.add(8 + 7 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l21 = *arg0.add(8 + 8 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len22 = l21;
                let bytes22 = _rt::Vec::from_raw_parts(l20.cast(), len22, len22);
                let l23 = *arg0.add(8 + 9 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l24 = *arg0.add(8 + 10 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len25 = l24;
                let bytes25 = _rt::Vec::from_raw_parts(l23.cast(), len25, len25);
                wavs::worker::layer_types::TriggerSourceCosmosContractEvent {
                    address: wavs::worker::layer_types::CosmosAddress {
                        bech32_addr: _rt::string_lift(bytes18),
                        prefix_len: l19 as u32,
                    },
                    chain_name: _rt::string_lift(bytes22),
                    event_type: _rt::string_lift(bytes25),
                }
            };
            V41::CosmosContractEvent(e41)
        }
        2 => {
            let e41 = {
                let l26 = *arg0.add(8 + 4 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l27 = *arg0.add(8 + 5 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len28 = l27;
                let bytes28 = _rt::Vec::from_raw_parts(l26.cast(), len28, len28);
                let l29 = *arg0.add(8 + 6 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l30 =
                    i32::from(*arg0.add(16 + 6 * ::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l32 =
                    i32::from(*arg0.add(32 + 6 * ::core::mem::size_of::<*const u8>()).cast::<u8>());
                wavs::worker::layer_types::BlockIntervalSource {
                    chain_name: _rt::string_lift(bytes28),
                    n_blocks: l29 as u32,
                    start_block: match l30 {
                        0 => None,
                        1 => {
                            let e = {
                                let l31 = *arg0
                                    .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i64>();
                                l31 as u64
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    },
                    end_block: match l32 {
                        0 => None,
                        1 => {
                            let e = {
                                let l33 = *arg0
                                    .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i64>();
                                l33 as u64
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    },
                }
            };
            V41::BlockInterval(e41)
        }
        3 => {
            let e41 = {
                let l34 = *arg0.add(8 + 4 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l35 = *arg0.add(8 + 5 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len36 = l35;
                let bytes36 = _rt::Vec::from_raw_parts(l34.cast(), len36, len36);
                let l37 =
                    i32::from(*arg0.add(8 + 6 * ::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l39 =
                    i32::from(*arg0.add(24 + 6 * ::core::mem::size_of::<*const u8>()).cast::<u8>());
                wavs::worker::layer_types::TriggerSourceCron {
                    schedule: _rt::string_lift(bytes36),
                    start_time: match l37 {
                        0 => None,
                        1 => {
                            let e = {
                                let l38 = *arg0
                                    .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i64>();
                                wavs::worker::layer_types::Timestamp { nanos: l38 as u64 }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    },
                    end_time: match l39 {
                        0 => None,
                        1 => {
                            let e = {
                                let l40 = *arg0
                                    .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i64>();
                                wavs::worker::layer_types::Timestamp { nanos: l40 as u64 }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    },
                }
            };
            V41::Cron(e41)
        }
        n => {
            debug_assert_eq!(n, 4, "invalid enum discriminant");
            V41::Manual
        }
    };
    let l42 = i32::from(*arg0.add(48 + 6 * ::core::mem::size_of::<*const u8>()).cast::<u8>());
    use wavs::worker::layer_types::TriggerData as V87;
    let v87 = match l42 {
        0 => {
            let e87 = {
                let l43 = *arg0.add(56 + 6 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l44 = *arg0.add(56 + 7 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len45 = l44;
                let l46 = *arg0.add(56 + 8 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l47 = *arg0.add(56 + 9 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len48 = l47;
                let bytes48 = _rt::Vec::from_raw_parts(l46.cast(), len48, len48);
                let l49 =
                    *arg0.add(56 + 10 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l50 = *arg0.add(56 + 11 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base54 = l49;
                let len54 = l50;
                let mut result54 = _rt::Vec::with_capacity(len54);
                for i in 0..len54 {
                    let base = base54.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                    let e54 = {
                        let l51 = *base.add(0).cast::<*mut u8>();
                        let l52 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len53 = l52;
                        _rt::Vec::from_raw_parts(l51.cast(), len53, len53)
                    };
                    result54.push(e54);
                }
                _rt::cabi_dealloc(
                    base54,
                    len54 * (2 * ::core::mem::size_of::<*const u8>()),
                    ::core::mem::size_of::<*const u8>(),
                );
                let l55 =
                    *arg0.add(56 + 12 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l56 = *arg0.add(56 + 13 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len57 = l56;
                let l58 = *arg0.add(56 + 14 * ::core::mem::size_of::<*const u8>()).cast::<i64>();
                wavs::worker::layer_types::TriggerDataEvmContractEvent {
                    contract_address: wavs::worker::layer_types::EvmAddress {
                        raw_bytes: _rt::Vec::from_raw_parts(l43.cast(), len45, len45),
                    },
                    chain_name: _rt::string_lift(bytes48),
                    log: wavs::worker::layer_types::EvmEventLogData {
                        topics: result54,
                        data: _rt::Vec::from_raw_parts(l55.cast(), len57, len57),
                    },
                    block_height: l58 as u64,
                }
            };
            V87::EvmContractEvent(e87)
        }
        1 => {
            let e87 = {
                let l59 = *arg0.add(56 + 6 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l60 = *arg0.add(56 + 7 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len61 = l60;
                let bytes61 = _rt::Vec::from_raw_parts(l59.cast(), len61, len61);
                let l62 = *arg0.add(56 + 8 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l63 = *arg0.add(56 + 9 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l64 = *arg0.add(56 + 10 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len65 = l64;
                let bytes65 = _rt::Vec::from_raw_parts(l63.cast(), len65, len65);
                let l66 =
                    *arg0.add(56 + 11 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l67 = *arg0.add(56 + 12 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len68 = l67;
                let bytes68 = _rt::Vec::from_raw_parts(l66.cast(), len68, len68);
                let l69 =
                    *arg0.add(56 + 13 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l70 = *arg0.add(56 + 14 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base77 = l69;
                let len77 = l70;
                let mut result77 = _rt::Vec::with_capacity(len77);
                for i in 0..len77 {
                    let base = base77.add(i * (4 * ::core::mem::size_of::<*const u8>()));
                    let e77 = {
                        let l71 = *base.add(0).cast::<*mut u8>();
                        let l72 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len73 = l72;
                        let bytes73 = _rt::Vec::from_raw_parts(l71.cast(), len73, len73);
                        let l74 =
                            *base.add(2 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l75 =
                            *base.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len76 = l75;
                        let bytes76 = _rt::Vec::from_raw_parts(l74.cast(), len76, len76);
                        (_rt::string_lift(bytes73), _rt::string_lift(bytes76))
                    };
                    result77.push(e77);
                }
                _rt::cabi_dealloc(
                    base77,
                    len77 * (4 * ::core::mem::size_of::<*const u8>()),
                    ::core::mem::size_of::<*const u8>(),
                );
                let l78 = *arg0.add(64 + 14 * ::core::mem::size_of::<*const u8>()).cast::<i64>();
                wavs::worker::layer_types::TriggerDataCosmosContractEvent {
                    contract_address: wavs::worker::layer_types::CosmosAddress {
                        bech32_addr: _rt::string_lift(bytes61),
                        prefix_len: l62 as u32,
                    },
                    chain_name: _rt::string_lift(bytes65),
                    event: wavs::worker::layer_types::CosmosEvent {
                        ty: _rt::string_lift(bytes68),
                        attributes: result77,
                    },
                    block_height: l78 as u64,
                }
            };
            V87::CosmosContractEvent(e87)
        }
        2 => {
            let e87 = {
                let l79 = *arg0.add(56 + 6 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l80 = *arg0.add(56 + 7 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len81 = l80;
                let bytes81 = _rt::Vec::from_raw_parts(l79.cast(), len81, len81);
                let l82 = *arg0.add(56 + 8 * ::core::mem::size_of::<*const u8>()).cast::<i64>();
                wavs::worker::layer_types::BlockIntervalData {
                    chain_name: _rt::string_lift(bytes81),
                    block_height: l82 as u64,
                }
            };
            V87::BlockInterval(e87)
        }
        3 => {
            let e87 = {
                let l83 = *arg0.add(56 + 6 * ::core::mem::size_of::<*const u8>()).cast::<i64>();
                wavs::worker::layer_types::TriggerDataCron {
                    trigger_time: wavs::worker::layer_types::Timestamp { nanos: l83 as u64 },
                }
            };
            V87::Cron(e87)
        }
        n => {
            debug_assert_eq!(n, 4, "invalid enum discriminant");
            let e87 = {
                let l84 = *arg0.add(56 + 6 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l85 = *arg0.add(56 + 7 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len86 = l85;
                _rt::Vec::from_raw_parts(l84.cast(), len86, len86)
            };
            V87::Raw(e87)
        }
    };
    let result88 = T::run(wavs::worker::layer_types::TriggerAction {
        config: wavs::worker::layer_types::TriggerConfig {
            service_id: _rt::string_lift(bytes2),
            workflow_id: _rt::string_lift(bytes5),
            trigger_source: v41,
        },
        data: v87,
    });
    _rt::cabi_dealloc(arg0, 72 + 14 * ::core::mem::size_of::<*const u8>(), 8);
    let ptr89 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result88 {
        Ok(e) => {
            *ptr89.add(0).cast::<u8>() = (0i32) as u8;
            match e {
                Some(e) => {
                    *ptr89.add(8).cast::<u8>() = (1i32) as u8;
                    let wavs::worker::layer_types::WasmResponse {
                        payload: payload90,
                        ordering: ordering90,
                    } = e;
                    let vec91 = (payload90).into_boxed_slice();
                    let ptr91 = vec91.as_ptr().cast::<u8>();
                    let len91 = vec91.len();
                    ::core::mem::forget(vec91);
                    *ptr89.add(16 + 1 * ::core::mem::size_of::<*const u8>()).cast::<usize>() =
                        len91;
                    *ptr89.add(16).cast::<*mut u8>() = ptr91.cast_mut();
                    match ordering90 {
                        Some(e) => {
                            *ptr89.add(16 + 2 * ::core::mem::size_of::<*const u8>()).cast::<u8>() =
                                (1i32) as u8;
                            *ptr89
                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i64>() = _rt::as_i64(e);
                        }
                        None => {
                            *ptr89.add(16 + 2 * ::core::mem::size_of::<*const u8>()).cast::<u8>() =
                                (0i32) as u8;
                        }
                    };
                }
                None => {
                    *ptr89.add(8).cast::<u8>() = (0i32) as u8;
                }
            };
        }
        Err(e) => {
            *ptr89.add(0).cast::<u8>() = (1i32) as u8;
            let vec92 = (e.into_bytes()).into_boxed_slice();
            let ptr92 = vec92.as_ptr().cast::<u8>();
            let len92 = vec92.len();
            ::core::mem::forget(vec92);
            *ptr89.add(8 + 1 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len92;
            *ptr89.add(8).cast::<*mut u8>() = ptr92.cast_mut();
        }
    };
    ptr89
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_run<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {
            let l1 = i32::from(*arg0.add(8).cast::<u8>());
            match l1 {
                0 => {}
                _ => {
                    let l2 = *arg0.add(16).cast::<*mut u8>();
                    let l3 =
                        *arg0.add(16 + 1 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base4 = l2;
                    let len4 = l3;
                    _rt::cabi_dealloc(base4, len4 * 1, 1);
                }
            }
        }
        _ => {
            let l5 = *arg0.add(8).cast::<*mut u8>();
            let l6 = *arg0.add(8 + 1 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l5, l6, 1);
        }
    }
}
pub trait Guest {
    fn run(trigger_action: TriggerAction) -> Result<Option<WasmResponse>, _rt::String>;
}
#[doc(hidden)]
macro_rules! __export_world_layer_trigger_world_cabi {
    ($ty:ident with_types_in $($path_to_types:tt)*) => {
        const _ : () = { #[unsafe (export_name = "run")] unsafe extern "C" fn
        export_run(arg0 : * mut u8,) -> * mut u8 { unsafe { $($path_to_types)*::
        _export_run_cabi::<$ty > (arg0) } } #[unsafe (export_name = "cabi_post_run")]
        unsafe extern "C" fn _post_return_run(arg0 : * mut u8,) { unsafe {
        $($path_to_types)*:: __post_return_run::<$ty > (arg0) } } };
    };
}
#[doc(hidden)]
pub(crate) use __export_world_layer_trigger_world_cabi;
#[repr(align(8))]
struct _RetArea([::core::mem::MaybeUninit<u8>; 32 + 2 * ::core::mem::size_of::<*const u8>()]);
static mut _RET_AREA: _RetArea =
    _RetArea([::core::mem::MaybeUninit::uninit(); 32 + 2 * ::core::mem::size_of::<*const u8>()]);
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wasi {
    pub mod cli {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod environment {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_environment() -> _rt::Vec<(_rt::String, _rt::String)> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/environment@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-environment"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base10 = l2;
                    let len10 = l3;
                    let mut result10 = _rt::Vec::with_capacity(len10);
                    for i in 0..len10 {
                        let base = base10
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e10 = {
                            let l4 = *base.add(0).cast::<*mut u8>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            let l7 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l8 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len9 = l8;
                            let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                            (_rt::string_lift(bytes6), _rt::string_lift(bytes9))
                        };
                        result10.push(e10);
                    }
                    _rt::cabi_dealloc(
                        base10,
                        len10 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result11 = result10;
                    result11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_arguments() -> _rt::Vec<_rt::String> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/environment@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-arguments"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base7 = l2;
                    let len7 = l3;
                    let mut result7 = _rt::Vec::with_capacity(len7);
                    for i in 0..len7 {
                        let base = base7
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e7 = {
                            let l4 = *base.add(0).cast::<*mut u8>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            _rt::string_lift(bytes6)
                        };
                        result7.push(e7);
                    }
                    _rt::cabi_dealloc(
                        base7,
                        len7 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result8 = result7;
                    result8
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn initial_cwd() -> Option<_rt::String> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 3 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 3
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/environment@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "initial-cwd"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result6 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l4 = *ptr0
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len5 = l4;
                                let bytes5 = _rt::Vec::from_raw_parts(
                                    l3.cast(),
                                    len5,
                                    len5,
                                );
                                _rt::string_lift(bytes5)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result6
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod exit {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            #[allow(unused_unsafe, clippy::all)]
            pub fn exit(status: Result<(), ()>) -> () {
                unsafe {
                    let result0 = match status {
                        Ok(_) => 0i32,
                        Err(_) => 1i32,
                    };
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/exit@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "exit"]
                        fn wit_import1(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i32) {
                        unreachable!()
                    }
                    unsafe { wit_import1(result0) };
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod stdin {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            pub type InputStream = super::super::super::wasi::io::streams::InputStream;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_stdin() -> InputStream {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/stdin@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-stdin"]
                        fn wit_import0() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    unsafe {
                        super::super::super::wasi::io::streams::InputStream::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod stdout {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_stdout() -> OutputStream {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/stdout@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-stdout"]
                        fn wit_import0() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    unsafe {
                        super::super::super::wasi::io::streams::OutputStream::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod stderr {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_stderr() -> OutputStream {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/stderr@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-stderr"]
                        fn wit_import0() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    unsafe {
                        super::super::super::wasi::io::streams::OutputStream::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_input {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct TerminalInput {
                handle: _rt::Resource<TerminalInput>,
            }
            impl TerminalInput {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for TerminalInput {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:cli/terminal-input@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]terminal-input"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_output {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct TerminalOutput {
                handle: _rt::Resource<TerminalOutput>,
            }
            impl TerminalOutput {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for TerminalOutput {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:cli/terminal-output@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]terminal-output"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_stdin {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type TerminalInput = super::super::super::wasi::cli::terminal_input::TerminalInput;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_terminal_stdin() -> Option<TerminalInput> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/terminal-stdin@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-terminal-stdin"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result4 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                unsafe {
                                    super::super::super::wasi::cli::terminal_input::TerminalInput::from_handle(
                                        l3 as u32,
                                    )
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result4
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_stdout {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type TerminalOutput = super::super::super::wasi::cli::terminal_output::TerminalOutput;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_terminal_stdout() -> Option<TerminalOutput> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/terminal-stdout@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-terminal-stdout"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result4 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                unsafe {
                                    super::super::super::wasi::cli::terminal_output::TerminalOutput::from_handle(
                                        l3 as u32,
                                    )
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result4
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod terminal_stderr {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type TerminalOutput = super::super::super::wasi::cli::terminal_output::TerminalOutput;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_terminal_stderr() -> Option<TerminalOutput> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:cli/terminal-stderr@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-terminal-stderr"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result4 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                unsafe {
                                    super::super::super::wasi::cli::terminal_output::TerminalOutput::from_handle(
                                        l3 as u32,
                                    )
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result4
                }
            }
        }
    }
    pub mod clocks {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod monotonic_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            pub type Instant = u64;
            pub type Duration = u64;
            #[allow(unused_unsafe, clippy::all)]
            pub fn now() -> Instant {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "now"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn resolution() -> Duration {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "resolution"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn subscribe_instant(when: Instant) -> Pollable {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "subscribe-instant"]
                        fn wit_import0(_: i64) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0(_: i64) -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0(_rt::as_i64(when)) };
                    unsafe {
                        super::super::super::wasi::io::poll::Pollable::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn subscribe_duration(when: Duration) -> Pollable {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "subscribe-duration"]
                        fn wit_import0(_: i64) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0(_: i64) -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0(_rt::as_i64(when)) };
                    unsafe {
                        super::super::super::wasi::io::poll::Pollable::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod wall_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Datetime {
                pub seconds: u64,
                pub nanoseconds: u32,
            }
            impl ::core::fmt::Debug for Datetime {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Datetime")
                        .field("seconds", &self.seconds)
                        .field("nanoseconds", &self.nanoseconds)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn now() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/wall-clock@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "now"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn resolution() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/wall-clock@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "resolution"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i32>();
                    let result4 = Datetime {
                        seconds: l2 as u64,
                        nanoseconds: l3 as u32,
                    };
                    result4
                }
            }
        }
    }
    pub mod filesystem {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type InputStream = super::super::super::wasi::io::streams::InputStream;
            pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
            pub type Error = super::super::super::wasi::io::streams::Error;
            pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
            pub type Filesize = u64;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum DescriptorType {
                Unknown,
                BlockDevice,
                CharacterDevice,
                Directory,
                Fifo,
                SymbolicLink,
                RegularFile,
                Socket,
            }
            impl ::core::fmt::Debug for DescriptorType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        DescriptorType::Unknown => {
                            f.debug_tuple("DescriptorType::Unknown").finish()
                        }
                        DescriptorType::BlockDevice => {
                            f.debug_tuple("DescriptorType::BlockDevice").finish()
                        }
                        DescriptorType::CharacterDevice => {
                            f.debug_tuple("DescriptorType::CharacterDevice").finish()
                        }
                        DescriptorType::Directory => {
                            f.debug_tuple("DescriptorType::Directory").finish()
                        }
                        DescriptorType::Fifo => {
                            f.debug_tuple("DescriptorType::Fifo").finish()
                        }
                        DescriptorType::SymbolicLink => {
                            f.debug_tuple("DescriptorType::SymbolicLink").finish()
                        }
                        DescriptorType::RegularFile => {
                            f.debug_tuple("DescriptorType::RegularFile").finish()
                        }
                        DescriptorType::Socket => {
                            f.debug_tuple("DescriptorType::Socket").finish()
                        }
                    }
                }
            }
            impl DescriptorType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> DescriptorType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => DescriptorType::Unknown,
                        1 => DescriptorType::BlockDevice,
                        2 => DescriptorType::CharacterDevice,
                        3 => DescriptorType::Directory,
                        4 => DescriptorType::Fifo,
                        5 => DescriptorType::SymbolicLink,
                        6 => DescriptorType::RegularFile,
                        7 => DescriptorType::Socket,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            wit_bindgen_rt::bitflags::bitflags! {
                #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)] pub
                struct DescriptorFlags : u8 { const READ = 1 << 0; const WRITE = 1 << 1;
                const FILE_INTEGRITY_SYNC = 1 << 2; const DATA_INTEGRITY_SYNC = 1 << 3;
                const REQUESTED_WRITE_SYNC = 1 << 4; const MUTATE_DIRECTORY = 1 << 5; }
            }
            wit_bindgen_rt::bitflags::bitflags! {
                #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)] pub
                struct PathFlags : u8 { const SYMLINK_FOLLOW = 1 << 0; }
            }
            wit_bindgen_rt::bitflags::bitflags! {
                #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)] pub
                struct OpenFlags : u8 { const CREATE = 1 << 0; const DIRECTORY = 1 << 1;
                const EXCLUSIVE = 1 << 2; const TRUNCATE = 1 << 3; }
            }
            pub type LinkCount = u64;
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct DescriptorStat {
                pub type_: DescriptorType,
                pub link_count: LinkCount,
                pub size: Filesize,
                pub data_access_timestamp: Option<Datetime>,
                pub data_modification_timestamp: Option<Datetime>,
                pub status_change_timestamp: Option<Datetime>,
            }
            impl ::core::fmt::Debug for DescriptorStat {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("DescriptorStat")
                        .field("type", &self.type_)
                        .field("link-count", &self.link_count)
                        .field("size", &self.size)
                        .field("data-access-timestamp", &self.data_access_timestamp)
                        .field(
                            "data-modification-timestamp",
                            &self.data_modification_timestamp,
                        )
                        .field("status-change-timestamp", &self.status_change_timestamp)
                        .finish()
                }
            }
            #[derive(Clone, Copy)]
            pub enum NewTimestamp {
                NoChange,
                Now,
                Timestamp(Datetime),
            }
            impl ::core::fmt::Debug for NewTimestamp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        NewTimestamp::NoChange => {
                            f.debug_tuple("NewTimestamp::NoChange").finish()
                        }
                        NewTimestamp::Now => f.debug_tuple("NewTimestamp::Now").finish(),
                        NewTimestamp::Timestamp(e) => {
                            f.debug_tuple("NewTimestamp::Timestamp").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct DirectoryEntry {
                pub type_: DescriptorType,
                pub name: _rt::String,
            }
            impl ::core::fmt::Debug for DirectoryEntry {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("DirectoryEntry")
                        .field("type", &self.type_)
                        .field("name", &self.name)
                        .finish()
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum ErrorCode {
                Access,
                WouldBlock,
                Already,
                BadDescriptor,
                Busy,
                Deadlock,
                Quota,
                Exist,
                FileTooLarge,
                IllegalByteSequence,
                InProgress,
                Interrupted,
                Invalid,
                Io,
                IsDirectory,
                Loop,
                TooManyLinks,
                MessageSize,
                NameTooLong,
                NoDevice,
                NoEntry,
                NoLock,
                InsufficientMemory,
                InsufficientSpace,
                NotDirectory,
                NotEmpty,
                NotRecoverable,
                Unsupported,
                NoTty,
                NoSuchDevice,
                Overflow,
                NotPermitted,
                Pipe,
                ReadOnly,
                InvalidSeek,
                TextFileBusy,
                CrossDevice,
            }
            impl ErrorCode {
                pub fn name(&self) -> &'static str {
                    match self {
                        ErrorCode::Access => "access",
                        ErrorCode::WouldBlock => "would-block",
                        ErrorCode::Already => "already",
                        ErrorCode::BadDescriptor => "bad-descriptor",
                        ErrorCode::Busy => "busy",
                        ErrorCode::Deadlock => "deadlock",
                        ErrorCode::Quota => "quota",
                        ErrorCode::Exist => "exist",
                        ErrorCode::FileTooLarge => "file-too-large",
                        ErrorCode::IllegalByteSequence => "illegal-byte-sequence",
                        ErrorCode::InProgress => "in-progress",
                        ErrorCode::Interrupted => "interrupted",
                        ErrorCode::Invalid => "invalid",
                        ErrorCode::Io => "io",
                        ErrorCode::IsDirectory => "is-directory",
                        ErrorCode::Loop => "loop",
                        ErrorCode::TooManyLinks => "too-many-links",
                        ErrorCode::MessageSize => "message-size",
                        ErrorCode::NameTooLong => "name-too-long",
                        ErrorCode::NoDevice => "no-device",
                        ErrorCode::NoEntry => "no-entry",
                        ErrorCode::NoLock => "no-lock",
                        ErrorCode::InsufficientMemory => "insufficient-memory",
                        ErrorCode::InsufficientSpace => "insufficient-space",
                        ErrorCode::NotDirectory => "not-directory",
                        ErrorCode::NotEmpty => "not-empty",
                        ErrorCode::NotRecoverable => "not-recoverable",
                        ErrorCode::Unsupported => "unsupported",
                        ErrorCode::NoTty => "no-tty",
                        ErrorCode::NoSuchDevice => "no-such-device",
                        ErrorCode::Overflow => "overflow",
                        ErrorCode::NotPermitted => "not-permitted",
                        ErrorCode::Pipe => "pipe",
                        ErrorCode::ReadOnly => "read-only",
                        ErrorCode::InvalidSeek => "invalid-seek",
                        ErrorCode::TextFileBusy => "text-file-busy",
                        ErrorCode::CrossDevice => "cross-device",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        ErrorCode::Access => "",
                        ErrorCode::WouldBlock => "",
                        ErrorCode::Already => "",
                        ErrorCode::BadDescriptor => "",
                        ErrorCode::Busy => "",
                        ErrorCode::Deadlock => "",
                        ErrorCode::Quota => "",
                        ErrorCode::Exist => "",
                        ErrorCode::FileTooLarge => "",
                        ErrorCode::IllegalByteSequence => "",
                        ErrorCode::InProgress => "",
                        ErrorCode::Interrupted => "",
                        ErrorCode::Invalid => "",
                        ErrorCode::Io => "",
                        ErrorCode::IsDirectory => "",
                        ErrorCode::Loop => "",
                        ErrorCode::TooManyLinks => "",
                        ErrorCode::MessageSize => "",
                        ErrorCode::NameTooLong => "",
                        ErrorCode::NoDevice => "",
                        ErrorCode::NoEntry => "",
                        ErrorCode::NoLock => "",
                        ErrorCode::InsufficientMemory => "",
                        ErrorCode::InsufficientSpace => "",
                        ErrorCode::NotDirectory => "",
                        ErrorCode::NotEmpty => "",
                        ErrorCode::NotRecoverable => "",
                        ErrorCode::Unsupported => "",
                        ErrorCode::NoTty => "",
                        ErrorCode::NoSuchDevice => "",
                        ErrorCode::Overflow => "",
                        ErrorCode::NotPermitted => "",
                        ErrorCode::Pipe => "",
                        ErrorCode::ReadOnly => "",
                        ErrorCode::InvalidSeek => "",
                        ErrorCode::TextFileBusy => "",
                        ErrorCode::CrossDevice => "",
                    }
                }
            }
            impl ::core::fmt::Debug for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ErrorCode")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{} (error {})", self.name(), * self as i32)
                }
            }
            impl std::error::Error for ErrorCode {}
            impl ErrorCode {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ErrorCode {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => ErrorCode::Access,
                        1 => ErrorCode::WouldBlock,
                        2 => ErrorCode::Already,
                        3 => ErrorCode::BadDescriptor,
                        4 => ErrorCode::Busy,
                        5 => ErrorCode::Deadlock,
                        6 => ErrorCode::Quota,
                        7 => ErrorCode::Exist,
                        8 => ErrorCode::FileTooLarge,
                        9 => ErrorCode::IllegalByteSequence,
                        10 => ErrorCode::InProgress,
                        11 => ErrorCode::Interrupted,
                        12 => ErrorCode::Invalid,
                        13 => ErrorCode::Io,
                        14 => ErrorCode::IsDirectory,
                        15 => ErrorCode::Loop,
                        16 => ErrorCode::TooManyLinks,
                        17 => ErrorCode::MessageSize,
                        18 => ErrorCode::NameTooLong,
                        19 => ErrorCode::NoDevice,
                        20 => ErrorCode::NoEntry,
                        21 => ErrorCode::NoLock,
                        22 => ErrorCode::InsufficientMemory,
                        23 => ErrorCode::InsufficientSpace,
                        24 => ErrorCode::NotDirectory,
                        25 => ErrorCode::NotEmpty,
                        26 => ErrorCode::NotRecoverable,
                        27 => ErrorCode::Unsupported,
                        28 => ErrorCode::NoTty,
                        29 => ErrorCode::NoSuchDevice,
                        30 => ErrorCode::Overflow,
                        31 => ErrorCode::NotPermitted,
                        32 => ErrorCode::Pipe,
                        33 => ErrorCode::ReadOnly,
                        34 => ErrorCode::InvalidSeek,
                        35 => ErrorCode::TextFileBusy,
                        36 => ErrorCode::CrossDevice,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum Advice {
                Normal,
                Sequential,
                Random,
                WillNeed,
                DontNeed,
                NoReuse,
            }
            impl ::core::fmt::Debug for Advice {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Advice::Normal => f.debug_tuple("Advice::Normal").finish(),
                        Advice::Sequential => {
                            f.debug_tuple("Advice::Sequential").finish()
                        }
                        Advice::Random => f.debug_tuple("Advice::Random").finish(),
                        Advice::WillNeed => f.debug_tuple("Advice::WillNeed").finish(),
                        Advice::DontNeed => f.debug_tuple("Advice::DontNeed").finish(),
                        Advice::NoReuse => f.debug_tuple("Advice::NoReuse").finish(),
                    }
                }
            }
            impl Advice {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> Advice {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => Advice::Normal,
                        1 => Advice::Sequential,
                        2 => Advice::Random,
                        3 => Advice::WillNeed,
                        4 => Advice::DontNeed,
                        5 => Advice::NoReuse,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct MetadataHashValue {
                pub lower: u64,
                pub upper: u64,
            }
            impl ::core::fmt::Debug for MetadataHashValue {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("MetadataHashValue")
                        .field("lower", &self.lower)
                        .field("upper", &self.upper)
                        .finish()
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Descriptor {
                handle: _rt::Resource<Descriptor>,
            }
            impl Descriptor {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Descriptor {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]descriptor"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct DirectoryEntryStream {
                handle: _rt::Resource<DirectoryEntryStream>,
            }
            impl DirectoryEntryStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for DirectoryEntryStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]directory-entry-stream"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn read_via_stream(
                    &self,
                    offset: Filesize,
                ) -> Result<InputStream, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.read-via-stream"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i64(offset),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    unsafe {
                                        super::super::super::wasi::io::streams::InputStream::from_handle(
                                            l3 as u32,
                                        )
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn write_via_stream(
                    &self,
                    offset: Filesize,
                ) -> Result<OutputStream, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.write-via-stream"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i64(offset),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    unsafe {
                                        super::super::super::wasi::io::streams::OutputStream::from_handle(
                                            l3 as u32,
                                        )
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn append_via_stream(&self) -> Result<OutputStream, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.append-via-stream"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    unsafe {
                                        super::super::super::wasi::io::streams::OutputStream::from_handle(
                                            l3 as u32,
                                        )
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn advise(
                    &self,
                    offset: Filesize,
                    length: Filesize,
                    advice: Advice,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.advise"]
                            fn wit_import1(_: i32, _: i64, _: i64, _: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(
                            _: i32,
                            _: i64,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i64(offset),
                                _rt::as_i64(length),
                                advice.clone() as i32,
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn sync_data(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.sync-data"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn get_flags(&self) -> Result<DescriptorFlags, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.get-flags"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    DescriptorFlags::empty()
                                        | DescriptorFlags::from_bits_retain(((l3 as u8) << 0) as _)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn get_type(&self) -> Result<DescriptorType, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.get-type"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    DescriptorType::_lift(l3 as u8)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_size(&self, size: Filesize) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.set-size"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1((self).handle() as i32, _rt::as_i64(size), ptr0)
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_times(
                    &self,
                    data_access_timestamp: NewTimestamp,
                    data_modification_timestamp: NewTimestamp,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let (result1_0, result1_1, result1_2) = match data_access_timestamp {
                            NewTimestamp::NoChange => (0i32, 0i64, 0i32),
                            NewTimestamp::Now => (1i32, 0i64, 0i32),
                            NewTimestamp::Timestamp(e) => {
                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: seconds0,
                                    nanoseconds: nanoseconds0,
                                } = e;
                                (2i32, _rt::as_i64(seconds0), _rt::as_i32(nanoseconds0))
                            }
                        };
                        let (result3_0, result3_1, result3_2) = match data_modification_timestamp {
                            NewTimestamp::NoChange => (0i32, 0i64, 0i32),
                            NewTimestamp::Now => (1i32, 0i64, 0i32),
                            NewTimestamp::Timestamp(e) => {
                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: seconds2,
                                    nanoseconds: nanoseconds2,
                                } = e;
                                (2i32, _rt::as_i64(seconds2), _rt::as_i32(nanoseconds2))
                            }
                        };
                        let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.set-times"]
                            fn wit_import5(
                                _: i32,
                                _: i32,
                                _: i64,
                                _: i32,
                                _: i32,
                                _: i64,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import5(
                            _: i32,
                            _: i32,
                            _: i64,
                            _: i32,
                            _: i32,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import5(
                                (self).handle() as i32,
                                result1_0,
                                result1_1,
                                result1_2,
                                result3_0,
                                result3_1,
                                result3_2,
                                ptr4,
                            )
                        };
                        let l6 = i32::from(*ptr4.add(0).cast::<u8>());
                        let result8 = match l6 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l7 = i32::from(*ptr4.add(1).cast::<u8>());
                                    ErrorCode::_lift(l7 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn read(
                    &self,
                    length: Filesize,
                    offset: Filesize,
                ) -> Result<(_rt::Vec<u8>, bool), ErrorCode> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.read"]
                            fn wit_import1(_: i32, _: i64, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(
                            _: i32,
                            _: i64,
                            _: i64,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i64(length),
                                _rt::as_i64(offset),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result8 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    let l6 = i32::from(
                                        *ptr0
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    (
                                        _rt::Vec::from_raw_parts(l3.cast(), len5, len5),
                                        _rt::bool_lift(l6 as u8),
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l7 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    ErrorCode::_lift(l7 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn write(
                    &self,
                    buffer: &[u8],
                    offset: Filesize,
                ) -> Result<Filesize, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let vec0 = buffer;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.write"]
                            fn wit_import2(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: i64,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                _rt::as_i64(offset),
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result6 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = *ptr1.add(8).cast::<i64>();
                                    l4 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr1.add(8).cast::<u8>());
                                    ErrorCode::_lift(l5 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn read_directory(&self) -> Result<DirectoryEntryStream, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.read-directory"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    unsafe { DirectoryEntryStream::from_handle(l3 as u32) }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn sync(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.sync"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    ErrorCode::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn create_directory_at(&self, path: &str) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.create-directory-at"]
                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result5 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn stat(&self) -> Result<DescriptorStat, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 104]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 104],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.stat"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result16 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let l4 = *ptr0.add(16).cast::<i64>();
                                    let l5 = *ptr0.add(24).cast::<i64>();
                                    let l6 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l9 = i32::from(*ptr0.add(56).cast::<u8>());
                                    let l12 = i32::from(*ptr0.add(80).cast::<u8>());
                                    DescriptorStat {
                                        type_: DescriptorType::_lift(l3 as u8),
                                        link_count: l4 as u64,
                                        size: l5 as u64,
                                        data_access_timestamp: match l6 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l7 = *ptr0.add(40).cast::<i64>();
                                                    let l8 = *ptr0.add(48).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l7 as u64,
                                                        nanoseconds: l8 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        data_modification_timestamp: match l9 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l10 = *ptr0.add(64).cast::<i64>();
                                                    let l11 = *ptr0.add(72).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l10 as u64,
                                                        nanoseconds: l11 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        status_change_timestamp: match l12 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l13 = *ptr0.add(88).cast::<i64>();
                                                    let l14 = *ptr0.add(96).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l13 as u64,
                                                        nanoseconds: l14 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l15 = i32::from(*ptr0.add(8).cast::<u8>());
                                    ErrorCode::_lift(l15 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result16
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn stat_at(
                    &self,
                    path_flags: PathFlags,
                    path: &str,
                ) -> Result<DescriptorStat, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 104]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 104],
                        );
                        let flags0 = path_flags;
                        let vec1 = path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.stat-at"]
                            fn wit_import3(
                                _: i32,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import3(
                                (self).handle() as i32,
                                (flags0.bits() >> 0) as i32,
                                ptr1.cast_mut(),
                                len1,
                                ptr2,
                            )
                        };
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result18 = match l4 {
                            0 => {
                                let e = {
                                    let l5 = i32::from(*ptr2.add(8).cast::<u8>());
                                    let l6 = *ptr2.add(16).cast::<i64>();
                                    let l7 = *ptr2.add(24).cast::<i64>();
                                    let l8 = i32::from(*ptr2.add(32).cast::<u8>());
                                    let l11 = i32::from(*ptr2.add(56).cast::<u8>());
                                    let l14 = i32::from(*ptr2.add(80).cast::<u8>());
                                    DescriptorStat {
                                        type_: DescriptorType::_lift(l5 as u8),
                                        link_count: l6 as u64,
                                        size: l7 as u64,
                                        data_access_timestamp: match l8 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l9 = *ptr2.add(40).cast::<i64>();
                                                    let l10 = *ptr2.add(48).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l9 as u64,
                                                        nanoseconds: l10 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        data_modification_timestamp: match l11 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l12 = *ptr2.add(64).cast::<i64>();
                                                    let l13 = *ptr2.add(72).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l12 as u64,
                                                        nanoseconds: l13 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        status_change_timestamp: match l14 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l15 = *ptr2.add(88).cast::<i64>();
                                                    let l16 = *ptr2.add(96).cast::<i32>();
                                                    super::super::super::wasi::clocks::wall_clock::Datetime {
                                                        seconds: l15 as u64,
                                                        nanoseconds: l16 as u32,
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l17 = i32::from(*ptr2.add(8).cast::<u8>());
                                    ErrorCode::_lift(l17 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result18
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_times_at(
                    &self,
                    path_flags: PathFlags,
                    path: &str,
                    data_access_timestamp: NewTimestamp,
                    data_modification_timestamp: NewTimestamp,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let flags0 = path_flags;
                        let vec1 = path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let (result3_0, result3_1, result3_2) = match data_access_timestamp {
                            NewTimestamp::NoChange => (0i32, 0i64, 0i32),
                            NewTimestamp::Now => (1i32, 0i64, 0i32),
                            NewTimestamp::Timestamp(e) => {
                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: seconds2,
                                    nanoseconds: nanoseconds2,
                                } = e;
                                (2i32, _rt::as_i64(seconds2), _rt::as_i32(nanoseconds2))
                            }
                        };
                        let (result5_0, result5_1, result5_2) = match data_modification_timestamp {
                            NewTimestamp::NoChange => (0i32, 0i64, 0i32),
                            NewTimestamp::Now => (1i32, 0i64, 0i32),
                            NewTimestamp::Timestamp(e) => {
                                let super::super::super::wasi::clocks::wall_clock::Datetime {
                                    seconds: seconds4,
                                    nanoseconds: nanoseconds4,
                                } = e;
                                (2i32, _rt::as_i64(seconds4), _rt::as_i32(nanoseconds4))
                            }
                        };
                        let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.set-times-at"]
                            fn wit_import7(
                                _: i32,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: i32,
                                _: i64,
                                _: i32,
                                _: i32,
                                _: i64,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import7(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: i64,
                            _: i32,
                            _: i32,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import7(
                                (self).handle() as i32,
                                (flags0.bits() >> 0) as i32,
                                ptr1.cast_mut(),
                                len1,
                                result3_0,
                                result3_1,
                                result3_2,
                                result5_0,
                                result5_1,
                                result5_2,
                                ptr6,
                            )
                        };
                        let l8 = i32::from(*ptr6.add(0).cast::<u8>());
                        let result10 = match l8 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l9 = i32::from(*ptr6.add(1).cast::<u8>());
                                    ErrorCode::_lift(l9 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn link_at(
                    &self,
                    old_path_flags: PathFlags,
                    old_path: &str,
                    new_descriptor: &Descriptor,
                    new_path: &str,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let flags0 = old_path_flags;
                        let vec1 = old_path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let vec2 = new_path;
                        let ptr2 = vec2.as_ptr().cast::<u8>();
                        let len2 = vec2.len();
                        let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.link-at"]
                            fn wit_import4(
                                _: i32,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import4(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import4(
                                (self).handle() as i32,
                                (flags0.bits() >> 0) as i32,
                                ptr1.cast_mut(),
                                len1,
                                (new_descriptor).handle() as i32,
                                ptr2.cast_mut(),
                                len2,
                                ptr3,
                            )
                        };
                        let l5 = i32::from(*ptr3.add(0).cast::<u8>());
                        let result7 = match l5 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l6 = i32::from(*ptr3.add(1).cast::<u8>());
                                    ErrorCode::_lift(l6 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn open_at(
                    &self,
                    path_flags: PathFlags,
                    path: &str,
                    open_flags: OpenFlags,
                    flags: DescriptorFlags,
                ) -> Result<Descriptor, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let flags0 = path_flags;
                        let vec1 = path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let flags2 = open_flags;
                        let flags3 = flags;
                        let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.open-at"]
                            fn wit_import5(
                                _: i32,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: i32,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import5(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import5(
                                (self).handle() as i32,
                                (flags0.bits() >> 0) as i32,
                                ptr1.cast_mut(),
                                len1,
                                (flags2.bits() >> 0) as i32,
                                (flags3.bits() >> 0) as i32,
                                ptr4,
                            )
                        };
                        let l6 = i32::from(*ptr4.add(0).cast::<u8>());
                        let result9 = match l6 {
                            0 => {
                                let e = {
                                    let l7 = *ptr4.add(4).cast::<i32>();
                                    unsafe { Descriptor::from_handle(l7 as u32) }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l8 = i32::from(*ptr4.add(4).cast::<u8>());
                                    ErrorCode::_lift(l8 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn readlink_at(&self, path: &str) -> Result<_rt::String, ErrorCode> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.readlink-at"]
                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result8 = match l3 {
                            0 => {
                                let e = {
                                    let l4 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *ptr1
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len6 = l5;
                                    let bytes6 = _rt::Vec::from_raw_parts(
                                        l4.cast(),
                                        len6,
                                        len6,
                                    );
                                    _rt::string_lift(bytes6)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l7 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    ErrorCode::_lift(l7 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn remove_directory_at(&self, path: &str) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.remove-directory-at"]
                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result5 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn rename_at(
                    &self,
                    old_path: &str,
                    new_descriptor: &Descriptor,
                    new_path: &str,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = old_path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let vec1 = new_path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.rename-at"]
                            fn wit_import3(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import3(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                (new_descriptor).handle() as i32,
                                ptr1.cast_mut(),
                                len1,
                                ptr2,
                            )
                        };
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result6 = match l4 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr2.add(1).cast::<u8>());
                                    ErrorCode::_lift(l5 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn symlink_at(
                    &self,
                    old_path: &str,
                    new_path: &str,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = old_path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let vec1 = new_path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.symlink-at"]
                            fn wit_import3(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import3(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1.cast_mut(),
                                len1,
                                ptr2,
                            )
                        };
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result6 = match l4 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr2.add(1).cast::<u8>());
                                    ErrorCode::_lift(l5 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn unlink_file_at(&self, path: &str) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = path;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.unlink-file-at"]
                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result5 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(1).cast::<u8>());
                                    ErrorCode::_lift(l4 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn is_same_object(&self, other: &Descriptor) -> bool {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.is-same-object"]
                            fn wit_import0(_: i32, _: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32, _: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import0((self).handle() as i32, (other).handle() as i32)
                        };
                        _rt::bool_lift(ret as u8)
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn metadata_hash(&self) -> Result<MetadataHashValue, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 24],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.metadata-hash"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    let l4 = *ptr0.add(16).cast::<i64>();
                                    MetadataHashValue {
                                        lower: l3 as u64,
                                        upper: l4 as u64,
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr0.add(8).cast::<u8>());
                                    ErrorCode::_lift(l5 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl Descriptor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn metadata_hash_at(
                    &self,
                    path_flags: PathFlags,
                    path: &str,
                ) -> Result<MetadataHashValue, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 24],
                        );
                        let flags0 = path_flags;
                        let vec1 = path;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]descriptor.metadata-hash-at"]
                            fn wit_import3(
                                _: i32,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import3(
                                (self).handle() as i32,
                                (flags0.bits() >> 0) as i32,
                                ptr1.cast_mut(),
                                len1,
                                ptr2,
                            )
                        };
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result8 = match l4 {
                            0 => {
                                let e = {
                                    let l5 = *ptr2.add(8).cast::<i64>();
                                    let l6 = *ptr2.add(16).cast::<i64>();
                                    MetadataHashValue {
                                        lower: l5 as u64,
                                        upper: l6 as u64,
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l7 = i32::from(*ptr2.add(8).cast::<u8>());
                                    ErrorCode::_lift(l7 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
            }
            impl DirectoryEntryStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn read_directory_entry(
                    &self,
                ) -> Result<Option<DirectoryEntry>, ErrorCode> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 5 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 5
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]directory-entry-stream.read-directory-entry"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result9 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    match l3 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l4 = i32::from(
                                                    *ptr0
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                let l5 = *ptr0
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l6 = *ptr0
                                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len7 = l6;
                                                let bytes7 = _rt::Vec::from_raw_parts(
                                                    l5.cast(),
                                                    len7,
                                                    len7,
                                                );
                                                DirectoryEntry {
                                                    type_: DescriptorType::_lift(l4 as u8),
                                                    name: _rt::string_lift(bytes7),
                                                }
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l8 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    ErrorCode::_lift(l8 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn filesystem_error_code(err: &Error) -> Option<ErrorCode> {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "filesystem-error-code"]
                        fn wit_import1(_: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1((err).handle() as i32, ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result4 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                ErrorCode::_lift(l3 as u8)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result4
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod preopens {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Descriptor = super::super::super::wasi::filesystem::types::Descriptor;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_directories() -> _rt::Vec<(Descriptor, _rt::String)> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:filesystem/preopens@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-directories"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base8 = l2;
                    let len8 = l3;
                    let mut result8 = _rt::Vec::with_capacity(len8);
                    for i in 0..len8 {
                        let base = base8
                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                        let e8 = {
                            let l4 = *base.add(0).cast::<i32>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l6 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len7 = l6;
                            let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                            (
                                unsafe {
                                    super::super::super::wasi::filesystem::types::Descriptor::from_handle(
                                        l4 as u32,
                                    )
                                },
                                _rt::string_lift(bytes7),
                            )
                        };
                        result8.push(e8);
                    }
                    _rt::cabi_dealloc(
                        base8,
                        len8 * (3 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result9 = result8;
                    result9
                }
            }
        }
    }
    pub mod http {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Duration = super::super::super::wasi::clocks::monotonic_clock::Duration;
            pub type InputStream = super::super::super::wasi::io::streams::InputStream;
            pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
            pub type IoError = super::super::super::wasi::io::error::Error;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            #[derive(Clone)]
            pub enum Method {
                Get,
                Head,
                Post,
                Put,
                Delete,
                Connect,
                Options,
                Trace,
                Patch,
                Other(_rt::String),
            }
            impl ::core::fmt::Debug for Method {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Method::Get => f.debug_tuple("Method::Get").finish(),
                        Method::Head => f.debug_tuple("Method::Head").finish(),
                        Method::Post => f.debug_tuple("Method::Post").finish(),
                        Method::Put => f.debug_tuple("Method::Put").finish(),
                        Method::Delete => f.debug_tuple("Method::Delete").finish(),
                        Method::Connect => f.debug_tuple("Method::Connect").finish(),
                        Method::Options => f.debug_tuple("Method::Options").finish(),
                        Method::Trace => f.debug_tuple("Method::Trace").finish(),
                        Method::Patch => f.debug_tuple("Method::Patch").finish(),
                        Method::Other(e) => {
                            f.debug_tuple("Method::Other").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub enum Scheme {
                Http,
                Https,
                Other(_rt::String),
            }
            impl ::core::fmt::Debug for Scheme {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Scheme::Http => f.debug_tuple("Scheme::Http").finish(),
                        Scheme::Https => f.debug_tuple("Scheme::Https").finish(),
                        Scheme::Other(e) => {
                            f.debug_tuple("Scheme::Other").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct DnsErrorPayload {
                pub rcode: Option<_rt::String>,
                pub info_code: Option<u16>,
            }
            impl ::core::fmt::Debug for DnsErrorPayload {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("DnsErrorPayload")
                        .field("rcode", &self.rcode)
                        .field("info-code", &self.info_code)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct TlsAlertReceivedPayload {
                pub alert_id: Option<u8>,
                pub alert_message: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for TlsAlertReceivedPayload {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TlsAlertReceivedPayload")
                        .field("alert-id", &self.alert_id)
                        .field("alert-message", &self.alert_message)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct FieldSizePayload {
                pub field_name: Option<_rt::String>,
                pub field_size: Option<u32>,
            }
            impl ::core::fmt::Debug for FieldSizePayload {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("FieldSizePayload")
                        .field("field-name", &self.field_name)
                        .field("field-size", &self.field_size)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum ErrorCode {
                DnsTimeout,
                DnsError(DnsErrorPayload),
                DestinationNotFound,
                DestinationUnavailable,
                DestinationIpProhibited,
                DestinationIpUnroutable,
                ConnectionRefused,
                ConnectionTerminated,
                ConnectionTimeout,
                ConnectionReadTimeout,
                ConnectionWriteTimeout,
                ConnectionLimitReached,
                TlsProtocolError,
                TlsCertificateError,
                TlsAlertReceived(TlsAlertReceivedPayload),
                HttpRequestDenied,
                HttpRequestLengthRequired,
                HttpRequestBodySize(Option<u64>),
                HttpRequestMethodInvalid,
                HttpRequestUriInvalid,
                HttpRequestUriTooLong,
                HttpRequestHeaderSectionSize(Option<u32>),
                HttpRequestHeaderSize(Option<FieldSizePayload>),
                HttpRequestTrailerSectionSize(Option<u32>),
                HttpRequestTrailerSize(FieldSizePayload),
                HttpResponseIncomplete,
                HttpResponseHeaderSectionSize(Option<u32>),
                HttpResponseHeaderSize(FieldSizePayload),
                HttpResponseBodySize(Option<u64>),
                HttpResponseTrailerSectionSize(Option<u32>),
                HttpResponseTrailerSize(FieldSizePayload),
                HttpResponseTransferCoding(Option<_rt::String>),
                HttpResponseContentCoding(Option<_rt::String>),
                HttpResponseTimeout,
                HttpUpgradeFailed,
                HttpProtocolError,
                LoopDetected,
                ConfigurationError,
                InternalError(Option<_rt::String>),
            }
            impl ::core::fmt::Debug for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ErrorCode::DnsTimeout => {
                            f.debug_tuple("ErrorCode::DnsTimeout").finish()
                        }
                        ErrorCode::DnsError(e) => {
                            f.debug_tuple("ErrorCode::DnsError").field(e).finish()
                        }
                        ErrorCode::DestinationNotFound => {
                            f.debug_tuple("ErrorCode::DestinationNotFound").finish()
                        }
                        ErrorCode::DestinationUnavailable => {
                            f.debug_tuple("ErrorCode::DestinationUnavailable").finish()
                        }
                        ErrorCode::DestinationIpProhibited => {
                            f.debug_tuple("ErrorCode::DestinationIpProhibited").finish()
                        }
                        ErrorCode::DestinationIpUnroutable => {
                            f.debug_tuple("ErrorCode::DestinationIpUnroutable").finish()
                        }
                        ErrorCode::ConnectionRefused => {
                            f.debug_tuple("ErrorCode::ConnectionRefused").finish()
                        }
                        ErrorCode::ConnectionTerminated => {
                            f.debug_tuple("ErrorCode::ConnectionTerminated").finish()
                        }
                        ErrorCode::ConnectionTimeout => {
                            f.debug_tuple("ErrorCode::ConnectionTimeout").finish()
                        }
                        ErrorCode::ConnectionReadTimeout => {
                            f.debug_tuple("ErrorCode::ConnectionReadTimeout").finish()
                        }
                        ErrorCode::ConnectionWriteTimeout => {
                            f.debug_tuple("ErrorCode::ConnectionWriteTimeout").finish()
                        }
                        ErrorCode::ConnectionLimitReached => {
                            f.debug_tuple("ErrorCode::ConnectionLimitReached").finish()
                        }
                        ErrorCode::TlsProtocolError => {
                            f.debug_tuple("ErrorCode::TlsProtocolError").finish()
                        }
                        ErrorCode::TlsCertificateError => {
                            f.debug_tuple("ErrorCode::TlsCertificateError").finish()
                        }
                        ErrorCode::TlsAlertReceived(e) => {
                            f.debug_tuple("ErrorCode::TlsAlertReceived")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpRequestDenied => {
                            f.debug_tuple("ErrorCode::HttpRequestDenied").finish()
                        }
                        ErrorCode::HttpRequestLengthRequired => {
                            f.debug_tuple("ErrorCode::HttpRequestLengthRequired")
                                .finish()
                        }
                        ErrorCode::HttpRequestBodySize(e) => {
                            f.debug_tuple("ErrorCode::HttpRequestBodySize")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpRequestMethodInvalid => {
                            f.debug_tuple("ErrorCode::HttpRequestMethodInvalid").finish()
                        }
                        ErrorCode::HttpRequestUriInvalid => {
                            f.debug_tuple("ErrorCode::HttpRequestUriInvalid").finish()
                        }
                        ErrorCode::HttpRequestUriTooLong => {
                            f.debug_tuple("ErrorCode::HttpRequestUriTooLong").finish()
                        }
                        ErrorCode::HttpRequestHeaderSectionSize(e) => {
                            f.debug_tuple("ErrorCode::HttpRequestHeaderSectionSize")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpRequestHeaderSize(e) => {
                            f.debug_tuple("ErrorCode::HttpRequestHeaderSize")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpRequestTrailerSectionSize(e) => {
                            f.debug_tuple("ErrorCode::HttpRequestTrailerSectionSize")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpRequestTrailerSize(e) => {
                            f.debug_tuple("ErrorCode::HttpRequestTrailerSize")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpResponseIncomplete => {
                            f.debug_tuple("ErrorCode::HttpResponseIncomplete").finish()
                        }
                        ErrorCode::HttpResponseHeaderSectionSize(e) => {
                            f.debug_tuple("ErrorCode::HttpResponseHeaderSectionSize")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpResponseHeaderSize(e) => {
                            f.debug_tuple("ErrorCode::HttpResponseHeaderSize")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpResponseBodySize(e) => {
                            f.debug_tuple("ErrorCode::HttpResponseBodySize")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpResponseTrailerSectionSize(e) => {
                            f.debug_tuple("ErrorCode::HttpResponseTrailerSectionSize")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpResponseTrailerSize(e) => {
                            f.debug_tuple("ErrorCode::HttpResponseTrailerSize")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpResponseTransferCoding(e) => {
                            f.debug_tuple("ErrorCode::HttpResponseTransferCoding")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpResponseContentCoding(e) => {
                            f.debug_tuple("ErrorCode::HttpResponseContentCoding")
                                .field(e)
                                .finish()
                        }
                        ErrorCode::HttpResponseTimeout => {
                            f.debug_tuple("ErrorCode::HttpResponseTimeout").finish()
                        }
                        ErrorCode::HttpUpgradeFailed => {
                            f.debug_tuple("ErrorCode::HttpUpgradeFailed").finish()
                        }
                        ErrorCode::HttpProtocolError => {
                            f.debug_tuple("ErrorCode::HttpProtocolError").finish()
                        }
                        ErrorCode::LoopDetected => {
                            f.debug_tuple("ErrorCode::LoopDetected").finish()
                        }
                        ErrorCode::ConfigurationError => {
                            f.debug_tuple("ErrorCode::ConfigurationError").finish()
                        }
                        ErrorCode::InternalError(e) => {
                            f.debug_tuple("ErrorCode::InternalError").field(e).finish()
                        }
                    }
                }
            }
            impl ::core::fmt::Display for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for ErrorCode {}
            #[derive(Clone, Copy)]
            pub enum HeaderError {
                InvalidSyntax,
                Forbidden,
                Immutable,
            }
            impl ::core::fmt::Debug for HeaderError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        HeaderError::InvalidSyntax => {
                            f.debug_tuple("HeaderError::InvalidSyntax").finish()
                        }
                        HeaderError::Forbidden => {
                            f.debug_tuple("HeaderError::Forbidden").finish()
                        }
                        HeaderError::Immutable => {
                            f.debug_tuple("HeaderError::Immutable").finish()
                        }
                    }
                }
            }
            impl ::core::fmt::Display for HeaderError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for HeaderError {}
            pub type FieldKey = _rt::String;
            pub type FieldValue = _rt::Vec<u8>;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Fields {
                handle: _rt::Resource<Fields>,
            }
            impl Fields {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Fields {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]fields"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            pub type Headers = Fields;
            pub type Trailers = Fields;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct IncomingRequest {
                handle: _rt::Resource<IncomingRequest>,
            }
            impl IncomingRequest {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for IncomingRequest {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]incoming-request"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct OutgoingRequest {
                handle: _rt::Resource<OutgoingRequest>,
            }
            impl OutgoingRequest {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for OutgoingRequest {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]outgoing-request"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct RequestOptions {
                handle: _rt::Resource<RequestOptions>,
            }
            impl RequestOptions {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for RequestOptions {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]request-options"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct ResponseOutparam {
                handle: _rt::Resource<ResponseOutparam>,
            }
            impl ResponseOutparam {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for ResponseOutparam {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]response-outparam"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            pub type StatusCode = u16;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct IncomingResponse {
                handle: _rt::Resource<IncomingResponse>,
            }
            impl IncomingResponse {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for IncomingResponse {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]incoming-response"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct IncomingBody {
                handle: _rt::Resource<IncomingBody>,
            }
            impl IncomingBody {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for IncomingBody {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]incoming-body"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct FutureTrailers {
                handle: _rt::Resource<FutureTrailers>,
            }
            impl FutureTrailers {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for FutureTrailers {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]future-trailers"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct OutgoingResponse {
                handle: _rt::Resource<OutgoingResponse>,
            }
            impl OutgoingResponse {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for OutgoingResponse {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]outgoing-response"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct OutgoingBody {
                handle: _rt::Resource<OutgoingBody>,
            }
            impl OutgoingBody {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for OutgoingBody {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]outgoing-body"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct FutureIncomingResponse {
                handle: _rt::Resource<FutureIncomingResponse>,
            }
            impl FutureIncomingResponse {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for FutureIncomingResponse {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]future-incoming-response"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl Fields {
                #[allow(unused_unsafe, clippy::all)]
                pub fn new() -> Self {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[constructor]fields"]
                            fn wit_import0() -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0() -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0() };
                        unsafe { Fields::from_handle(ret as u32) }
                    }
                }
            }
            impl Fields {
                #[allow(unused_unsafe, clippy::all)]
                pub fn from_list(
                    entries: &[(FieldKey, FieldValue)],
                ) -> Result<Fields, HeaderError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let vec3 = entries;
                        let len3 = vec3.len();
                        let layout3 = _rt::alloc::Layout::from_size_align_unchecked(
                            vec3.len() * (4 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result3 = if layout3.size() != 0 {
                            let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
                            if ptr.is_null() {
                                _rt::alloc::handle_alloc_error(layout3);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec3.into_iter().enumerate() {
                            let base = result3
                                .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                            {
                                let (t0_0, t0_1) = e;
                                let vec1 = t0_0;
                                let ptr1 = vec1.as_ptr().cast::<u8>();
                                let len1 = vec1.len();
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len1;
                                *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                                let vec2 = t0_1;
                                let ptr2 = vec2.as_ptr().cast::<u8>();
                                let len2 = vec2.len();
                                *base
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len2;
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>() = ptr2.cast_mut();
                            }
                        }
                        let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[static]fields.from-list"]
                            fn wit_import5(_: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import5(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe { wit_import5(result3, len3, ptr4) };
                        let l6 = i32::from(*ptr4.add(0).cast::<u8>());
                        let result10 = match l6 {
                            0 => {
                                let e = {
                                    let l7 = *ptr4.add(4).cast::<i32>();
                                    unsafe { Fields::from_handle(l7 as u32) }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l8 = i32::from(*ptr4.add(4).cast::<u8>());
                                    let v9 = match l8 {
                                        0 => HeaderError::InvalidSyntax,
                                        1 => HeaderError::Forbidden,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            HeaderError::Immutable
                                        }
                                    };
                                    v9
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        if layout3.size() != 0 {
                            _rt::alloc::dealloc(result3.cast(), layout3);
                        }
                        result10
                    }
                }
            }
            impl Fields {
                #[allow(unused_unsafe, clippy::all)]
                pub fn get(&self, name: &str) -> _rt::Vec<FieldValue> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec0 = name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]fields.get"]
                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            )
                        };
                        let l3 = *ptr1.add(0).cast::<*mut u8>();
                        let l4 = *ptr1
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let base8 = l3;
                        let len8 = l4;
                        let mut result8 = _rt::Vec::with_capacity(len8);
                        for i in 0..len8 {
                            let base = base8
                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                            let e8 = {
                                let l5 = *base.add(0).cast::<*mut u8>();
                                let l6 = *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len7 = l6;
                                _rt::Vec::from_raw_parts(l5.cast(), len7, len7)
                            };
                            result8.push(e8);
                        }
                        _rt::cabi_dealloc(
                            base8,
                            len8 * (2 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result9 = result8;
                        result9
                    }
                }
            }
            impl Fields {
                #[allow(unused_unsafe, clippy::all)]
                pub fn has(&self, name: &str) -> bool {
                    unsafe {
                        let vec0 = name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]fields.has"]
                            fn wit_import1(_: i32, _: *mut u8, _: usize) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                        ) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import1((self).handle() as i32, ptr0.cast_mut(), len0)
                        };
                        _rt::bool_lift(ret as u8)
                    }
                }
            }
            impl Fields {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set(
                    &self,
                    name: &str,
                    value: &[FieldValue],
                ) -> Result<(), HeaderError> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let vec2 = value;
                        let len2 = vec2.len();
                        let layout2 = _rt::alloc::Layout::from_size_align_unchecked(
                            vec2.len() * (2 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result2 = if layout2.size() != 0 {
                            let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
                            if ptr.is_null() {
                                _rt::alloc::handle_alloc_error(layout2);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec2.into_iter().enumerate() {
                            let base = result2
                                .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                            {
                                let vec1 = e;
                                let ptr1 = vec1.as_ptr().cast::<u8>();
                                let len1 = vec1.len();
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len1;
                                *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                            }
                        }
                        let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]fields.set"]
                            fn wit_import4(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import4(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import4(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                result2,
                                len2,
                                ptr3,
                            )
                        };
                        let l5 = i32::from(*ptr3.add(0).cast::<u8>());
                        let result8 = match l5 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l6 = i32::from(*ptr3.add(1).cast::<u8>());
                                    let v7 = match l6 {
                                        0 => HeaderError::InvalidSyntax,
                                        1 => HeaderError::Forbidden,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            HeaderError::Immutable
                                        }
                                    };
                                    v7
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        if layout2.size() != 0 {
                            _rt::alloc::dealloc(result2.cast(), layout2);
                        }
                        result8
                    }
                }
            }
            impl Fields {
                #[allow(unused_unsafe, clippy::all)]
                pub fn delete(&self, name: &str) -> Result<(), HeaderError> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]fields.delete"]
                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result6 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(1).cast::<u8>());
                                    let v5 = match l4 {
                                        0 => HeaderError::InvalidSyntax,
                                        1 => HeaderError::Forbidden,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            HeaderError::Immutable
                                        }
                                    };
                                    v5
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl Fields {
                #[allow(unused_unsafe, clippy::all)]
                pub fn append(
                    &self,
                    name: &str,
                    value: &[u8],
                ) -> Result<(), HeaderError> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let vec0 = name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let vec1 = value;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]fields.append"]
                            fn wit_import3(
                                _: i32,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                                _: usize,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import3(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1.cast_mut(),
                                len1,
                                ptr2,
                            )
                        };
                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                        let result7 = match l4 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr2.add(1).cast::<u8>());
                                    let v6 = match l5 {
                                        0 => HeaderError::InvalidSyntax,
                                        1 => HeaderError::Forbidden,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            HeaderError::Immutable
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl Fields {
                #[allow(unused_unsafe, clippy::all)]
                pub fn entries(&self) -> _rt::Vec<(FieldKey, FieldValue)> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]fields.entries"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                        let l3 = *ptr0
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let base10 = l2;
                        let len10 = l3;
                        let mut result10 = _rt::Vec::with_capacity(len10);
                        for i in 0..len10 {
                            let base = base10
                                .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                            let e10 = {
                                let l4 = *base.add(0).cast::<*mut u8>();
                                let l5 = *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len6 = l5;
                                let bytes6 = _rt::Vec::from_raw_parts(
                                    l4.cast(),
                                    len6,
                                    len6,
                                );
                                let l7 = *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l8 = *base
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len9 = l8;
                                (
                                    _rt::string_lift(bytes6),
                                    _rt::Vec::from_raw_parts(l7.cast(), len9, len9),
                                )
                            };
                            result10.push(e10);
                        }
                        _rt::cabi_dealloc(
                            base10,
                            len10 * (4 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result11 = result10;
                        result11
                    }
                }
            }
            impl Fields {
                #[allow(unused_unsafe, clippy::all)]
                pub fn clone(&self) -> Fields {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]fields.clone"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe { Fields::from_handle(ret as u32) }
                    }
                }
            }
            impl IncomingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn method(&self) -> Method {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-request.method"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let v6 = match l2 {
                            0 => Method::Get,
                            1 => Method::Head,
                            2 => Method::Post,
                            3 => Method::Put,
                            4 => Method::Delete,
                            5 => Method::Connect,
                            6 => Method::Options,
                            7 => Method::Trace,
                            8 => Method::Patch,
                            n => {
                                debug_assert_eq!(n, 9, "invalid enum discriminant");
                                let e6 = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    let bytes5 = _rt::Vec::from_raw_parts(
                                        l3.cast(),
                                        len5,
                                        len5,
                                    );
                                    _rt::string_lift(bytes5)
                                };
                                Method::Other(e6)
                            }
                        };
                        let result7 = v6;
                        result7
                    }
                }
            }
            impl IncomingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn path_with_query(&self) -> Option<_rt::String> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-request.path-with-query"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    let bytes5 = _rt::Vec::from_raw_parts(
                                        l3.cast(),
                                        len5,
                                        len5,
                                    );
                                    _rt::string_lift(bytes5)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl IncomingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn scheme(&self) -> Option<Scheme> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-request.scheme"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result8 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v7 = match l3 {
                                        0 => Scheme::Http,
                                        1 => Scheme::Https,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e7 = {
                                                let l4 = *ptr0
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l5 = *ptr0
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len6 = l5;
                                                let bytes6 = _rt::Vec::from_raw_parts(
                                                    l4.cast(),
                                                    len6,
                                                    len6,
                                                );
                                                _rt::string_lift(bytes6)
                                            };
                                            Scheme::Other(e7)
                                        }
                                    };
                                    v7
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
            }
            impl IncomingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn authority(&self) -> Option<_rt::String> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-request.authority"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    let bytes5 = _rt::Vec::from_raw_parts(
                                        l3.cast(),
                                        len5,
                                        len5,
                                    );
                                    _rt::string_lift(bytes5)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl IncomingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn headers(&self) -> Headers {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-request.headers"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe { Fields::from_handle(ret as u32) }
                    }
                }
            }
            impl IncomingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn consume(&self) -> Result<IncomingBody, ()> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-request.consume"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    unsafe { IncomingBody::from_handle(l3 as u32) }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl OutgoingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn new(headers: Headers) -> Self {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[constructor]outgoing-request"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import0((&headers).take_handle() as i32)
                        };
                        unsafe { OutgoingRequest::from_handle(ret as u32) }
                    }
                }
            }
            impl OutgoingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn body(&self) -> Result<OutgoingBody, ()> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-request.body"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    unsafe { OutgoingBody::from_handle(l3 as u32) }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl OutgoingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn method(&self) -> Method {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-request.method"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let v6 = match l2 {
                            0 => Method::Get,
                            1 => Method::Head,
                            2 => Method::Post,
                            3 => Method::Put,
                            4 => Method::Delete,
                            5 => Method::Connect,
                            6 => Method::Options,
                            7 => Method::Trace,
                            8 => Method::Patch,
                            n => {
                                debug_assert_eq!(n, 9, "invalid enum discriminant");
                                let e6 = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    let bytes5 = _rt::Vec::from_raw_parts(
                                        l3.cast(),
                                        len5,
                                        len5,
                                    );
                                    _rt::string_lift(bytes5)
                                };
                                Method::Other(e6)
                            }
                        };
                        let result7 = v6;
                        result7
                    }
                }
            }
            impl OutgoingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_method(&self, method: &Method) -> Result<(), ()> {
                    unsafe {
                        let (result1_0, result1_1, result1_2) = match method {
                            Method::Get => (0i32, ::core::ptr::null_mut(), 0usize),
                            Method::Head => (1i32, ::core::ptr::null_mut(), 0usize),
                            Method::Post => (2i32, ::core::ptr::null_mut(), 0usize),
                            Method::Put => (3i32, ::core::ptr::null_mut(), 0usize),
                            Method::Delete => (4i32, ::core::ptr::null_mut(), 0usize),
                            Method::Connect => (5i32, ::core::ptr::null_mut(), 0usize),
                            Method::Options => (6i32, ::core::ptr::null_mut(), 0usize),
                            Method::Trace => (7i32, ::core::ptr::null_mut(), 0usize),
                            Method::Patch => (8i32, ::core::ptr::null_mut(), 0usize),
                            Method::Other(e) => {
                                let vec0 = e;
                                let ptr0 = vec0.as_ptr().cast::<u8>();
                                let len0 = vec0.len();
                                (9i32, ptr0.cast_mut(), len0)
                            }
                        };
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-request.set-method"]
                            fn wit_import2(_: i32, _: i32, _: *mut u8, _: usize) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                        ) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                result1_0,
                                result1_1,
                                result1_2,
                            )
                        };
                        match ret {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl OutgoingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn path_with_query(&self) -> Option<_rt::String> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-request.path-with-query"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    let bytes5 = _rt::Vec::from_raw_parts(
                                        l3.cast(),
                                        len5,
                                        len5,
                                    );
                                    _rt::string_lift(bytes5)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl OutgoingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_path_with_query(
                    &self,
                    path_with_query: Option<&str>,
                ) -> Result<(), ()> {
                    unsafe {
                        let (result1_0, result1_1, result1_2) = match path_with_query {
                            Some(e) => {
                                let vec0 = e;
                                let ptr0 = vec0.as_ptr().cast::<u8>();
                                let len0 = vec0.len();
                                (1i32, ptr0.cast_mut(), len0)
                            }
                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                        };
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-request.set-path-with-query"]
                            fn wit_import2(_: i32, _: i32, _: *mut u8, _: usize) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                        ) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                result1_0,
                                result1_1,
                                result1_2,
                            )
                        };
                        match ret {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl OutgoingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn scheme(&self) -> Option<Scheme> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 4
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-request.scheme"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result8 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v7 = match l3 {
                                        0 => Scheme::Http,
                                        1 => Scheme::Https,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e7 = {
                                                let l4 = *ptr0
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l5 = *ptr0
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len6 = l5;
                                                let bytes6 = _rt::Vec::from_raw_parts(
                                                    l4.cast(),
                                                    len6,
                                                    len6,
                                                );
                                                _rt::string_lift(bytes6)
                                            };
                                            Scheme::Other(e7)
                                        }
                                    };
                                    v7
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result8
                    }
                }
            }
            impl OutgoingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_scheme(&self, scheme: Option<&Scheme>) -> Result<(), ()> {
                    unsafe {
                        let (result2_0, result2_1, result2_2, result2_3) = match scheme {
                            Some(e) => {
                                let (result1_0, result1_1, result1_2) = match e {
                                    Scheme::Http => (0i32, ::core::ptr::null_mut(), 0usize),
                                    Scheme::Https => (1i32, ::core::ptr::null_mut(), 0usize),
                                    Scheme::Other(e) => {
                                        let vec0 = e;
                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                        let len0 = vec0.len();
                                        (2i32, ptr0.cast_mut(), len0)
                                    }
                                };
                                (1i32, result1_0, result1_1, result1_2)
                            }
                            None => (0i32, 0i32, ::core::ptr::null_mut(), 0usize),
                        };
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-request.set-scheme"]
                            fn wit_import3(
                                _: i32,
                                _: i32,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                            ) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import3(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                        ) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import3(
                                (self).handle() as i32,
                                result2_0,
                                result2_1,
                                result2_2,
                                result2_3,
                            )
                        };
                        match ret {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl OutgoingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn authority(&self) -> Option<_rt::String> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-request.authority"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    let bytes5 = _rt::Vec::from_raw_parts(
                                        l3.cast(),
                                        len5,
                                        len5,
                                    );
                                    _rt::string_lift(bytes5)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl OutgoingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_authority(&self, authority: Option<&str>) -> Result<(), ()> {
                    unsafe {
                        let (result1_0, result1_1, result1_2) = match authority {
                            Some(e) => {
                                let vec0 = e;
                                let ptr0 = vec0.as_ptr().cast::<u8>();
                                let len0 = vec0.len();
                                (1i32, ptr0.cast_mut(), len0)
                            }
                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                        };
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-request.set-authority"]
                            fn wit_import2(_: i32, _: i32, _: *mut u8, _: usize) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                        ) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                result1_0,
                                result1_1,
                                result1_2,
                            )
                        };
                        match ret {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl OutgoingRequest {
                #[allow(unused_unsafe, clippy::all)]
                pub fn headers(&self) -> Headers {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-request.headers"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe { Fields::from_handle(ret as u32) }
                    }
                }
            }
            impl RequestOptions {
                #[allow(unused_unsafe, clippy::all)]
                pub fn new() -> Self {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[constructor]request-options"]
                            fn wit_import0() -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0() -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0() };
                        unsafe { RequestOptions::from_handle(ret as u32) }
                    }
                }
            }
            impl RequestOptions {
                #[allow(unused_unsafe, clippy::all)]
                pub fn connect_timeout(&self) -> Option<Duration> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]request-options.connect-timeout"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl RequestOptions {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_connect_timeout(
                    &self,
                    duration: Option<Duration>,
                ) -> Result<(), ()> {
                    unsafe {
                        let (result0_0, result0_1) = match duration {
                            Some(e) => (1i32, _rt::as_i64(e)),
                            None => (0i32, 0i64),
                        };
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]request-options.set-connect-timeout"]
                            fn wit_import1(_: i32, _: i32, _: i64) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: i64) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import1((self).handle() as i32, result0_0, result0_1)
                        };
                        match ret {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl RequestOptions {
                #[allow(unused_unsafe, clippy::all)]
                pub fn first_byte_timeout(&self) -> Option<Duration> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]request-options.first-byte-timeout"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl RequestOptions {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_first_byte_timeout(
                    &self,
                    duration: Option<Duration>,
                ) -> Result<(), ()> {
                    unsafe {
                        let (result0_0, result0_1) = match duration {
                            Some(e) => (1i32, _rt::as_i64(e)),
                            None => (0i32, 0i64),
                        };
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]request-options.set-first-byte-timeout"]
                            fn wit_import1(_: i32, _: i32, _: i64) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: i64) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import1((self).handle() as i32, result0_0, result0_1)
                        };
                        match ret {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl RequestOptions {
                #[allow(unused_unsafe, clippy::all)]
                pub fn between_bytes_timeout(&self) -> Option<Duration> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]request-options.between-bytes-timeout"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl RequestOptions {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_between_bytes_timeout(
                    &self,
                    duration: Option<Duration>,
                ) -> Result<(), ()> {
                    unsafe {
                        let (result0_0, result0_1) = match duration {
                            Some(e) => (1i32, _rt::as_i64(e)),
                            None => (0i32, 0i64),
                        };
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]request-options.set-between-bytes-timeout"]
                            fn wit_import1(_: i32, _: i32, _: i64) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: i64) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import1((self).handle() as i32, result0_0, result0_1)
                        };
                        match ret {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl ResponseOutparam {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set(
                    param: ResponseOutparam,
                    response: Result<OutgoingResponse, ErrorCode>,
                ) -> () {
                    unsafe {
                        let (
                            result38_0,
                            result38_1,
                            result38_2,
                            result38_3,
                            result38_4,
                            result38_5,
                            result38_6,
                            result38_7,
                        ) = match &response {
                            Ok(e) => {
                                (
                                    0i32,
                                    (e).take_handle() as i32,
                                    0i32,
                                    ::core::mem::MaybeUninit::<u64>::zeroed(),
                                    ::core::ptr::null_mut(),
                                    ::core::ptr::null_mut(),
                                    0usize,
                                    0i32,
                                )
                            }
                            Err(e) => {
                                let (
                                    result37_0,
                                    result37_1,
                                    result37_2,
                                    result37_3,
                                    result37_4,
                                    result37_5,
                                    result37_6,
                                ) = match e {
                                    ErrorCode::DnsTimeout => {
                                        (
                                            0i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::DnsError(e) => {
                                        let DnsErrorPayload {
                                            rcode: rcode0,
                                            info_code: info_code0,
                                        } = e;
                                        let (result2_0, result2_1, result2_2) = match rcode0 {
                                            Some(e) => {
                                                let vec1 = e;
                                                let ptr1 = vec1.as_ptr().cast::<u8>();
                                                let len1 = vec1.len();
                                                (1i32, ptr1.cast_mut(), len1)
                                            }
                                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                                        };
                                        let (result3_0, result3_1) = match info_code0 {
                                            Some(e) => (1i32, _rt::as_i32(e)),
                                            None => (0i32, 0i32),
                                        };
                                        (
                                            1i32,
                                            result2_0,
                                            {
                                                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                                                t.as_mut_ptr().cast::<*mut u8>().write(result2_1);
                                                t
                                            },
                                            result2_2 as *mut u8,
                                            result3_0 as *mut u8,
                                            result3_1 as usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::DestinationNotFound => {
                                        (
                                            2i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::DestinationUnavailable => {
                                        (
                                            3i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::DestinationIpProhibited => {
                                        (
                                            4i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::DestinationIpUnroutable => {
                                        (
                                            5i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::ConnectionRefused => {
                                        (
                                            6i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::ConnectionTerminated => {
                                        (
                                            7i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::ConnectionTimeout => {
                                        (
                                            8i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::ConnectionReadTimeout => {
                                        (
                                            9i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::ConnectionWriteTimeout => {
                                        (
                                            10i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::ConnectionLimitReached => {
                                        (
                                            11i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::TlsProtocolError => {
                                        (
                                            12i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::TlsCertificateError => {
                                        (
                                            13i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::TlsAlertReceived(e) => {
                                        let TlsAlertReceivedPayload {
                                            alert_id: alert_id4,
                                            alert_message: alert_message4,
                                        } = e;
                                        let (result5_0, result5_1) = match alert_id4 {
                                            Some(e) => (1i32, _rt::as_i32(e)),
                                            None => (0i32, 0i32),
                                        };
                                        let (result7_0, result7_1, result7_2) = match alert_message4 {
                                            Some(e) => {
                                                let vec6 = e;
                                                let ptr6 = vec6.as_ptr().cast::<u8>();
                                                let len6 = vec6.len();
                                                (1i32, ptr6.cast_mut(), len6)
                                            }
                                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                                        };
                                        (
                                            14i32,
                                            result5_0,
                                            ::core::mem::MaybeUninit::new(i64::from(result5_1) as u64),
                                            result7_0 as *mut u8,
                                            result7_1,
                                            result7_2,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpRequestDenied => {
                                        (
                                            15i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpRequestLengthRequired => {
                                        (
                                            16i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpRequestBodySize(e) => {
                                        let (result8_0, result8_1) = match e {
                                            Some(e) => (1i32, _rt::as_i64(e)),
                                            None => (0i32, 0i64),
                                        };
                                        (
                                            17i32,
                                            result8_0,
                                            ::core::mem::MaybeUninit::new(result8_1 as u64),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpRequestMethodInvalid => {
                                        (
                                            18i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpRequestUriInvalid => {
                                        (
                                            19i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpRequestUriTooLong => {
                                        (
                                            20i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpRequestHeaderSectionSize(e) => {
                                        let (result9_0, result9_1) = match e {
                                            Some(e) => (1i32, _rt::as_i32(e)),
                                            None => (0i32, 0i32),
                                        };
                                        (
                                            21i32,
                                            result9_0,
                                            ::core::mem::MaybeUninit::new(i64::from(result9_1) as u64),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpRequestHeaderSize(e) => {
                                        let (
                                            result14_0,
                                            result14_1,
                                            result14_2,
                                            result14_3,
                                            result14_4,
                                            result14_5,
                                        ) = match e {
                                            Some(e) => {
                                                let FieldSizePayload {
                                                    field_name: field_name10,
                                                    field_size: field_size10,
                                                } = e;
                                                let (result12_0, result12_1, result12_2) = match field_name10 {
                                                    Some(e) => {
                                                        let vec11 = e;
                                                        let ptr11 = vec11.as_ptr().cast::<u8>();
                                                        let len11 = vec11.len();
                                                        (1i32, ptr11.cast_mut(), len11)
                                                    }
                                                    None => (0i32, ::core::ptr::null_mut(), 0usize),
                                                };
                                                let (result13_0, result13_1) = match field_size10 {
                                                    Some(e) => (1i32, _rt::as_i32(e)),
                                                    None => (0i32, 0i32),
                                                };
                                                (
                                                    1i32,
                                                    result12_0,
                                                    result12_1,
                                                    result12_2,
                                                    result13_0,
                                                    result13_1,
                                                )
                                            }
                                            None => {
                                                (0i32, 0i32, ::core::ptr::null_mut(), 0usize, 0i32, 0i32)
                                            }
                                        };
                                        (
                                            22i32,
                                            result14_0,
                                            ::core::mem::MaybeUninit::new(i64::from(result14_1) as u64),
                                            result14_2,
                                            result14_3 as *mut u8,
                                            result14_4 as usize,
                                            result14_5,
                                        )
                                    }
                                    ErrorCode::HttpRequestTrailerSectionSize(e) => {
                                        let (result15_0, result15_1) = match e {
                                            Some(e) => (1i32, _rt::as_i32(e)),
                                            None => (0i32, 0i32),
                                        };
                                        (
                                            23i32,
                                            result15_0,
                                            ::core::mem::MaybeUninit::new(i64::from(result15_1) as u64),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpRequestTrailerSize(e) => {
                                        let FieldSizePayload {
                                            field_name: field_name16,
                                            field_size: field_size16,
                                        } = e;
                                        let (result18_0, result18_1, result18_2) = match field_name16 {
                                            Some(e) => {
                                                let vec17 = e;
                                                let ptr17 = vec17.as_ptr().cast::<u8>();
                                                let len17 = vec17.len();
                                                (1i32, ptr17.cast_mut(), len17)
                                            }
                                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                                        };
                                        let (result19_0, result19_1) = match field_size16 {
                                            Some(e) => (1i32, _rt::as_i32(e)),
                                            None => (0i32, 0i32),
                                        };
                                        (
                                            24i32,
                                            result18_0,
                                            {
                                                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                                                t.as_mut_ptr().cast::<*mut u8>().write(result18_1);
                                                t
                                            },
                                            result18_2 as *mut u8,
                                            result19_0 as *mut u8,
                                            result19_1 as usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpResponseIncomplete => {
                                        (
                                            25i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpResponseHeaderSectionSize(e) => {
                                        let (result20_0, result20_1) = match e {
                                            Some(e) => (1i32, _rt::as_i32(e)),
                                            None => (0i32, 0i32),
                                        };
                                        (
                                            26i32,
                                            result20_0,
                                            ::core::mem::MaybeUninit::new(i64::from(result20_1) as u64),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpResponseHeaderSize(e) => {
                                        let FieldSizePayload {
                                            field_name: field_name21,
                                            field_size: field_size21,
                                        } = e;
                                        let (result23_0, result23_1, result23_2) = match field_name21 {
                                            Some(e) => {
                                                let vec22 = e;
                                                let ptr22 = vec22.as_ptr().cast::<u8>();
                                                let len22 = vec22.len();
                                                (1i32, ptr22.cast_mut(), len22)
                                            }
                                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                                        };
                                        let (result24_0, result24_1) = match field_size21 {
                                            Some(e) => (1i32, _rt::as_i32(e)),
                                            None => (0i32, 0i32),
                                        };
                                        (
                                            27i32,
                                            result23_0,
                                            {
                                                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                                                t.as_mut_ptr().cast::<*mut u8>().write(result23_1);
                                                t
                                            },
                                            result23_2 as *mut u8,
                                            result24_0 as *mut u8,
                                            result24_1 as usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpResponseBodySize(e) => {
                                        let (result25_0, result25_1) = match e {
                                            Some(e) => (1i32, _rt::as_i64(e)),
                                            None => (0i32, 0i64),
                                        };
                                        (
                                            28i32,
                                            result25_0,
                                            ::core::mem::MaybeUninit::new(result25_1 as u64),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpResponseTrailerSectionSize(e) => {
                                        let (result26_0, result26_1) = match e {
                                            Some(e) => (1i32, _rt::as_i32(e)),
                                            None => (0i32, 0i32),
                                        };
                                        (
                                            29i32,
                                            result26_0,
                                            ::core::mem::MaybeUninit::new(i64::from(result26_1) as u64),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpResponseTrailerSize(e) => {
                                        let FieldSizePayload {
                                            field_name: field_name27,
                                            field_size: field_size27,
                                        } = e;
                                        let (result29_0, result29_1, result29_2) = match field_name27 {
                                            Some(e) => {
                                                let vec28 = e;
                                                let ptr28 = vec28.as_ptr().cast::<u8>();
                                                let len28 = vec28.len();
                                                (1i32, ptr28.cast_mut(), len28)
                                            }
                                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                                        };
                                        let (result30_0, result30_1) = match field_size27 {
                                            Some(e) => (1i32, _rt::as_i32(e)),
                                            None => (0i32, 0i32),
                                        };
                                        (
                                            30i32,
                                            result29_0,
                                            {
                                                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                                                t.as_mut_ptr().cast::<*mut u8>().write(result29_1);
                                                t
                                            },
                                            result29_2 as *mut u8,
                                            result30_0 as *mut u8,
                                            result30_1 as usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpResponseTransferCoding(e) => {
                                        let (result32_0, result32_1, result32_2) = match e {
                                            Some(e) => {
                                                let vec31 = e;
                                                let ptr31 = vec31.as_ptr().cast::<u8>();
                                                let len31 = vec31.len();
                                                (1i32, ptr31.cast_mut(), len31)
                                            }
                                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                                        };
                                        (
                                            31i32,
                                            result32_0,
                                            {
                                                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                                                t.as_mut_ptr().cast::<*mut u8>().write(result32_1);
                                                t
                                            },
                                            result32_2 as *mut u8,
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpResponseContentCoding(e) => {
                                        let (result34_0, result34_1, result34_2) = match e {
                                            Some(e) => {
                                                let vec33 = e;
                                                let ptr33 = vec33.as_ptr().cast::<u8>();
                                                let len33 = vec33.len();
                                                (1i32, ptr33.cast_mut(), len33)
                                            }
                                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                                        };
                                        (
                                            32i32,
                                            result34_0,
                                            {
                                                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                                                t.as_mut_ptr().cast::<*mut u8>().write(result34_1);
                                                t
                                            },
                                            result34_2 as *mut u8,
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpResponseTimeout => {
                                        (
                                            33i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpUpgradeFailed => {
                                        (
                                            34i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::HttpProtocolError => {
                                        (
                                            35i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::LoopDetected => {
                                        (
                                            36i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::ConfigurationError => {
                                        (
                                            37i32,
                                            0i32,
                                            ::core::mem::MaybeUninit::<u64>::zeroed(),
                                            ::core::ptr::null_mut(),
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                    ErrorCode::InternalError(e) => {
                                        let (result36_0, result36_1, result36_2) = match e {
                                            Some(e) => {
                                                let vec35 = e;
                                                let ptr35 = vec35.as_ptr().cast::<u8>();
                                                let len35 = vec35.len();
                                                (1i32, ptr35.cast_mut(), len35)
                                            }
                                            None => (0i32, ::core::ptr::null_mut(), 0usize),
                                        };
                                        (
                                            38i32,
                                            result36_0,
                                            {
                                                let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                                                t.as_mut_ptr().cast::<*mut u8>().write(result36_1);
                                                t
                                            },
                                            result36_2 as *mut u8,
                                            ::core::ptr::null_mut(),
                                            0usize,
                                            0i32,
                                        )
                                    }
                                };
                                (
                                    1i32,
                                    result37_0,
                                    result37_1,
                                    result37_2,
                                    result37_3,
                                    result37_4,
                                    result37_5,
                                    result37_6,
                                )
                            }
                        };
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[static]response-outparam.set"]
                            fn wit_import39(
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: ::core::mem::MaybeUninit<u64>,
                                _: *mut u8,
                                _: *mut u8,
                                _: usize,
                                _: i32,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import39(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: ::core::mem::MaybeUninit<u64>,
                            _: *mut u8,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import39(
                                (&param).take_handle() as i32,
                                result38_0,
                                result38_1,
                                result38_2,
                                result38_3,
                                result38_4,
                                result38_5,
                                result38_6,
                                result38_7,
                            )
                        };
                    }
                }
            }
            impl IncomingResponse {
                #[allow(unused_unsafe, clippy::all)]
                pub fn status(&self) -> StatusCode {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-response.status"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        ret as u16
                    }
                }
            }
            impl IncomingResponse {
                #[allow(unused_unsafe, clippy::all)]
                pub fn headers(&self) -> Headers {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-response.headers"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe { Fields::from_handle(ret as u32) }
                    }
                }
            }
            impl IncomingResponse {
                #[allow(unused_unsafe, clippy::all)]
                pub fn consume(&self) -> Result<IncomingBody, ()> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-response.consume"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    unsafe { IncomingBody::from_handle(l3 as u32) }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl IncomingBody {
                #[allow(unused_unsafe, clippy::all)]
                pub fn stream(&self) -> Result<InputStream, ()> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-body.stream"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    unsafe {
                                        super::super::super::wasi::io::streams::InputStream::from_handle(
                                            l3 as u32,
                                        )
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl IncomingBody {
                #[allow(unused_unsafe, clippy::all)]
                pub fn finish(this: IncomingBody) -> FutureTrailers {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[static]incoming-body.finish"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((&this).take_handle() as i32) };
                        unsafe { FutureTrailers::from_handle(ret as u32) }
                    }
                }
            }
            impl FutureTrailers {
                #[allow(unused_unsafe, clippy::all)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]future-trailers.subscribe"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe {
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
            }
            impl FutureTrailers {
                #[allow(unused_unsafe, clippy::all)]
                pub fn get(
                    &self,
                ) -> Option<Result<Result<Option<Trailers>, ErrorCode>, ()>> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 40 + 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 40
                                + 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]future-trailers.get"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result70 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                                    match l3 {
                                        0 => {
                                            let e = {
                                                let l4 = i32::from(*ptr0.add(16).cast::<u8>());
                                                match l4 {
                                                    0 => {
                                                        let e = {
                                                            let l5 = i32::from(*ptr0.add(24).cast::<u8>());
                                                            match l5 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l6 = *ptr0.add(28).cast::<i32>();
                                                                        unsafe { Fields::from_handle(l6 as u32) }
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            }
                                                        };
                                                        Ok(e)
                                                    }
                                                    1 => {
                                                        let e = {
                                                            let l7 = i32::from(*ptr0.add(24).cast::<u8>());
                                                            let v69 = match l7 {
                                                                0 => ErrorCode::DnsTimeout,
                                                                1 => {
                                                                    let e69 = {
                                                                        let l8 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        let l12 = i32::from(
                                                                            *ptr0
                                                                                .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>(),
                                                                        );
                                                                        DnsErrorPayload {
                                                                            rcode: match l8 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l9 = *ptr0
                                                                                            .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>();
                                                                                        let l10 = *ptr0
                                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len11 = l10;
                                                                                        let bytes11 = _rt::Vec::from_raw_parts(
                                                                                            l9.cast(),
                                                                                            len11,
                                                                                            len11,
                                                                                        );
                                                                                        _rt::string_lift(bytes11)
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                            info_code: match l12 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l13 = i32::from(
                                                                                            *ptr0
                                                                                                .add(34 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<u16>(),
                                                                                        );
                                                                                        l13 as u16
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                        }
                                                                    };
                                                                    ErrorCode::DnsError(e69)
                                                                }
                                                                2 => ErrorCode::DestinationNotFound,
                                                                3 => ErrorCode::DestinationUnavailable,
                                                                4 => ErrorCode::DestinationIpProhibited,
                                                                5 => ErrorCode::DestinationIpUnroutable,
                                                                6 => ErrorCode::ConnectionRefused,
                                                                7 => ErrorCode::ConnectionTerminated,
                                                                8 => ErrorCode::ConnectionTimeout,
                                                                9 => ErrorCode::ConnectionReadTimeout,
                                                                10 => ErrorCode::ConnectionWriteTimeout,
                                                                11 => ErrorCode::ConnectionLimitReached,
                                                                12 => ErrorCode::TlsProtocolError,
                                                                13 => ErrorCode::TlsCertificateError,
                                                                14 => {
                                                                    let e69 = {
                                                                        let l14 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        let l16 = i32::from(
                                                                            *ptr0
                                                                                .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>(),
                                                                        );
                                                                        TlsAlertReceivedPayload {
                                                                            alert_id: match l14 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l15 = i32::from(*ptr0.add(33).cast::<u8>());
                                                                                        l15 as u8
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                            alert_message: match l16 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l17 = *ptr0
                                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>();
                                                                                        let l18 = *ptr0
                                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len19 = l18;
                                                                                        let bytes19 = _rt::Vec::from_raw_parts(
                                                                                            l17.cast(),
                                                                                            len19,
                                                                                            len19,
                                                                                        );
                                                                                        _rt::string_lift(bytes19)
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                        }
                                                                    };
                                                                    ErrorCode::TlsAlertReceived(e69)
                                                                }
                                                                15 => ErrorCode::HttpRequestDenied,
                                                                16 => ErrorCode::HttpRequestLengthRequired,
                                                                17 => {
                                                                    let e69 = {
                                                                        let l20 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l20 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l21 = *ptr0.add(40).cast::<i64>();
                                                                                    l21 as u64
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpRequestBodySize(e69)
                                                                }
                                                                18 => ErrorCode::HttpRequestMethodInvalid,
                                                                19 => ErrorCode::HttpRequestUriInvalid,
                                                                20 => ErrorCode::HttpRequestUriTooLong,
                                                                21 => {
                                                                    let e69 = {
                                                                        let l22 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l22 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l23 = *ptr0.add(36).cast::<i32>();
                                                                                    l23 as u32
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpRequestHeaderSectionSize(e69)
                                                                }
                                                                22 => {
                                                                    let e69 = {
                                                                        let l24 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l24 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l25 = i32::from(
                                                                                        *ptr0
                                                                                            .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>(),
                                                                                    );
                                                                                    let l29 = i32::from(
                                                                                        *ptr0
                                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>(),
                                                                                    );
                                                                                    FieldSizePayload {
                                                                                        field_name: match l25 {
                                                                                            0 => None,
                                                                                            1 => {
                                                                                                let e = {
                                                                                                    let l26 = *ptr0
                                                                                                        .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<*mut u8>();
                                                                                                    let l27 = *ptr0
                                                                                                        .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<usize>();
                                                                                                    let len28 = l27;
                                                                                                    let bytes28 = _rt::Vec::from_raw_parts(
                                                                                                        l26.cast(),
                                                                                                        len28,
                                                                                                        len28,
                                                                                                    );
                                                                                                    _rt::string_lift(bytes28)
                                                                                                };
                                                                                                Some(e)
                                                                                            }
                                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                                        },
                                                                                        field_size: match l29 {
                                                                                            0 => None,
                                                                                            1 => {
                                                                                                let e = {
                                                                                                    let l30 = *ptr0
                                                                                                        .add(36 + 4 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<i32>();
                                                                                                    l30 as u32
                                                                                                };
                                                                                                Some(e)
                                                                                            }
                                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                                        },
                                                                                    }
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpRequestHeaderSize(e69)
                                                                }
                                                                23 => {
                                                                    let e69 = {
                                                                        let l31 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l31 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l32 = *ptr0.add(36).cast::<i32>();
                                                                                    l32 as u32
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpRequestTrailerSectionSize(e69)
                                                                }
                                                                24 => {
                                                                    let e69 = {
                                                                        let l33 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        let l37 = i32::from(
                                                                            *ptr0
                                                                                .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>(),
                                                                        );
                                                                        FieldSizePayload {
                                                                            field_name: match l33 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l34 = *ptr0
                                                                                            .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>();
                                                                                        let l35 = *ptr0
                                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len36 = l35;
                                                                                        let bytes36 = _rt::Vec::from_raw_parts(
                                                                                            l34.cast(),
                                                                                            len36,
                                                                                            len36,
                                                                                        );
                                                                                        _rt::string_lift(bytes36)
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                            field_size: match l37 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l38 = *ptr0
                                                                                            .add(36 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i32>();
                                                                                        l38 as u32
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpRequestTrailerSize(e69)
                                                                }
                                                                25 => ErrorCode::HttpResponseIncomplete,
                                                                26 => {
                                                                    let e69 = {
                                                                        let l39 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l39 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l40 = *ptr0.add(36).cast::<i32>();
                                                                                    l40 as u32
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseHeaderSectionSize(e69)
                                                                }
                                                                27 => {
                                                                    let e69 = {
                                                                        let l41 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        let l45 = i32::from(
                                                                            *ptr0
                                                                                .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>(),
                                                                        );
                                                                        FieldSizePayload {
                                                                            field_name: match l41 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l42 = *ptr0
                                                                                            .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>();
                                                                                        let l43 = *ptr0
                                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len44 = l43;
                                                                                        let bytes44 = _rt::Vec::from_raw_parts(
                                                                                            l42.cast(),
                                                                                            len44,
                                                                                            len44,
                                                                                        );
                                                                                        _rt::string_lift(bytes44)
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                            field_size: match l45 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l46 = *ptr0
                                                                                            .add(36 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i32>();
                                                                                        l46 as u32
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseHeaderSize(e69)
                                                                }
                                                                28 => {
                                                                    let e69 = {
                                                                        let l47 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l47 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l48 = *ptr0.add(40).cast::<i64>();
                                                                                    l48 as u64
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseBodySize(e69)
                                                                }
                                                                29 => {
                                                                    let e69 = {
                                                                        let l49 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l49 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l50 = *ptr0.add(36).cast::<i32>();
                                                                                    l50 as u32
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseTrailerSectionSize(e69)
                                                                }
                                                                30 => {
                                                                    let e69 = {
                                                                        let l51 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        let l55 = i32::from(
                                                                            *ptr0
                                                                                .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>(),
                                                                        );
                                                                        FieldSizePayload {
                                                                            field_name: match l51 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l52 = *ptr0
                                                                                            .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>();
                                                                                        let l53 = *ptr0
                                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len54 = l53;
                                                                                        let bytes54 = _rt::Vec::from_raw_parts(
                                                                                            l52.cast(),
                                                                                            len54,
                                                                                            len54,
                                                                                        );
                                                                                        _rt::string_lift(bytes54)
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                            field_size: match l55 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l56 = *ptr0
                                                                                            .add(36 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i32>();
                                                                                        l56 as u32
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseTrailerSize(e69)
                                                                }
                                                                31 => {
                                                                    let e69 = {
                                                                        let l57 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l57 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l58 = *ptr0
                                                                                        .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<*mut u8>();
                                                                                    let l59 = *ptr0
                                                                                        .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let len60 = l59;
                                                                                    let bytes60 = _rt::Vec::from_raw_parts(
                                                                                        l58.cast(),
                                                                                        len60,
                                                                                        len60,
                                                                                    );
                                                                                    _rt::string_lift(bytes60)
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseTransferCoding(e69)
                                                                }
                                                                32 => {
                                                                    let e69 = {
                                                                        let l61 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l61 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l62 = *ptr0
                                                                                        .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<*mut u8>();
                                                                                    let l63 = *ptr0
                                                                                        .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let len64 = l63;
                                                                                    let bytes64 = _rt::Vec::from_raw_parts(
                                                                                        l62.cast(),
                                                                                        len64,
                                                                                        len64,
                                                                                    );
                                                                                    _rt::string_lift(bytes64)
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseContentCoding(e69)
                                                                }
                                                                33 => ErrorCode::HttpResponseTimeout,
                                                                34 => ErrorCode::HttpUpgradeFailed,
                                                                35 => ErrorCode::HttpProtocolError,
                                                                36 => ErrorCode::LoopDetected,
                                                                37 => ErrorCode::ConfigurationError,
                                                                n => {
                                                                    debug_assert_eq!(n, 38, "invalid enum discriminant");
                                                                    let e69 = {
                                                                        let l65 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l65 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l66 = *ptr0
                                                                                        .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<*mut u8>();
                                                                                    let l67 = *ptr0
                                                                                        .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let len68 = l67;
                                                                                    let bytes68 = _rt::Vec::from_raw_parts(
                                                                                        l66.cast(),
                                                                                        len68,
                                                                                        len68,
                                                                                    );
                                                                                    _rt::string_lift(bytes68)
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::InternalError(e69)
                                                                }
                                                            };
                                                            v69
                                                        };
                                                        Err(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = ();
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result70
                    }
                }
            }
            impl OutgoingResponse {
                #[allow(unused_unsafe, clippy::all)]
                pub fn new(headers: Headers) -> Self {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[constructor]outgoing-response"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import0((&headers).take_handle() as i32)
                        };
                        unsafe { OutgoingResponse::from_handle(ret as u32) }
                    }
                }
            }
            impl OutgoingResponse {
                #[allow(unused_unsafe, clippy::all)]
                pub fn status_code(&self) -> StatusCode {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-response.status-code"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        ret as u16
                    }
                }
            }
            impl OutgoingResponse {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_status_code(
                    &self,
                    status_code: StatusCode,
                ) -> Result<(), ()> {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-response.set-status-code"]
                            fn wit_import0(_: i32, _: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32, _: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import0((self).handle() as i32, _rt::as_i32(status_code))
                        };
                        match ret {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl OutgoingResponse {
                #[allow(unused_unsafe, clippy::all)]
                pub fn headers(&self) -> Headers {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-response.headers"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe { Fields::from_handle(ret as u32) }
                    }
                }
            }
            impl OutgoingResponse {
                #[allow(unused_unsafe, clippy::all)]
                pub fn body(&self) -> Result<OutgoingBody, ()> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-response.body"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    unsafe { OutgoingBody::from_handle(l3 as u32) }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl OutgoingBody {
                #[allow(unused_unsafe, clippy::all)]
                pub fn write(&self) -> Result<OutputStream, ()> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-body.write"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    unsafe {
                                        super::super::super::wasi::io::streams::OutputStream::from_handle(
                                            l3 as u32,
                                        )
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = ();
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl OutgoingBody {
                #[allow(unused_unsafe, clippy::all)]
                pub fn finish(
                    this: OutgoingBody,
                    trailers: Option<Trailers>,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 24 + 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 24
                                + 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let (result0_0, result0_1) = match &trailers {
                            Some(e) => (1i32, (e).take_handle() as i32),
                            None => (0i32, 0i32),
                        };
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[static]outgoing-body.finish"]
                            fn wit_import2(_: i32, _: i32, _: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (&this).take_handle() as i32,
                                result0_0,
                                result0_1,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result67 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(8).cast::<u8>());
                                    let v66 = match l4 {
                                        0 => ErrorCode::DnsTimeout,
                                        1 => {
                                            let e66 = {
                                                let l5 = i32::from(*ptr1.add(16).cast::<u8>());
                                                let l9 = i32::from(
                                                    *ptr1
                                                        .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                DnsErrorPayload {
                                                    rcode: match l5 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l6 = *ptr1
                                                                    .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>();
                                                                let l7 = *ptr1
                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                let len8 = l7;
                                                                let bytes8 = _rt::Vec::from_raw_parts(
                                                                    l6.cast(),
                                                                    len8,
                                                                    len8,
                                                                );
                                                                _rt::string_lift(bytes8)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    info_code: match l9 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l10 = i32::from(
                                                                    *ptr1
                                                                        .add(18 + 3 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<u16>(),
                                                                );
                                                                l10 as u16
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                }
                                            };
                                            ErrorCode::DnsError(e66)
                                        }
                                        2 => ErrorCode::DestinationNotFound,
                                        3 => ErrorCode::DestinationUnavailable,
                                        4 => ErrorCode::DestinationIpProhibited,
                                        5 => ErrorCode::DestinationIpUnroutable,
                                        6 => ErrorCode::ConnectionRefused,
                                        7 => ErrorCode::ConnectionTerminated,
                                        8 => ErrorCode::ConnectionTimeout,
                                        9 => ErrorCode::ConnectionReadTimeout,
                                        10 => ErrorCode::ConnectionWriteTimeout,
                                        11 => ErrorCode::ConnectionLimitReached,
                                        12 => ErrorCode::TlsProtocolError,
                                        13 => ErrorCode::TlsCertificateError,
                                        14 => {
                                            let e66 = {
                                                let l11 = i32::from(*ptr1.add(16).cast::<u8>());
                                                let l13 = i32::from(
                                                    *ptr1
                                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                TlsAlertReceivedPayload {
                                                    alert_id: match l11 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l12 = i32::from(*ptr1.add(17).cast::<u8>());
                                                                l12 as u8
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    alert_message: match l13 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l14 = *ptr1
                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>();
                                                                let l15 = *ptr1
                                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                let len16 = l15;
                                                                let bytes16 = _rt::Vec::from_raw_parts(
                                                                    l14.cast(),
                                                                    len16,
                                                                    len16,
                                                                );
                                                                _rt::string_lift(bytes16)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                }
                                            };
                                            ErrorCode::TlsAlertReceived(e66)
                                        }
                                        15 => ErrorCode::HttpRequestDenied,
                                        16 => ErrorCode::HttpRequestLengthRequired,
                                        17 => {
                                            let e66 = {
                                                let l17 = i32::from(*ptr1.add(16).cast::<u8>());
                                                match l17 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l18 = *ptr1.add(24).cast::<i64>();
                                                            l18 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            ErrorCode::HttpRequestBodySize(e66)
                                        }
                                        18 => ErrorCode::HttpRequestMethodInvalid,
                                        19 => ErrorCode::HttpRequestUriInvalid,
                                        20 => ErrorCode::HttpRequestUriTooLong,
                                        21 => {
                                            let e66 = {
                                                let l19 = i32::from(*ptr1.add(16).cast::<u8>());
                                                match l19 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l20 = *ptr1.add(20).cast::<i32>();
                                                            l20 as u32
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            ErrorCode::HttpRequestHeaderSectionSize(e66)
                                        }
                                        22 => {
                                            let e66 = {
                                                let l21 = i32::from(*ptr1.add(16).cast::<u8>());
                                                match l21 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l22 = i32::from(
                                                                *ptr1
                                                                    .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>(),
                                                            );
                                                            let l26 = i32::from(
                                                                *ptr1
                                                                    .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u8>(),
                                                            );
                                                            FieldSizePayload {
                                                                field_name: match l22 {
                                                                    0 => None,
                                                                    1 => {
                                                                        let e = {
                                                                            let l23 = *ptr1
                                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<*mut u8>();
                                                                            let l24 = *ptr1
                                                                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<usize>();
                                                                            let len25 = l24;
                                                                            let bytes25 = _rt::Vec::from_raw_parts(
                                                                                l23.cast(),
                                                                                len25,
                                                                                len25,
                                                                            );
                                                                            _rt::string_lift(bytes25)
                                                                        };
                                                                        Some(e)
                                                                    }
                                                                    _ => _rt::invalid_enum_discriminant(),
                                                                },
                                                                field_size: match l26 {
                                                                    0 => None,
                                                                    1 => {
                                                                        let e = {
                                                                            let l27 = *ptr1
                                                                                .add(20 + 4 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<i32>();
                                                                            l27 as u32
                                                                        };
                                                                        Some(e)
                                                                    }
                                                                    _ => _rt::invalid_enum_discriminant(),
                                                                },
                                                            }
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            ErrorCode::HttpRequestHeaderSize(e66)
                                        }
                                        23 => {
                                            let e66 = {
                                                let l28 = i32::from(*ptr1.add(16).cast::<u8>());
                                                match l28 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l29 = *ptr1.add(20).cast::<i32>();
                                                            l29 as u32
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            ErrorCode::HttpRequestTrailerSectionSize(e66)
                                        }
                                        24 => {
                                            let e66 = {
                                                let l30 = i32::from(*ptr1.add(16).cast::<u8>());
                                                let l34 = i32::from(
                                                    *ptr1
                                                        .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                FieldSizePayload {
                                                    field_name: match l30 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l31 = *ptr1
                                                                    .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>();
                                                                let l32 = *ptr1
                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                let len33 = l32;
                                                                let bytes33 = _rt::Vec::from_raw_parts(
                                                                    l31.cast(),
                                                                    len33,
                                                                    len33,
                                                                );
                                                                _rt::string_lift(bytes33)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    field_size: match l34 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l35 = *ptr1
                                                                    .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>();
                                                                l35 as u32
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                }
                                            };
                                            ErrorCode::HttpRequestTrailerSize(e66)
                                        }
                                        25 => ErrorCode::HttpResponseIncomplete,
                                        26 => {
                                            let e66 = {
                                                let l36 = i32::from(*ptr1.add(16).cast::<u8>());
                                                match l36 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l37 = *ptr1.add(20).cast::<i32>();
                                                            l37 as u32
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            ErrorCode::HttpResponseHeaderSectionSize(e66)
                                        }
                                        27 => {
                                            let e66 = {
                                                let l38 = i32::from(*ptr1.add(16).cast::<u8>());
                                                let l42 = i32::from(
                                                    *ptr1
                                                        .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                FieldSizePayload {
                                                    field_name: match l38 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l39 = *ptr1
                                                                    .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>();
                                                                let l40 = *ptr1
                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                let len41 = l40;
                                                                let bytes41 = _rt::Vec::from_raw_parts(
                                                                    l39.cast(),
                                                                    len41,
                                                                    len41,
                                                                );
                                                                _rt::string_lift(bytes41)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    field_size: match l42 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l43 = *ptr1
                                                                    .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>();
                                                                l43 as u32
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                }
                                            };
                                            ErrorCode::HttpResponseHeaderSize(e66)
                                        }
                                        28 => {
                                            let e66 = {
                                                let l44 = i32::from(*ptr1.add(16).cast::<u8>());
                                                match l44 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l45 = *ptr1.add(24).cast::<i64>();
                                                            l45 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            ErrorCode::HttpResponseBodySize(e66)
                                        }
                                        29 => {
                                            let e66 = {
                                                let l46 = i32::from(*ptr1.add(16).cast::<u8>());
                                                match l46 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l47 = *ptr1.add(20).cast::<i32>();
                                                            l47 as u32
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            ErrorCode::HttpResponseTrailerSectionSize(e66)
                                        }
                                        30 => {
                                            let e66 = {
                                                let l48 = i32::from(*ptr1.add(16).cast::<u8>());
                                                let l52 = i32::from(
                                                    *ptr1
                                                        .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>(),
                                                );
                                                FieldSizePayload {
                                                    field_name: match l48 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l49 = *ptr1
                                                                    .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<*mut u8>();
                                                                let l50 = *ptr1
                                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<usize>();
                                                                let len51 = l50;
                                                                let bytes51 = _rt::Vec::from_raw_parts(
                                                                    l49.cast(),
                                                                    len51,
                                                                    len51,
                                                                );
                                                                _rt::string_lift(bytes51)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    field_size: match l52 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l53 = *ptr1
                                                                    .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<i32>();
                                                                l53 as u32
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                }
                                            };
                                            ErrorCode::HttpResponseTrailerSize(e66)
                                        }
                                        31 => {
                                            let e66 = {
                                                let l54 = i32::from(*ptr1.add(16).cast::<u8>());
                                                match l54 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l55 = *ptr1
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l56 = *ptr1
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len57 = l56;
                                                            let bytes57 = _rt::Vec::from_raw_parts(
                                                                l55.cast(),
                                                                len57,
                                                                len57,
                                                            );
                                                            _rt::string_lift(bytes57)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            ErrorCode::HttpResponseTransferCoding(e66)
                                        }
                                        32 => {
                                            let e66 = {
                                                let l58 = i32::from(*ptr1.add(16).cast::<u8>());
                                                match l58 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l59 = *ptr1
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l60 = *ptr1
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len61 = l60;
                                                            let bytes61 = _rt::Vec::from_raw_parts(
                                                                l59.cast(),
                                                                len61,
                                                                len61,
                                                            );
                                                            _rt::string_lift(bytes61)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            ErrorCode::HttpResponseContentCoding(e66)
                                        }
                                        33 => ErrorCode::HttpResponseTimeout,
                                        34 => ErrorCode::HttpUpgradeFailed,
                                        35 => ErrorCode::HttpProtocolError,
                                        36 => ErrorCode::LoopDetected,
                                        37 => ErrorCode::ConfigurationError,
                                        n => {
                                            debug_assert_eq!(n, 38, "invalid enum discriminant");
                                            let e66 = {
                                                let l62 = i32::from(*ptr1.add(16).cast::<u8>());
                                                match l62 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l63 = *ptr1
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l64 = *ptr1
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len65 = l64;
                                                            let bytes65 = _rt::Vec::from_raw_parts(
                                                                l63.cast(),
                                                                len65,
                                                                len65,
                                                            );
                                                            _rt::string_lift(bytes65)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            ErrorCode::InternalError(e66)
                                        }
                                    };
                                    v66
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result67
                    }
                }
            }
            impl FutureIncomingResponse {
                #[allow(unused_unsafe, clippy::all)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]future-incoming-response.subscribe"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe {
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
            }
            impl FutureIncomingResponse {
                #[allow(unused_unsafe, clippy::all)]
                pub fn get(
                    &self,
                ) -> Option<Result<Result<IncomingResponse, ErrorCode>, ()>> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 40 + 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 40
                                + 4 * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]future-incoming-response.get"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result69 = match l2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                                    match l3 {
                                        0 => {
                                            let e = {
                                                let l4 = i32::from(*ptr0.add(16).cast::<u8>());
                                                match l4 {
                                                    0 => {
                                                        let e = {
                                                            let l5 = *ptr0.add(24).cast::<i32>();
                                                            unsafe { IncomingResponse::from_handle(l5 as u32) }
                                                        };
                                                        Ok(e)
                                                    }
                                                    1 => {
                                                        let e = {
                                                            let l6 = i32::from(*ptr0.add(24).cast::<u8>());
                                                            let v68 = match l6 {
                                                                0 => ErrorCode::DnsTimeout,
                                                                1 => {
                                                                    let e68 = {
                                                                        let l7 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        let l11 = i32::from(
                                                                            *ptr0
                                                                                .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>(),
                                                                        );
                                                                        DnsErrorPayload {
                                                                            rcode: match l7 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l8 = *ptr0
                                                                                            .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>();
                                                                                        let l9 = *ptr0
                                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len10 = l9;
                                                                                        let bytes10 = _rt::Vec::from_raw_parts(
                                                                                            l8.cast(),
                                                                                            len10,
                                                                                            len10,
                                                                                        );
                                                                                        _rt::string_lift(bytes10)
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                            info_code: match l11 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l12 = i32::from(
                                                                                            *ptr0
                                                                                                .add(34 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                                .cast::<u16>(),
                                                                                        );
                                                                                        l12 as u16
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                        }
                                                                    };
                                                                    ErrorCode::DnsError(e68)
                                                                }
                                                                2 => ErrorCode::DestinationNotFound,
                                                                3 => ErrorCode::DestinationUnavailable,
                                                                4 => ErrorCode::DestinationIpProhibited,
                                                                5 => ErrorCode::DestinationIpUnroutable,
                                                                6 => ErrorCode::ConnectionRefused,
                                                                7 => ErrorCode::ConnectionTerminated,
                                                                8 => ErrorCode::ConnectionTimeout,
                                                                9 => ErrorCode::ConnectionReadTimeout,
                                                                10 => ErrorCode::ConnectionWriteTimeout,
                                                                11 => ErrorCode::ConnectionLimitReached,
                                                                12 => ErrorCode::TlsProtocolError,
                                                                13 => ErrorCode::TlsCertificateError,
                                                                14 => {
                                                                    let e68 = {
                                                                        let l13 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        let l15 = i32::from(
                                                                            *ptr0
                                                                                .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>(),
                                                                        );
                                                                        TlsAlertReceivedPayload {
                                                                            alert_id: match l13 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l14 = i32::from(*ptr0.add(33).cast::<u8>());
                                                                                        l14 as u8
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                            alert_message: match l15 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l16 = *ptr0
                                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>();
                                                                                        let l17 = *ptr0
                                                                                            .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len18 = l17;
                                                                                        let bytes18 = _rt::Vec::from_raw_parts(
                                                                                            l16.cast(),
                                                                                            len18,
                                                                                            len18,
                                                                                        );
                                                                                        _rt::string_lift(bytes18)
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                        }
                                                                    };
                                                                    ErrorCode::TlsAlertReceived(e68)
                                                                }
                                                                15 => ErrorCode::HttpRequestDenied,
                                                                16 => ErrorCode::HttpRequestLengthRequired,
                                                                17 => {
                                                                    let e68 = {
                                                                        let l19 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l19 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l20 = *ptr0.add(40).cast::<i64>();
                                                                                    l20 as u64
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpRequestBodySize(e68)
                                                                }
                                                                18 => ErrorCode::HttpRequestMethodInvalid,
                                                                19 => ErrorCode::HttpRequestUriInvalid,
                                                                20 => ErrorCode::HttpRequestUriTooLong,
                                                                21 => {
                                                                    let e68 = {
                                                                        let l21 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l21 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l22 = *ptr0.add(36).cast::<i32>();
                                                                                    l22 as u32
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpRequestHeaderSectionSize(e68)
                                                                }
                                                                22 => {
                                                                    let e68 = {
                                                                        let l23 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l23 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l24 = i32::from(
                                                                                        *ptr0
                                                                                            .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>(),
                                                                                    );
                                                                                    let l28 = i32::from(
                                                                                        *ptr0
                                                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<u8>(),
                                                                                    );
                                                                                    FieldSizePayload {
                                                                                        field_name: match l24 {
                                                                                            0 => None,
                                                                                            1 => {
                                                                                                let e = {
                                                                                                    let l25 = *ptr0
                                                                                                        .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<*mut u8>();
                                                                                                    let l26 = *ptr0
                                                                                                        .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<usize>();
                                                                                                    let len27 = l26;
                                                                                                    let bytes27 = _rt::Vec::from_raw_parts(
                                                                                                        l25.cast(),
                                                                                                        len27,
                                                                                                        len27,
                                                                                                    );
                                                                                                    _rt::string_lift(bytes27)
                                                                                                };
                                                                                                Some(e)
                                                                                            }
                                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                                        },
                                                                                        field_size: match l28 {
                                                                                            0 => None,
                                                                                            1 => {
                                                                                                let e = {
                                                                                                    let l29 = *ptr0
                                                                                                        .add(36 + 4 * ::core::mem::size_of::<*const u8>())
                                                                                                        .cast::<i32>();
                                                                                                    l29 as u32
                                                                                                };
                                                                                                Some(e)
                                                                                            }
                                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                                        },
                                                                                    }
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpRequestHeaderSize(e68)
                                                                }
                                                                23 => {
                                                                    let e68 = {
                                                                        let l30 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l30 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l31 = *ptr0.add(36).cast::<i32>();
                                                                                    l31 as u32
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpRequestTrailerSectionSize(e68)
                                                                }
                                                                24 => {
                                                                    let e68 = {
                                                                        let l32 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        let l36 = i32::from(
                                                                            *ptr0
                                                                                .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>(),
                                                                        );
                                                                        FieldSizePayload {
                                                                            field_name: match l32 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l33 = *ptr0
                                                                                            .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>();
                                                                                        let l34 = *ptr0
                                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len35 = l34;
                                                                                        let bytes35 = _rt::Vec::from_raw_parts(
                                                                                            l33.cast(),
                                                                                            len35,
                                                                                            len35,
                                                                                        );
                                                                                        _rt::string_lift(bytes35)
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                            field_size: match l36 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l37 = *ptr0
                                                                                            .add(36 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i32>();
                                                                                        l37 as u32
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpRequestTrailerSize(e68)
                                                                }
                                                                25 => ErrorCode::HttpResponseIncomplete,
                                                                26 => {
                                                                    let e68 = {
                                                                        let l38 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l38 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l39 = *ptr0.add(36).cast::<i32>();
                                                                                    l39 as u32
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseHeaderSectionSize(e68)
                                                                }
                                                                27 => {
                                                                    let e68 = {
                                                                        let l40 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        let l44 = i32::from(
                                                                            *ptr0
                                                                                .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>(),
                                                                        );
                                                                        FieldSizePayload {
                                                                            field_name: match l40 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l41 = *ptr0
                                                                                            .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>();
                                                                                        let l42 = *ptr0
                                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len43 = l42;
                                                                                        let bytes43 = _rt::Vec::from_raw_parts(
                                                                                            l41.cast(),
                                                                                            len43,
                                                                                            len43,
                                                                                        );
                                                                                        _rt::string_lift(bytes43)
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                            field_size: match l44 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l45 = *ptr0
                                                                                            .add(36 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i32>();
                                                                                        l45 as u32
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseHeaderSize(e68)
                                                                }
                                                                28 => {
                                                                    let e68 = {
                                                                        let l46 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l46 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l47 = *ptr0.add(40).cast::<i64>();
                                                                                    l47 as u64
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseBodySize(e68)
                                                                }
                                                                29 => {
                                                                    let e68 = {
                                                                        let l48 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l48 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l49 = *ptr0.add(36).cast::<i32>();
                                                                                    l49 as u32
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseTrailerSectionSize(e68)
                                                                }
                                                                30 => {
                                                                    let e68 = {
                                                                        let l50 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        let l54 = i32::from(
                                                                            *ptr0
                                                                                .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                .cast::<u8>(),
                                                                        );
                                                                        FieldSizePayload {
                                                                            field_name: match l50 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l51 = *ptr0
                                                                                            .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<*mut u8>();
                                                                                        let l52 = *ptr0
                                                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<usize>();
                                                                                        let len53 = l52;
                                                                                        let bytes53 = _rt::Vec::from_raw_parts(
                                                                                            l51.cast(),
                                                                                            len53,
                                                                                            len53,
                                                                                        );
                                                                                        _rt::string_lift(bytes53)
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                            field_size: match l54 {
                                                                                0 => None,
                                                                                1 => {
                                                                                    let e = {
                                                                                        let l55 = *ptr0
                                                                                            .add(36 + 3 * ::core::mem::size_of::<*const u8>())
                                                                                            .cast::<i32>();
                                                                                        l55 as u32
                                                                                    };
                                                                                    Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                            },
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseTrailerSize(e68)
                                                                }
                                                                31 => {
                                                                    let e68 = {
                                                                        let l56 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l56 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l57 = *ptr0
                                                                                        .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<*mut u8>();
                                                                                    let l58 = *ptr0
                                                                                        .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let len59 = l58;
                                                                                    let bytes59 = _rt::Vec::from_raw_parts(
                                                                                        l57.cast(),
                                                                                        len59,
                                                                                        len59,
                                                                                    );
                                                                                    _rt::string_lift(bytes59)
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseTransferCoding(e68)
                                                                }
                                                                32 => {
                                                                    let e68 = {
                                                                        let l60 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l60 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l61 = *ptr0
                                                                                        .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<*mut u8>();
                                                                                    let l62 = *ptr0
                                                                                        .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let len63 = l62;
                                                                                    let bytes63 = _rt::Vec::from_raw_parts(
                                                                                        l61.cast(),
                                                                                        len63,
                                                                                        len63,
                                                                                    );
                                                                                    _rt::string_lift(bytes63)
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::HttpResponseContentCoding(e68)
                                                                }
                                                                33 => ErrorCode::HttpResponseTimeout,
                                                                34 => ErrorCode::HttpUpgradeFailed,
                                                                35 => ErrorCode::HttpProtocolError,
                                                                36 => ErrorCode::LoopDetected,
                                                                37 => ErrorCode::ConfigurationError,
                                                                n => {
                                                                    debug_assert_eq!(n, 38, "invalid enum discriminant");
                                                                    let e68 = {
                                                                        let l64 = i32::from(*ptr0.add(32).cast::<u8>());
                                                                        match l64 {
                                                                            0 => None,
                                                                            1 => {
                                                                                let e = {
                                                                                    let l65 = *ptr0
                                                                                        .add(32 + 1 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<*mut u8>();
                                                                                    let l66 = *ptr0
                                                                                        .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                                                        .cast::<usize>();
                                                                                    let len67 = l66;
                                                                                    let bytes67 = _rt::Vec::from_raw_parts(
                                                                                        l65.cast(),
                                                                                        len67,
                                                                                        len67,
                                                                                    );
                                                                                    _rt::string_lift(bytes67)
                                                                                };
                                                                                Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                        }
                                                                    };
                                                                    ErrorCode::InternalError(e68)
                                                                }
                                                            };
                                                            v68
                                                        };
                                                        Err(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                }
                                            };
                                            Ok(e)
                                        }
                                        1 => {
                                            let e = ();
                                            Err(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result69
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn http_error_code(err: &IoError) -> Option<ErrorCode> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 24 + 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 24
                            + 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:http/types@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "http-error-code"]
                        fn wit_import1(_: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1((err).handle() as i32, ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result66 = match l2 {
                        0 => None,
                        1 => {
                            let e = {
                                let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                                let v65 = match l3 {
                                    0 => ErrorCode::DnsTimeout,
                                    1 => {
                                        let e65 = {
                                            let l4 = i32::from(*ptr0.add(16).cast::<u8>());
                                            let l8 = i32::from(
                                                *ptr0
                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            DnsErrorPayload {
                                                rcode: match l4 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l5 = *ptr0
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l6 = *ptr0
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len7 = l6;
                                                            let bytes7 = _rt::Vec::from_raw_parts(
                                                                l5.cast(),
                                                                len7,
                                                                len7,
                                                            );
                                                            _rt::string_lift(bytes7)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                info_code: match l8 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l9 = i32::from(
                                                                *ptr0
                                                                    .add(18 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            l9 as u16
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        ErrorCode::DnsError(e65)
                                    }
                                    2 => ErrorCode::DestinationNotFound,
                                    3 => ErrorCode::DestinationUnavailable,
                                    4 => ErrorCode::DestinationIpProhibited,
                                    5 => ErrorCode::DestinationIpUnroutable,
                                    6 => ErrorCode::ConnectionRefused,
                                    7 => ErrorCode::ConnectionTerminated,
                                    8 => ErrorCode::ConnectionTimeout,
                                    9 => ErrorCode::ConnectionReadTimeout,
                                    10 => ErrorCode::ConnectionWriteTimeout,
                                    11 => ErrorCode::ConnectionLimitReached,
                                    12 => ErrorCode::TlsProtocolError,
                                    13 => ErrorCode::TlsCertificateError,
                                    14 => {
                                        let e65 = {
                                            let l10 = i32::from(*ptr0.add(16).cast::<u8>());
                                            let l12 = i32::from(
                                                *ptr0
                                                    .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            TlsAlertReceivedPayload {
                                                alert_id: match l10 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l11 = i32::from(*ptr0.add(17).cast::<u8>());
                                                            l11 as u8
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                alert_message: match l12 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l13 = *ptr0
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l14 = *ptr0
                                                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len15 = l14;
                                                            let bytes15 = _rt::Vec::from_raw_parts(
                                                                l13.cast(),
                                                                len15,
                                                                len15,
                                                            );
                                                            _rt::string_lift(bytes15)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        ErrorCode::TlsAlertReceived(e65)
                                    }
                                    15 => ErrorCode::HttpRequestDenied,
                                    16 => ErrorCode::HttpRequestLengthRequired,
                                    17 => {
                                        let e65 = {
                                            let l16 = i32::from(*ptr0.add(16).cast::<u8>());
                                            match l16 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l17 = *ptr0.add(24).cast::<i64>();
                                                        l17 as u64
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        ErrorCode::HttpRequestBodySize(e65)
                                    }
                                    18 => ErrorCode::HttpRequestMethodInvalid,
                                    19 => ErrorCode::HttpRequestUriInvalid,
                                    20 => ErrorCode::HttpRequestUriTooLong,
                                    21 => {
                                        let e65 = {
                                            let l18 = i32::from(*ptr0.add(16).cast::<u8>());
                                            match l18 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l19 = *ptr0.add(20).cast::<i32>();
                                                        l19 as u32
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        ErrorCode::HttpRequestHeaderSectionSize(e65)
                                    }
                                    22 => {
                                        let e65 = {
                                            let l20 = i32::from(*ptr0.add(16).cast::<u8>());
                                            match l20 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l21 = i32::from(
                                                            *ptr0
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        let l25 = i32::from(
                                                            *ptr0
                                                                .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        FieldSizePayload {
                                                            field_name: match l21 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l22 = *ptr0
                                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>();
                                                                        let l23 = *ptr0
                                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>();
                                                                        let len24 = l23;
                                                                        let bytes24 = _rt::Vec::from_raw_parts(
                                                                            l22.cast(),
                                                                            len24,
                                                                            len24,
                                                                        );
                                                                        _rt::string_lift(bytes24)
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            },
                                                            field_size: match l25 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l26 = *ptr0
                                                                            .add(20 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>();
                                                                        l26 as u32
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            },
                                                        }
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        ErrorCode::HttpRequestHeaderSize(e65)
                                    }
                                    23 => {
                                        let e65 = {
                                            let l27 = i32::from(*ptr0.add(16).cast::<u8>());
                                            match l27 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l28 = *ptr0.add(20).cast::<i32>();
                                                        l28 as u32
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        ErrorCode::HttpRequestTrailerSectionSize(e65)
                                    }
                                    24 => {
                                        let e65 = {
                                            let l29 = i32::from(*ptr0.add(16).cast::<u8>());
                                            let l33 = i32::from(
                                                *ptr0
                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            FieldSizePayload {
                                                field_name: match l29 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l30 = *ptr0
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l31 = *ptr0
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len32 = l31;
                                                            let bytes32 = _rt::Vec::from_raw_parts(
                                                                l30.cast(),
                                                                len32,
                                                                len32,
                                                            );
                                                            _rt::string_lift(bytes32)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                field_size: match l33 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l34 = *ptr0
                                                                .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<i32>();
                                                            l34 as u32
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        ErrorCode::HttpRequestTrailerSize(e65)
                                    }
                                    25 => ErrorCode::HttpResponseIncomplete,
                                    26 => {
                                        let e65 = {
                                            let l35 = i32::from(*ptr0.add(16).cast::<u8>());
                                            match l35 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l36 = *ptr0.add(20).cast::<i32>();
                                                        l36 as u32
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        ErrorCode::HttpResponseHeaderSectionSize(e65)
                                    }
                                    27 => {
                                        let e65 = {
                                            let l37 = i32::from(*ptr0.add(16).cast::<u8>());
                                            let l41 = i32::from(
                                                *ptr0
                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            FieldSizePayload {
                                                field_name: match l37 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l38 = *ptr0
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l39 = *ptr0
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len40 = l39;
                                                            let bytes40 = _rt::Vec::from_raw_parts(
                                                                l38.cast(),
                                                                len40,
                                                                len40,
                                                            );
                                                            _rt::string_lift(bytes40)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                field_size: match l41 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l42 = *ptr0
                                                                .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<i32>();
                                                            l42 as u32
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        ErrorCode::HttpResponseHeaderSize(e65)
                                    }
                                    28 => {
                                        let e65 = {
                                            let l43 = i32::from(*ptr0.add(16).cast::<u8>());
                                            match l43 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l44 = *ptr0.add(24).cast::<i64>();
                                                        l44 as u64
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        ErrorCode::HttpResponseBodySize(e65)
                                    }
                                    29 => {
                                        let e65 = {
                                            let l45 = i32::from(*ptr0.add(16).cast::<u8>());
                                            match l45 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l46 = *ptr0.add(20).cast::<i32>();
                                                        l46 as u32
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        ErrorCode::HttpResponseTrailerSectionSize(e65)
                                    }
                                    30 => {
                                        let e65 = {
                                            let l47 = i32::from(*ptr0.add(16).cast::<u8>());
                                            let l51 = i32::from(
                                                *ptr0
                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            FieldSizePayload {
                                                field_name: match l47 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l48 = *ptr0
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l49 = *ptr0
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len50 = l49;
                                                            let bytes50 = _rt::Vec::from_raw_parts(
                                                                l48.cast(),
                                                                len50,
                                                                len50,
                                                            );
                                                            _rt::string_lift(bytes50)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                field_size: match l51 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l52 = *ptr0
                                                                .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<i32>();
                                                            l52 as u32
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        ErrorCode::HttpResponseTrailerSize(e65)
                                    }
                                    31 => {
                                        let e65 = {
                                            let l53 = i32::from(*ptr0.add(16).cast::<u8>());
                                            match l53 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l54 = *ptr0
                                                            .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l55 = *ptr0
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len56 = l55;
                                                        let bytes56 = _rt::Vec::from_raw_parts(
                                                            l54.cast(),
                                                            len56,
                                                            len56,
                                                        );
                                                        _rt::string_lift(bytes56)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        ErrorCode::HttpResponseTransferCoding(e65)
                                    }
                                    32 => {
                                        let e65 = {
                                            let l57 = i32::from(*ptr0.add(16).cast::<u8>());
                                            match l57 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l58 = *ptr0
                                                            .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l59 = *ptr0
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len60 = l59;
                                                        let bytes60 = _rt::Vec::from_raw_parts(
                                                            l58.cast(),
                                                            len60,
                                                            len60,
                                                        );
                                                        _rt::string_lift(bytes60)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        ErrorCode::HttpResponseContentCoding(e65)
                                    }
                                    33 => ErrorCode::HttpResponseTimeout,
                                    34 => ErrorCode::HttpUpgradeFailed,
                                    35 => ErrorCode::HttpProtocolError,
                                    36 => ErrorCode::LoopDetected,
                                    37 => ErrorCode::ConfigurationError,
                                    n => {
                                        debug_assert_eq!(n, 38, "invalid enum discriminant");
                                        let e65 = {
                                            let l61 = i32::from(*ptr0.add(16).cast::<u8>());
                                            match l61 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l62 = *ptr0
                                                            .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l63 = *ptr0
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len64 = l63;
                                                        let bytes64 = _rt::Vec::from_raw_parts(
                                                            l62.cast(),
                                                            len64,
                                                            len64,
                                                        );
                                                        _rt::string_lift(bytes64)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        ErrorCode::InternalError(e65)
                                    }
                                };
                                v65
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result66
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod outgoing_handler {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type OutgoingRequest = super::super::super::wasi::http::types::OutgoingRequest;
            pub type RequestOptions = super::super::super::wasi::http::types::RequestOptions;
            pub type FutureIncomingResponse = super::super::super::wasi::http::types::FutureIncomingResponse;
            pub type ErrorCode = super::super::super::wasi::http::types::ErrorCode;
            #[allow(unused_unsafe, clippy::all)]
            pub fn handle(
                request: OutgoingRequest,
                options: Option<RequestOptions>,
            ) -> Result<FutureIncomingResponse, ErrorCode> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 24 + 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 24
                            + 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let (result0_0, result0_1) = match &options {
                        Some(e) => (1i32, (e).take_handle() as i32),
                        None => (0i32, 0i32),
                    };
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:http/outgoing-handler@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "handle"]
                        fn wit_import2(_: i32, _: i32, _: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(
                        _: i32,
                        _: i32,
                        _: i32,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import2(
                            (&request).take_handle() as i32,
                            result0_0,
                            result0_1,
                            ptr1,
                        )
                    };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result68 = match l3 {
                        0 => {
                            let e = {
                                let l4 = *ptr1.add(8).cast::<i32>();
                                unsafe {
                                    super::super::super::wasi::http::types::FutureIncomingResponse::from_handle(
                                        l4 as u32,
                                    )
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l5 = i32::from(*ptr1.add(8).cast::<u8>());
                                use super::super::super::wasi::http::types::ErrorCode as V67;
                                let v67 = match l5 {
                                    0 => V67::DnsTimeout,
                                    1 => {
                                        let e67 = {
                                            let l6 = i32::from(*ptr1.add(16).cast::<u8>());
                                            let l10 = i32::from(
                                                *ptr1
                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            super::super::super::wasi::http::types::DnsErrorPayload {
                                                rcode: match l6 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l7 = *ptr1
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l8 = *ptr1
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len9 = l8;
                                                            let bytes9 = _rt::Vec::from_raw_parts(
                                                                l7.cast(),
                                                                len9,
                                                                len9,
                                                            );
                                                            _rt::string_lift(bytes9)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                info_code: match l10 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l11 = i32::from(
                                                                *ptr1
                                                                    .add(18 + 3 * ::core::mem::size_of::<*const u8>())
                                                                    .cast::<u16>(),
                                                            );
                                                            l11 as u16
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        V67::DnsError(e67)
                                    }
                                    2 => V67::DestinationNotFound,
                                    3 => V67::DestinationUnavailable,
                                    4 => V67::DestinationIpProhibited,
                                    5 => V67::DestinationIpUnroutable,
                                    6 => V67::ConnectionRefused,
                                    7 => V67::ConnectionTerminated,
                                    8 => V67::ConnectionTimeout,
                                    9 => V67::ConnectionReadTimeout,
                                    10 => V67::ConnectionWriteTimeout,
                                    11 => V67::ConnectionLimitReached,
                                    12 => V67::TlsProtocolError,
                                    13 => V67::TlsCertificateError,
                                    14 => {
                                        let e67 = {
                                            let l12 = i32::from(*ptr1.add(16).cast::<u8>());
                                            let l14 = i32::from(
                                                *ptr1
                                                    .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            super::super::super::wasi::http::types::TlsAlertReceivedPayload {
                                                alert_id: match l12 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l13 = i32::from(*ptr1.add(17).cast::<u8>());
                                                            l13 as u8
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                alert_message: match l14 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l15 = *ptr1
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l16 = *ptr1
                                                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len17 = l16;
                                                            let bytes17 = _rt::Vec::from_raw_parts(
                                                                l15.cast(),
                                                                len17,
                                                                len17,
                                                            );
                                                            _rt::string_lift(bytes17)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        V67::TlsAlertReceived(e67)
                                    }
                                    15 => V67::HttpRequestDenied,
                                    16 => V67::HttpRequestLengthRequired,
                                    17 => {
                                        let e67 = {
                                            let l18 = i32::from(*ptr1.add(16).cast::<u8>());
                                            match l18 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l19 = *ptr1.add(24).cast::<i64>();
                                                        l19 as u64
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        V67::HttpRequestBodySize(e67)
                                    }
                                    18 => V67::HttpRequestMethodInvalid,
                                    19 => V67::HttpRequestUriInvalid,
                                    20 => V67::HttpRequestUriTooLong,
                                    21 => {
                                        let e67 = {
                                            let l20 = i32::from(*ptr1.add(16).cast::<u8>());
                                            match l20 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l21 = *ptr1.add(20).cast::<i32>();
                                                        l21 as u32
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        V67::HttpRequestHeaderSectionSize(e67)
                                    }
                                    22 => {
                                        let e67 = {
                                            let l22 = i32::from(*ptr1.add(16).cast::<u8>());
                                            match l22 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l23 = i32::from(
                                                            *ptr1
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        let l27 = i32::from(
                                                            *ptr1
                                                                .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        super::super::super::wasi::http::types::FieldSizePayload {
                                                            field_name: match l23 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l24 = *ptr1
                                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<*mut u8>();
                                                                        let l25 = *ptr1
                                                                            .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<usize>();
                                                                        let len26 = l25;
                                                                        let bytes26 = _rt::Vec::from_raw_parts(
                                                                            l24.cast(),
                                                                            len26,
                                                                            len26,
                                                                        );
                                                                        _rt::string_lift(bytes26)
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            },
                                                            field_size: match l27 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l28 = *ptr1
                                                                            .add(20 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<i32>();
                                                                        l28 as u32
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            },
                                                        }
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        V67::HttpRequestHeaderSize(e67)
                                    }
                                    23 => {
                                        let e67 = {
                                            let l29 = i32::from(*ptr1.add(16).cast::<u8>());
                                            match l29 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l30 = *ptr1.add(20).cast::<i32>();
                                                        l30 as u32
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        V67::HttpRequestTrailerSectionSize(e67)
                                    }
                                    24 => {
                                        let e67 = {
                                            let l31 = i32::from(*ptr1.add(16).cast::<u8>());
                                            let l35 = i32::from(
                                                *ptr1
                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            super::super::super::wasi::http::types::FieldSizePayload {
                                                field_name: match l31 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l32 = *ptr1
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l33 = *ptr1
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len34 = l33;
                                                            let bytes34 = _rt::Vec::from_raw_parts(
                                                                l32.cast(),
                                                                len34,
                                                                len34,
                                                            );
                                                            _rt::string_lift(bytes34)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                field_size: match l35 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l36 = *ptr1
                                                                .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<i32>();
                                                            l36 as u32
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        V67::HttpRequestTrailerSize(e67)
                                    }
                                    25 => V67::HttpResponseIncomplete,
                                    26 => {
                                        let e67 = {
                                            let l37 = i32::from(*ptr1.add(16).cast::<u8>());
                                            match l37 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l38 = *ptr1.add(20).cast::<i32>();
                                                        l38 as u32
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        V67::HttpResponseHeaderSectionSize(e67)
                                    }
                                    27 => {
                                        let e67 = {
                                            let l39 = i32::from(*ptr1.add(16).cast::<u8>());
                                            let l43 = i32::from(
                                                *ptr1
                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            super::super::super::wasi::http::types::FieldSizePayload {
                                                field_name: match l39 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l40 = *ptr1
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l41 = *ptr1
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len42 = l41;
                                                            let bytes42 = _rt::Vec::from_raw_parts(
                                                                l40.cast(),
                                                                len42,
                                                                len42,
                                                            );
                                                            _rt::string_lift(bytes42)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                field_size: match l43 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l44 = *ptr1
                                                                .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<i32>();
                                                            l44 as u32
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        V67::HttpResponseHeaderSize(e67)
                                    }
                                    28 => {
                                        let e67 = {
                                            let l45 = i32::from(*ptr1.add(16).cast::<u8>());
                                            match l45 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l46 = *ptr1.add(24).cast::<i64>();
                                                        l46 as u64
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        V67::HttpResponseBodySize(e67)
                                    }
                                    29 => {
                                        let e67 = {
                                            let l47 = i32::from(*ptr1.add(16).cast::<u8>());
                                            match l47 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l48 = *ptr1.add(20).cast::<i32>();
                                                        l48 as u32
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        V67::HttpResponseTrailerSectionSize(e67)
                                    }
                                    30 => {
                                        let e67 = {
                                            let l49 = i32::from(*ptr1.add(16).cast::<u8>());
                                            let l53 = i32::from(
                                                *ptr1
                                                    .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            super::super::super::wasi::http::types::FieldSizePayload {
                                                field_name: match l49 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l50 = *ptr1
                                                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l51 = *ptr1
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len52 = l51;
                                                            let bytes52 = _rt::Vec::from_raw_parts(
                                                                l50.cast(),
                                                                len52,
                                                                len52,
                                                            );
                                                            _rt::string_lift(bytes52)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                field_size: match l53 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l54 = *ptr1
                                                                .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<i32>();
                                                            l54 as u32
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        V67::HttpResponseTrailerSize(e67)
                                    }
                                    31 => {
                                        let e67 = {
                                            let l55 = i32::from(*ptr1.add(16).cast::<u8>());
                                            match l55 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l56 = *ptr1
                                                            .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l57 = *ptr1
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len58 = l57;
                                                        let bytes58 = _rt::Vec::from_raw_parts(
                                                            l56.cast(),
                                                            len58,
                                                            len58,
                                                        );
                                                        _rt::string_lift(bytes58)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        V67::HttpResponseTransferCoding(e67)
                                    }
                                    32 => {
                                        let e67 = {
                                            let l59 = i32::from(*ptr1.add(16).cast::<u8>());
                                            match l59 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l60 = *ptr1
                                                            .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l61 = *ptr1
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len62 = l61;
                                                        let bytes62 = _rt::Vec::from_raw_parts(
                                                            l60.cast(),
                                                            len62,
                                                            len62,
                                                        );
                                                        _rt::string_lift(bytes62)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        V67::HttpResponseContentCoding(e67)
                                    }
                                    33 => V67::HttpResponseTimeout,
                                    34 => V67::HttpUpgradeFailed,
                                    35 => V67::HttpProtocolError,
                                    36 => V67::LoopDetected,
                                    37 => V67::ConfigurationError,
                                    n => {
                                        debug_assert_eq!(n, 38, "invalid enum discriminant");
                                        let e67 = {
                                            let l63 = i32::from(*ptr1.add(16).cast::<u8>());
                                            match l63 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l64 = *ptr1
                                                            .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<*mut u8>();
                                                        let l65 = *ptr1
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<usize>();
                                                        let len66 = l65;
                                                        let bytes66 = _rt::Vec::from_raw_parts(
                                                            l64.cast(),
                                                            len66,
                                                            len66,
                                                        );
                                                        _rt::string_lift(bytes66)
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            }
                                        };
                                        V67::InternalError(e67)
                                    }
                                };
                                v67
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result68
                }
            }
        }
    }
    pub mod io {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod poll {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Pollable {
                handle: _rt::Resource<Pollable>,
            }
            impl Pollable {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Pollable {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]pollable"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl Pollable {
                #[allow(unused_unsafe, clippy::all)]
                pub fn ready(&self) -> bool {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]pollable.ready"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        _rt::bool_lift(ret as u8)
                    }
                }
            }
            impl Pollable {
                #[allow(unused_unsafe, clippy::all)]
                pub fn block(&self) -> () {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]pollable.block"]
                            fn wit_import0(_: i32);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) {
                            unreachable!()
                        }
                        unsafe { wit_import0((self).handle() as i32) };
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn poll(in_: &[&Pollable]) -> _rt::Vec<u32> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = in_;
                    let len0 = vec0.len();
                    let layout0 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec0.len() * 4,
                        4,
                    );
                    let result0 = if layout0.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout0).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout0);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec0.into_iter().enumerate() {
                        let base = result0.add(i * 4);
                        {
                            *base.add(0).cast::<i32>() = (e).handle() as i32;
                        }
                    }
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "poll"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(result0, len0, ptr1) };
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let result6 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    if layout0.size() != 0 {
                        _rt::alloc::dealloc(result0.cast(), layout0);
                    }
                    result6
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod error {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Error {
                handle: _rt::Resource<Error>,
            }
            impl Error {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Error {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:io/error@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]error"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl Error {
                #[allow(unused_unsafe, clippy::all)]
                pub fn to_debug_string(&self) -> _rt::String {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/error@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]error.to-debug-string"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                        let l3 = *ptr0
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len4 = l3;
                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                        let result5 = _rt::string_lift(bytes4);
                        result5
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod streams {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Error = super::super::super::wasi::io::error::Error;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            pub enum StreamError {
                LastOperationFailed(Error),
                Closed,
            }
            impl ::core::fmt::Debug for StreamError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        StreamError::LastOperationFailed(e) => {
                            f.debug_tuple("StreamError::LastOperationFailed")
                                .field(e)
                                .finish()
                        }
                        StreamError::Closed => {
                            f.debug_tuple("StreamError::Closed").finish()
                        }
                    }
                }
            }
            impl ::core::fmt::Display for StreamError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for StreamError {}
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct InputStream {
                handle: _rt::Resource<InputStream>,
            }
            impl InputStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for InputStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]input-stream"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct OutputStream {
                handle: _rt::Resource<OutputStream>,
            }
            impl OutputStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for OutputStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]output-stream"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl InputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn read(&self, len: u64) -> Result<_rt::Vec<u8>, StreamError> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]input-stream.read"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0)
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result9 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l6 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v8 = match l6 {
                                        0 => {
                                            let e8 = {
                                                let l7 = *ptr0
                                                    .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l7 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e8)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v8
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            impl InputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn blocking_read(
                    &self,
                    len: u64,
                ) -> Result<_rt::Vec<u8>, StreamError> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]input-stream.blocking-read"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0)
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result9 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len5 = l4;
                                    _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l6 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    let v8 = match l6 {
                                        0 => {
                                            let e8 = {
                                                let l7 = *ptr0
                                                    .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l7 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e8)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v8
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result9
                    }
                }
            }
            impl InputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn skip(&self, len: u64) -> Result<u64, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]input-stream.skip"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0)
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr0.add(12).cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl InputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn blocking_skip(&self, len: u64) -> Result<u64, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]input-stream.blocking-skip"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0)
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr0.add(12).cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl InputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]input-stream.subscribe"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe {
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn check_write(&self) -> Result<u64, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]output-stream.check-write"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr0.add(12).cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn write(&self, contents: &[u8]) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let vec0 = contents;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]output-stream.write"]
                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result7 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(4).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr1.add(8).cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn blocking_write_and_flush(
                    &self,
                    contents: &[u8],
                ) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let vec0 = contents;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]output-stream.blocking-write-and-flush"]
                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import2(
                                (self).handle() as i32,
                                ptr0.cast_mut(),
                                len0,
                                ptr1,
                            )
                        };
                        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                        let result7 = match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr1.add(4).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr1.add(8).cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn flush(&self) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]output-stream.flush"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v5 = match l3 {
                                        0 => {
                                            let e5 = {
                                                let l4 = *ptr0.add(8).cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l4 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e5)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v5
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn blocking_flush(&self) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]output-stream.blocking-flush"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v5 = match l3 {
                                        0 => {
                                            let e5 = {
                                                let l4 = *ptr0.add(8).cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l4 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e5)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v5
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]output-stream.subscribe"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe {
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn write_zeroes(&self, len: u64) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]output-stream.write-zeroes"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0)
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v5 = match l3 {
                                        0 => {
                                            let e5 = {
                                                let l4 = *ptr0.add(8).cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l4 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e5)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v5
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn blocking_write_zeroes_and_flush(
                    &self,
                    len: u64,
                ) -> Result<(), StreamError> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]output-stream.blocking-write-zeroes-and-flush"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1((self).handle() as i32, _rt::as_i64(&len), ptr0)
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    let v5 = match l3 {
                                        0 => {
                                            let e5 = {
                                                let l4 = *ptr0.add(8).cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l4 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e5)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v5
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn splice(
                    &self,
                    src: &InputStream,
                    len: u64,
                ) -> Result<u64, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]output-stream.splice"]
                            fn wit_import1(_: i32, _: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(
                            _: i32,
                            _: i32,
                            _: i64,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                (src).handle() as i32,
                                _rt::as_i64(&len),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr0.add(12).cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl OutputStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn blocking_splice(
                    &self,
                    src: &InputStream,
                    len: u64,
                ) -> Result<u64, StreamError> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]output-stream.blocking-splice"]
                            fn wit_import1(_: i32, _: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(
                            _: i32,
                            _: i32,
                            _: i64,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                (src).handle() as i32,
                                _rt::as_i64(&len),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    let v6 = match l4 {
                                        0 => {
                                            let e6 = {
                                                let l5 = *ptr0.add(12).cast::<i32>();
                                                unsafe {
                                                    super::super::super::wasi::io::error::Error::from_handle(
                                                        l5 as u32,
                                                    )
                                                }
                                            };
                                            StreamError::LastOperationFailed(e6)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            StreamError::Closed
                                        }
                                    };
                                    v6
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
        }
    }
    pub mod random {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod random {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_random_bytes(len: u64) -> _rt::Vec<u8> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:random/random@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-random-bytes"]
                        fn wit_import1(_: i64, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i64, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(_rt::as_i64(&len), ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len4 = l3;
                    let result5 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_random_u64() -> u64 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:random/random@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-random-u64"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    ret as u64
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod insecure {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_insecure_random_bytes(len: u64) -> _rt::Vec<u8> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:random/insecure@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-insecure-random-bytes"]
                        fn wit_import1(_: i64, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i64, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(_rt::as_i64(&len), ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len4 = l3;
                    let result5 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    result5
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_insecure_random_u64() -> u64 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:random/insecure@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "get-insecure-random-u64"]
                        fn wit_import0() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i64 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    ret as u64
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod insecure_seed {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            #[allow(unused_unsafe, clippy::all)]
            pub fn insecure_seed() -> (u64, u64) {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:random/insecure-seed@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "insecure-seed"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<i64>();
                    let l3 = *ptr0.add(8).cast::<i64>();
                    let result4 = (l2 as u64, l3 as u64);
                    result4
                }
            }
        }
    }
    pub mod sockets {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod network {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Network {
                handle: _rt::Resource<Network>,
            }
            impl Network {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Network {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:sockets/network@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]network"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum ErrorCode {
                Unknown,
                AccessDenied,
                NotSupported,
                InvalidArgument,
                OutOfMemory,
                Timeout,
                ConcurrencyConflict,
                NotInProgress,
                WouldBlock,
                InvalidState,
                NewSocketLimit,
                AddressNotBindable,
                AddressInUse,
                RemoteUnreachable,
                ConnectionRefused,
                ConnectionReset,
                ConnectionAborted,
                DatagramTooLarge,
                NameUnresolvable,
                TemporaryResolverFailure,
                PermanentResolverFailure,
            }
            impl ErrorCode {
                pub fn name(&self) -> &'static str {
                    match self {
                        ErrorCode::Unknown => "unknown",
                        ErrorCode::AccessDenied => "access-denied",
                        ErrorCode::NotSupported => "not-supported",
                        ErrorCode::InvalidArgument => "invalid-argument",
                        ErrorCode::OutOfMemory => "out-of-memory",
                        ErrorCode::Timeout => "timeout",
                        ErrorCode::ConcurrencyConflict => "concurrency-conflict",
                        ErrorCode::NotInProgress => "not-in-progress",
                        ErrorCode::WouldBlock => "would-block",
                        ErrorCode::InvalidState => "invalid-state",
                        ErrorCode::NewSocketLimit => "new-socket-limit",
                        ErrorCode::AddressNotBindable => "address-not-bindable",
                        ErrorCode::AddressInUse => "address-in-use",
                        ErrorCode::RemoteUnreachable => "remote-unreachable",
                        ErrorCode::ConnectionRefused => "connection-refused",
                        ErrorCode::ConnectionReset => "connection-reset",
                        ErrorCode::ConnectionAborted => "connection-aborted",
                        ErrorCode::DatagramTooLarge => "datagram-too-large",
                        ErrorCode::NameUnresolvable => "name-unresolvable",
                        ErrorCode::TemporaryResolverFailure => {
                            "temporary-resolver-failure"
                        }
                        ErrorCode::PermanentResolverFailure => {
                            "permanent-resolver-failure"
                        }
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        ErrorCode::Unknown => "",
                        ErrorCode::AccessDenied => "",
                        ErrorCode::NotSupported => "",
                        ErrorCode::InvalidArgument => "",
                        ErrorCode::OutOfMemory => "",
                        ErrorCode::Timeout => "",
                        ErrorCode::ConcurrencyConflict => "",
                        ErrorCode::NotInProgress => "",
                        ErrorCode::WouldBlock => "",
                        ErrorCode::InvalidState => "",
                        ErrorCode::NewSocketLimit => "",
                        ErrorCode::AddressNotBindable => "",
                        ErrorCode::AddressInUse => "",
                        ErrorCode::RemoteUnreachable => "",
                        ErrorCode::ConnectionRefused => "",
                        ErrorCode::ConnectionReset => "",
                        ErrorCode::ConnectionAborted => "",
                        ErrorCode::DatagramTooLarge => "",
                        ErrorCode::NameUnresolvable => "",
                        ErrorCode::TemporaryResolverFailure => "",
                        ErrorCode::PermanentResolverFailure => "",
                    }
                }
            }
            impl ::core::fmt::Debug for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ErrorCode")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{} (error {})", self.name(), * self as i32)
                }
            }
            impl std::error::Error for ErrorCode {}
            impl ErrorCode {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ErrorCode {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => ErrorCode::Unknown,
                        1 => ErrorCode::AccessDenied,
                        2 => ErrorCode::NotSupported,
                        3 => ErrorCode::InvalidArgument,
                        4 => ErrorCode::OutOfMemory,
                        5 => ErrorCode::Timeout,
                        6 => ErrorCode::ConcurrencyConflict,
                        7 => ErrorCode::NotInProgress,
                        8 => ErrorCode::WouldBlock,
                        9 => ErrorCode::InvalidState,
                        10 => ErrorCode::NewSocketLimit,
                        11 => ErrorCode::AddressNotBindable,
                        12 => ErrorCode::AddressInUse,
                        13 => ErrorCode::RemoteUnreachable,
                        14 => ErrorCode::ConnectionRefused,
                        15 => ErrorCode::ConnectionReset,
                        16 => ErrorCode::ConnectionAborted,
                        17 => ErrorCode::DatagramTooLarge,
                        18 => ErrorCode::NameUnresolvable,
                        19 => ErrorCode::TemporaryResolverFailure,
                        20 => ErrorCode::PermanentResolverFailure,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum IpAddressFamily {
                Ipv4,
                Ipv6,
            }
            impl ::core::fmt::Debug for IpAddressFamily {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        IpAddressFamily::Ipv4 => {
                            f.debug_tuple("IpAddressFamily::Ipv4").finish()
                        }
                        IpAddressFamily::Ipv6 => {
                            f.debug_tuple("IpAddressFamily::Ipv6").finish()
                        }
                    }
                }
            }
            impl IpAddressFamily {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> IpAddressFamily {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => IpAddressFamily::Ipv4,
                        1 => IpAddressFamily::Ipv6,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            pub type Ipv4Address = (u8, u8, u8, u8);
            pub type Ipv6Address = (u16, u16, u16, u16, u16, u16, u16, u16);
            #[derive(Clone, Copy)]
            pub enum IpAddress {
                Ipv4(Ipv4Address),
                Ipv6(Ipv6Address),
            }
            impl ::core::fmt::Debug for IpAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        IpAddress::Ipv4(e) => {
                            f.debug_tuple("IpAddress::Ipv4").field(e).finish()
                        }
                        IpAddress::Ipv6(e) => {
                            f.debug_tuple("IpAddress::Ipv6").field(e).finish()
                        }
                    }
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Ipv4SocketAddress {
                pub port: u16,
                pub address: Ipv4Address,
            }
            impl ::core::fmt::Debug for Ipv4SocketAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Ipv4SocketAddress")
                        .field("port", &self.port)
                        .field("address", &self.address)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Ipv6SocketAddress {
                pub port: u16,
                pub flow_info: u32,
                pub address: Ipv6Address,
                pub scope_id: u32,
            }
            impl ::core::fmt::Debug for Ipv6SocketAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Ipv6SocketAddress")
                        .field("port", &self.port)
                        .field("flow-info", &self.flow_info)
                        .field("address", &self.address)
                        .field("scope-id", &self.scope_id)
                        .finish()
                }
            }
            #[derive(Clone, Copy)]
            pub enum IpSocketAddress {
                Ipv4(Ipv4SocketAddress),
                Ipv6(Ipv6SocketAddress),
            }
            impl ::core::fmt::Debug for IpSocketAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        IpSocketAddress::Ipv4(e) => {
                            f.debug_tuple("IpSocketAddress::Ipv4").field(e).finish()
                        }
                        IpSocketAddress::Ipv6(e) => {
                            f.debug_tuple("IpSocketAddress::Ipv6").field(e).finish()
                        }
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod instance_network {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            pub type Network = super::super::super::wasi::sockets::network::Network;
            #[allow(unused_unsafe, clippy::all)]
            pub fn instance_network() -> Network {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:sockets/instance-network@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "instance-network"]
                        fn wit_import0() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0() -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe { wit_import0() };
                    unsafe {
                        super::super::super::wasi::sockets::network::Network::from_handle(
                            ret as u32,
                        )
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod udp {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            pub type Network = super::super::super::wasi::sockets::network::Network;
            pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
            pub type IpSocketAddress = super::super::super::wasi::sockets::network::IpSocketAddress;
            pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
            #[derive(Clone)]
            pub struct IncomingDatagram {
                pub data: _rt::Vec<u8>,
                pub remote_address: IpSocketAddress,
            }
            impl ::core::fmt::Debug for IncomingDatagram {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("IncomingDatagram")
                        .field("data", &self.data)
                        .field("remote-address", &self.remote_address)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct OutgoingDatagram {
                pub data: _rt::Vec<u8>,
                pub remote_address: Option<IpSocketAddress>,
            }
            impl ::core::fmt::Debug for OutgoingDatagram {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("OutgoingDatagram")
                        .field("data", &self.data)
                        .field("remote-address", &self.remote_address)
                        .finish()
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct UdpSocket {
                handle: _rt::Resource<UdpSocket>,
            }
            impl UdpSocket {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for UdpSocket {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]udp-socket"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct IncomingDatagramStream {
                handle: _rt::Resource<IncomingDatagramStream>,
            }
            impl IncomingDatagramStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for IncomingDatagramStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]incoming-datagram-stream"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct OutgoingDatagramStream {
                handle: _rt::Resource<OutgoingDatagramStream>,
            }
            impl OutgoingDatagramStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for OutgoingDatagramStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]outgoing-datagram-stream"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn start_bind(
                    &self,
                    network: &Network,
                    local_address: IpSocketAddress,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        use super::super::super::wasi::sockets::network::IpSocketAddress as V4;
                        let (
                            result5_0,
                            result5_1,
                            result5_2,
                            result5_3,
                            result5_4,
                            result5_5,
                            result5_6,
                            result5_7,
                            result5_8,
                            result5_9,
                            result5_10,
                            result5_11,
                        ) = match local_address {
                            V4::Ipv4(e) => {
                                let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                    port: port0,
                                    address: address0,
                                } = e;
                                let (t1_0, t1_1, t1_2, t1_3) = address0;
                                (
                                    0i32,
                                    _rt::as_i32(port0),
                                    _rt::as_i32(t1_0),
                                    _rt::as_i32(t1_1),
                                    _rt::as_i32(t1_2),
                                    _rt::as_i32(t1_3),
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                )
                            }
                            V4::Ipv6(e) => {
                                let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                    port: port2,
                                    flow_info: flow_info2,
                                    address: address2,
                                    scope_id: scope_id2,
                                } = e;
                                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                (
                                    1i32,
                                    _rt::as_i32(port2),
                                    _rt::as_i32(flow_info2),
                                    _rt::as_i32(t3_0),
                                    _rt::as_i32(t3_1),
                                    _rt::as_i32(t3_2),
                                    _rt::as_i32(t3_3),
                                    _rt::as_i32(t3_4),
                                    _rt::as_i32(t3_5),
                                    _rt::as_i32(t3_6),
                                    _rt::as_i32(t3_7),
                                    _rt::as_i32(scope_id2),
                                )
                            }
                        };
                        let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.start-bind"]
                            fn wit_import7(
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import7(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import7(
                                (self).handle() as i32,
                                (network).handle() as i32,
                                result5_0,
                                result5_1,
                                result5_2,
                                result5_3,
                                result5_4,
                                result5_5,
                                result5_6,
                                result5_7,
                                result5_8,
                                result5_9,
                                result5_10,
                                result5_11,
                                ptr6,
                            )
                        };
                        let l8 = i32::from(*ptr6.add(0).cast::<u8>());
                        let result10 = match l8 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l9 = i32::from(*ptr6.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l9 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn finish_bind(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.finish-bind"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn stream(
                    &self,
                    remote_address: Option<IpSocketAddress>,
                ) -> Result<
                    (IncomingDatagramStream, OutgoingDatagramStream),
                    ErrorCode,
                > {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let (
                            result6_0,
                            result6_1,
                            result6_2,
                            result6_3,
                            result6_4,
                            result6_5,
                            result6_6,
                            result6_7,
                            result6_8,
                            result6_9,
                            result6_10,
                            result6_11,
                            result6_12,
                        ) = match remote_address {
                            Some(e) => {
                                use super::super::super::wasi::sockets::network::IpSocketAddress as V4;
                                let (
                                    result5_0,
                                    result5_1,
                                    result5_2,
                                    result5_3,
                                    result5_4,
                                    result5_5,
                                    result5_6,
                                    result5_7,
                                    result5_8,
                                    result5_9,
                                    result5_10,
                                    result5_11,
                                ) = match e {
                                    V4::Ipv4(e) => {
                                        let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                            port: port0,
                                            address: address0,
                                        } = e;
                                        let (t1_0, t1_1, t1_2, t1_3) = address0;
                                        (
                                            0i32,
                                            _rt::as_i32(port0),
                                            _rt::as_i32(t1_0),
                                            _rt::as_i32(t1_1),
                                            _rt::as_i32(t1_2),
                                            _rt::as_i32(t1_3),
                                            0i32,
                                            0i32,
                                            0i32,
                                            0i32,
                                            0i32,
                                            0i32,
                                        )
                                    }
                                    V4::Ipv6(e) => {
                                        let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                            port: port2,
                                            flow_info: flow_info2,
                                            address: address2,
                                            scope_id: scope_id2,
                                        } = e;
                                        let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                        (
                                            1i32,
                                            _rt::as_i32(port2),
                                            _rt::as_i32(flow_info2),
                                            _rt::as_i32(t3_0),
                                            _rt::as_i32(t3_1),
                                            _rt::as_i32(t3_2),
                                            _rt::as_i32(t3_3),
                                            _rt::as_i32(t3_4),
                                            _rt::as_i32(t3_5),
                                            _rt::as_i32(t3_6),
                                            _rt::as_i32(t3_7),
                                            _rt::as_i32(scope_id2),
                                        )
                                    }
                                };
                                (
                                    1i32,
                                    result5_0,
                                    result5_1,
                                    result5_2,
                                    result5_3,
                                    result5_4,
                                    result5_5,
                                    result5_6,
                                    result5_7,
                                    result5_8,
                                    result5_9,
                                    result5_10,
                                    result5_11,
                                )
                            }
                            None => {
                                (
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                )
                            }
                        };
                        let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.stream"]
                            fn wit_import8(
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import8(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import8(
                                (self).handle() as i32,
                                result6_0,
                                result6_1,
                                result6_2,
                                result6_3,
                                result6_4,
                                result6_5,
                                result6_6,
                                result6_7,
                                result6_8,
                                result6_9,
                                result6_10,
                                result6_11,
                                result6_12,
                                ptr7,
                            )
                        };
                        let l9 = i32::from(*ptr7.add(0).cast::<u8>());
                        let result13 = match l9 {
                            0 => {
                                let e = {
                                    let l10 = *ptr7.add(4).cast::<i32>();
                                    let l11 = *ptr7.add(8).cast::<i32>();
                                    (
                                        unsafe { IncomingDatagramStream::from_handle(l10 as u32) },
                                        unsafe { OutgoingDatagramStream::from_handle(l11 as u32) },
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l12 = i32::from(*ptr7.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l12 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result13
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn local_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.local-address"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    use super::super::super::wasi::sockets::network::IpSocketAddress as V20;
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            V20::Ipv4(e20)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            V20::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l21 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn remote_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.remote-address"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    use super::super::super::wasi::sockets::network::IpSocketAddress as V20;
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            V20::Ipv4(e20)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            V20::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l21 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn address_family(&self) -> IpAddressFamily {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.address-family"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        super::super::super::wasi::sockets::network::IpAddressFamily::_lift(
                            ret as u8,
                        )
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn unicast_hop_limit(&self) -> Result<u8, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.unicast-hop-limit"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    l3 as u8
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_unicast_hop_limit(&self, value: u8) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.set-unicast-hop-limit"]
                            fn wit_import1(_: i32, _: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i32(&value),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn receive_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.receive-buffer-size"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_receive_buffer_size(
                    &self,
                    value: u64,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.set-receive-buffer-size"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i64(&value),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn send_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.send-buffer-size"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_send_buffer_size(&self, value: u64) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.set-send-buffer-size"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i64(&value),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl UdpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]udp-socket.subscribe"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe {
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
            }
            impl IncomingDatagramStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn receive(
                    &self,
                    max_results: u64,
                ) -> Result<_rt::Vec<IncomingDatagram>, ErrorCode> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-datagram-stream.receive"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i64(&max_results),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result28 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr0
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base26 = l3;
                                    let len26 = l4;
                                    let mut result26 = _rt::Vec::with_capacity(len26);
                                    for i in 0..len26 {
                                        let base = base26
                                            .add(i * (32 + 2 * ::core::mem::size_of::<*const u8>()));
                                        let e26 = {
                                            let l5 = *base.add(0).cast::<*mut u8>();
                                            let l6 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len7 = l6;
                                            let l8 = i32::from(
                                                *base
                                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            use super::super::super::wasi::sockets::network::IpSocketAddress as V25;
                                            let v25 = match l8 {
                                                0 => {
                                                    let e25 = {
                                                        let l9 = i32::from(
                                                            *base
                                                                .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l10 = i32::from(
                                                            *base
                                                                .add(6 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        let l11 = i32::from(
                                                            *base
                                                                .add(7 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        let l12 = i32::from(
                                                            *base
                                                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        let l13 = i32::from(
                                                            *base
                                                                .add(9 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u8>(),
                                                        );
                                                        super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                            port: l9 as u16,
                                                            address: (l10 as u8, l11 as u8, l12 as u8, l13 as u8),
                                                        }
                                                    };
                                                    V25::Ipv4(e25)
                                                }
                                                n => {
                                                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                                                    let e25 = {
                                                        let l14 = i32::from(
                                                            *base
                                                                .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l15 = *base
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>();
                                                        let l16 = i32::from(
                                                            *base
                                                                .add(12 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l17 = i32::from(
                                                            *base
                                                                .add(14 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l18 = i32::from(
                                                            *base
                                                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l19 = i32::from(
                                                            *base
                                                                .add(18 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l20 = i32::from(
                                                            *base
                                                                .add(20 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l21 = i32::from(
                                                            *base
                                                                .add(22 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l22 = i32::from(
                                                            *base
                                                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l23 = i32::from(
                                                            *base
                                                                .add(26 + 2 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<u16>(),
                                                        );
                                                        let l24 = *base
                                                            .add(28 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<i32>();
                                                        super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                            port: l14 as u16,
                                                            flow_info: l15 as u32,
                                                            address: (
                                                                l16 as u16,
                                                                l17 as u16,
                                                                l18 as u16,
                                                                l19 as u16,
                                                                l20 as u16,
                                                                l21 as u16,
                                                                l22 as u16,
                                                                l23 as u16,
                                                            ),
                                                            scope_id: l24 as u32,
                                                        }
                                                    };
                                                    V25::Ipv6(e25)
                                                }
                                            };
                                            IncomingDatagram {
                                                data: _rt::Vec::from_raw_parts(l5.cast(), len7, len7),
                                                remote_address: v25,
                                            }
                                        };
                                        result26.push(e26);
                                    }
                                    _rt::cabi_dealloc(
                                        base26,
                                        len26 * (32 + 2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    result26
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l27 = i32::from(
                                        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l27 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result28
                    }
                }
            }
            impl IncomingDatagramStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]incoming-datagram-stream.subscribe"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe {
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
            }
            impl OutgoingDatagramStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn check_send(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-datagram-stream.check-send"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl OutgoingDatagramStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn send(
                    &self,
                    datagrams: &[OutgoingDatagram],
                ) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let vec7 = datagrams;
                        let len7 = vec7.len();
                        let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
                            vec7.len() * (32 + 3 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result7 = if layout7.size() != 0 {
                            let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                            if ptr.is_null() {
                                _rt::alloc::handle_alloc_error(layout7);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec7.into_iter().enumerate() {
                            let base = result7
                                .add(i * (32 + 3 * ::core::mem::size_of::<*const u8>()));
                            {
                                let OutgoingDatagram {
                                    data: data0,
                                    remote_address: remote_address0,
                                } = e;
                                let vec1 = data0;
                                let ptr1 = vec1.as_ptr().cast::<u8>();
                                let len1 = vec1.len();
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len1;
                                *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                                match remote_address0 {
                                    Some(e) => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (1i32) as u8;
                                        use super::super::super::wasi::sockets::network::IpSocketAddress as V6;
                                        match e {
                                            V6::Ipv4(e) => {
                                                *base
                                                    .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (0i32) as u8;
                                                let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                    port: port2,
                                                    address: address2,
                                                } = e;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(port2)) as u16;
                                                let (t3_0, t3_1, t3_2, t3_3) = address2;
                                                *base
                                                    .add(10 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (_rt::as_i32(t3_0)) as u8;
                                                *base
                                                    .add(11 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (_rt::as_i32(t3_1)) as u8;
                                                *base
                                                    .add(12 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (_rt::as_i32(t3_2)) as u8;
                                                *base
                                                    .add(13 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (_rt::as_i32(t3_3)) as u8;
                                            }
                                            V6::Ipv6(e) => {
                                                *base
                                                    .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>() = (1i32) as u8;
                                                let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                    port: port4,
                                                    flow_info: flow_info4,
                                                    address: address4,
                                                    scope_id: scope_id4,
                                                } = e;
                                                *base
                                                    .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(port4)) as u16;
                                                *base
                                                    .add(12 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>() = _rt::as_i32(flow_info4);
                                                let (t5_0, t5_1, t5_2, t5_3, t5_4, t5_5, t5_6, t5_7) = address4;
                                                *base
                                                    .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_0)) as u16;
                                                *base
                                                    .add(18 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_1)) as u16;
                                                *base
                                                    .add(20 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_2)) as u16;
                                                *base
                                                    .add(22 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_3)) as u16;
                                                *base
                                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_4)) as u16;
                                                *base
                                                    .add(26 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_5)) as u16;
                                                *base
                                                    .add(28 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_6)) as u16;
                                                *base
                                                    .add(30 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u16>() = (_rt::as_i32(t5_7)) as u16;
                                                *base
                                                    .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<i32>() = _rt::as_i32(scope_id4);
                                            }
                                        }
                                    }
                                    None => {
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>() = (0i32) as u8;
                                    }
                                };
                            }
                        }
                        let ptr8 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-datagram-stream.send"]
                            fn wit_import9(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import9(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import9((self).handle() as i32, result7, len7, ptr8)
                        };
                        let l10 = i32::from(*ptr8.add(0).cast::<u8>());
                        let result13 = match l10 {
                            0 => {
                                let e = {
                                    let l11 = *ptr8.add(8).cast::<i64>();
                                    l11 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l12 = i32::from(*ptr8.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l12 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        if layout7.size() != 0 {
                            _rt::alloc::dealloc(result7.cast(), layout7);
                        }
                        result13
                    }
                }
            }
            impl OutgoingDatagramStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/udp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]outgoing-datagram-stream.subscribe"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe {
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod udp_create_socket {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
            pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
            pub type UdpSocket = super::super::super::wasi::sockets::udp::UdpSocket;
            #[allow(unused_unsafe, clippy::all)]
            pub fn create_udp_socket(
                address_family: IpAddressFamily,
            ) -> Result<UdpSocket, ErrorCode> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:sockets/udp-create-socket@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "create-udp-socket"]
                        fn wit_import1(_: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(address_family.clone() as i32, ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result5 = match l2 {
                        0 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                unsafe {
                                    super::super::super::wasi::sockets::udp::UdpSocket::from_handle(
                                        l3 as u32,
                                    )
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                    l4 as u8,
                                )
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result5
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod tcp {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type InputStream = super::super::super::wasi::io::streams::InputStream;
            pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            pub type Duration = super::super::super::wasi::clocks::monotonic_clock::Duration;
            pub type Network = super::super::super::wasi::sockets::network::Network;
            pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
            pub type IpSocketAddress = super::super::super::wasi::sockets::network::IpSocketAddress;
            pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum ShutdownType {
                Receive,
                Send,
                Both,
            }
            impl ::core::fmt::Debug for ShutdownType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ShutdownType::Receive => {
                            f.debug_tuple("ShutdownType::Receive").finish()
                        }
                        ShutdownType::Send => {
                            f.debug_tuple("ShutdownType::Send").finish()
                        }
                        ShutdownType::Both => {
                            f.debug_tuple("ShutdownType::Both").finish()
                        }
                    }
                }
            }
            impl ShutdownType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ShutdownType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => ShutdownType::Receive,
                        1 => ShutdownType::Send,
                        2 => ShutdownType::Both,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct TcpSocket {
                handle: _rt::Resource<TcpSocket>,
            }
            impl TcpSocket {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for TcpSocket {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]tcp-socket"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn start_bind(
                    &self,
                    network: &Network,
                    local_address: IpSocketAddress,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        use super::super::super::wasi::sockets::network::IpSocketAddress as V4;
                        let (
                            result5_0,
                            result5_1,
                            result5_2,
                            result5_3,
                            result5_4,
                            result5_5,
                            result5_6,
                            result5_7,
                            result5_8,
                            result5_9,
                            result5_10,
                            result5_11,
                        ) = match local_address {
                            V4::Ipv4(e) => {
                                let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                    port: port0,
                                    address: address0,
                                } = e;
                                let (t1_0, t1_1, t1_2, t1_3) = address0;
                                (
                                    0i32,
                                    _rt::as_i32(port0),
                                    _rt::as_i32(t1_0),
                                    _rt::as_i32(t1_1),
                                    _rt::as_i32(t1_2),
                                    _rt::as_i32(t1_3),
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                )
                            }
                            V4::Ipv6(e) => {
                                let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                    port: port2,
                                    flow_info: flow_info2,
                                    address: address2,
                                    scope_id: scope_id2,
                                } = e;
                                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                (
                                    1i32,
                                    _rt::as_i32(port2),
                                    _rt::as_i32(flow_info2),
                                    _rt::as_i32(t3_0),
                                    _rt::as_i32(t3_1),
                                    _rt::as_i32(t3_2),
                                    _rt::as_i32(t3_3),
                                    _rt::as_i32(t3_4),
                                    _rt::as_i32(t3_5),
                                    _rt::as_i32(t3_6),
                                    _rt::as_i32(t3_7),
                                    _rt::as_i32(scope_id2),
                                )
                            }
                        };
                        let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.start-bind"]
                            fn wit_import7(
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import7(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import7(
                                (self).handle() as i32,
                                (network).handle() as i32,
                                result5_0,
                                result5_1,
                                result5_2,
                                result5_3,
                                result5_4,
                                result5_5,
                                result5_6,
                                result5_7,
                                result5_8,
                                result5_9,
                                result5_10,
                                result5_11,
                                ptr6,
                            )
                        };
                        let l8 = i32::from(*ptr6.add(0).cast::<u8>());
                        let result10 = match l8 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l9 = i32::from(*ptr6.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l9 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn finish_bind(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.finish-bind"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn start_connect(
                    &self,
                    network: &Network,
                    remote_address: IpSocketAddress,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        use super::super::super::wasi::sockets::network::IpSocketAddress as V4;
                        let (
                            result5_0,
                            result5_1,
                            result5_2,
                            result5_3,
                            result5_4,
                            result5_5,
                            result5_6,
                            result5_7,
                            result5_8,
                            result5_9,
                            result5_10,
                            result5_11,
                        ) = match remote_address {
                            V4::Ipv4(e) => {
                                let super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                    port: port0,
                                    address: address0,
                                } = e;
                                let (t1_0, t1_1, t1_2, t1_3) = address0;
                                (
                                    0i32,
                                    _rt::as_i32(port0),
                                    _rt::as_i32(t1_0),
                                    _rt::as_i32(t1_1),
                                    _rt::as_i32(t1_2),
                                    _rt::as_i32(t1_3),
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                    0i32,
                                )
                            }
                            V4::Ipv6(e) => {
                                let super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                    port: port2,
                                    flow_info: flow_info2,
                                    address: address2,
                                    scope_id: scope_id2,
                                } = e;
                                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7) = address2;
                                (
                                    1i32,
                                    _rt::as_i32(port2),
                                    _rt::as_i32(flow_info2),
                                    _rt::as_i32(t3_0),
                                    _rt::as_i32(t3_1),
                                    _rt::as_i32(t3_2),
                                    _rt::as_i32(t3_3),
                                    _rt::as_i32(t3_4),
                                    _rt::as_i32(t3_5),
                                    _rt::as_i32(t3_6),
                                    _rt::as_i32(t3_7),
                                    _rt::as_i32(scope_id2),
                                )
                            }
                        };
                        let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.start-connect"]
                            fn wit_import7(
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import7(
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import7(
                                (self).handle() as i32,
                                (network).handle() as i32,
                                result5_0,
                                result5_1,
                                result5_2,
                                result5_3,
                                result5_4,
                                result5_5,
                                result5_6,
                                result5_7,
                                result5_8,
                                result5_9,
                                result5_10,
                                result5_11,
                                ptr6,
                            )
                        };
                        let l8 = i32::from(*ptr6.add(0).cast::<u8>());
                        let result10 = match l8 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l9 = i32::from(*ptr6.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l9 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result10
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn finish_connect(
                    &self,
                ) -> Result<(InputStream, OutputStream), ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 12],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.finish-connect"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result6 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    let l4 = *ptr0.add(8).cast::<i32>();
                                    (
                                        unsafe {
                                            super::super::super::wasi::io::streams::InputStream::from_handle(
                                                l3 as u32,
                                            )
                                        },
                                        unsafe {
                                            super::super::super::wasi::io::streams::OutputStream::from_handle(
                                                l4 as u32,
                                            )
                                        },
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l5 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result6
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn start_listen(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.start-listen"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn finish_listen(&self) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.finish-listen"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn accept(
                    &self,
                ) -> Result<(TcpSocket, InputStream, OutputStream), ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.accept"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result7 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    let l4 = *ptr0.add(8).cast::<i32>();
                                    let l5 = *ptr0.add(12).cast::<i32>();
                                    (
                                        unsafe { TcpSocket::from_handle(l3 as u32) },
                                        unsafe {
                                            super::super::super::wasi::io::streams::InputStream::from_handle(
                                                l4 as u32,
                                            )
                                        },
                                        unsafe {
                                            super::super::super::wasi::io::streams::OutputStream::from_handle(
                                                l5 as u32,
                                            )
                                        },
                                    )
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l6 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l6 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result7
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn local_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.local-address"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    use super::super::super::wasi::sockets::network::IpSocketAddress as V20;
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            V20::Ipv4(e20)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            V20::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l21 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn remote_address(&self) -> Result<IpSocketAddress, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 36]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 36],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.remote-address"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result22 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                                    use super::super::super::wasi::sockets::network::IpSocketAddress as V20;
                                    let v20 = match l3 {
                                        0 => {
                                            let e20 = {
                                                let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                                                let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                                                let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                                                let l8 = i32::from(*ptr0.add(13).cast::<u8>());
                                                super::super::super::wasi::sockets::network::Ipv4SocketAddress {
                                                    port: l4 as u16,
                                                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                                                }
                                            };
                                            V20::Ipv4(e20)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                                            let e20 = {
                                                let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                                                let l10 = *ptr0.add(12).cast::<i32>();
                                                let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                                                let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                                                let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                                                let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                                                let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                                                let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                                                let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                                                let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                                                let l19 = *ptr0.add(32).cast::<i32>();
                                                super::super::super::wasi::sockets::network::Ipv6SocketAddress {
                                                    port: l9 as u16,
                                                    flow_info: l10 as u32,
                                                    address: (
                                                        l11 as u16,
                                                        l12 as u16,
                                                        l13 as u16,
                                                        l14 as u16,
                                                        l15 as u16,
                                                        l16 as u16,
                                                        l17 as u16,
                                                        l18 as u16,
                                                    ),
                                                    scope_id: l19 as u32,
                                                }
                                            };
                                            V20::Ipv6(e20)
                                        }
                                    };
                                    v20
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l21 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l21 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result22
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn is_listening(&self) -> bool {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.is-listening"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        _rt::bool_lift(ret as u8)
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn address_family(&self) -> IpAddressFamily {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.address-family"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        super::super::super::wasi::sockets::network::IpAddressFamily::_lift(
                            ret as u8,
                        )
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_listen_backlog_size(
                    &self,
                    value: u64,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-listen-backlog-size"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i64(&value),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn keep_alive_enabled(&self) -> Result<bool, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.keep-alive-enabled"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    _rt::bool_lift(l3 as u8)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_keep_alive_enabled(
                    &self,
                    value: bool,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-keep-alive-enabled"]
                            fn wit_import1(_: i32, _: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                match &value {
                                    true => 1,
                                    false => 0,
                                },
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn keep_alive_idle_time(&self) -> Result<Duration, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.keep-alive-idle-time"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_keep_alive_idle_time(
                    &self,
                    value: Duration,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-keep-alive-idle-time"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1((self).handle() as i32, _rt::as_i64(value), ptr0)
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn keep_alive_interval(&self) -> Result<Duration, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.keep-alive-interval"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_keep_alive_interval(
                    &self,
                    value: Duration,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-keep-alive-interval"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1((self).handle() as i32, _rt::as_i64(value), ptr0)
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn keep_alive_count(&self) -> Result<u32, ErrorCode> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.keep-alive-count"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    l3 as u32
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_keep_alive_count(&self, value: u32) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-keep-alive-count"]
                            fn wit_import1(_: i32, _: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i32(&value),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn hop_limit(&self) -> Result<u8, ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.hop-limit"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    l3 as u8
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_hop_limit(&self, value: u8) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-hop-limit"]
                            fn wit_import1(_: i32, _: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i32(&value),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn receive_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.receive-buffer-size"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_receive_buffer_size(
                    &self,
                    value: u64,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-receive-buffer-size"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i64(&value),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn send_buffer_size(&self) -> Result<u64, ErrorCode> {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 16],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.send-buffer-size"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(8).cast::<i64>();
                                    l3 as u64
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*ptr0.add(8).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l4 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_send_buffer_size(&self, value: u64) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.set-send-buffer-size"]
                            fn wit_import1(_: i32, _: i64, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                _rt::as_i64(&value),
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.subscribe"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe {
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
            }
            impl TcpSocket {
                #[allow(unused_unsafe, clippy::all)]
                pub fn shutdown(
                    &self,
                    shutdown_type: ShutdownType,
                ) -> Result<(), ErrorCode> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/tcp@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]tcp-socket.shutdown"]
                            fn wit_import1(_: i32, _: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import1(
                                (self).handle() as i32,
                                shutdown_type.clone() as i32,
                                ptr0,
                            )
                        };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result4 = match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(1).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l3 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result4
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod tcp_create_socket {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
            pub type IpAddressFamily = super::super::super::wasi::sockets::network::IpAddressFamily;
            pub type TcpSocket = super::super::super::wasi::sockets::tcp::TcpSocket;
            #[allow(unused_unsafe, clippy::all)]
            pub fn create_tcp_socket(
                address_family: IpAddressFamily,
            ) -> Result<TcpSocket, ErrorCode> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:sockets/tcp-create-socket@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "create-tcp-socket"]
                        fn wit_import1(_: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(address_family.clone() as i32, ptr0) };
                    let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                    let result5 = match l2 {
                        0 => {
                            let e = {
                                let l3 = *ptr0.add(4).cast::<i32>();
                                unsafe {
                                    super::super::super::wasi::sockets::tcp::TcpSocket::from_handle(
                                        l3 as u32,
                                    )
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                    l4 as u8,
                                )
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result5
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod ip_name_lookup {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            pub type Network = super::super::super::wasi::sockets::network::Network;
            pub type ErrorCode = super::super::super::wasi::sockets::network::ErrorCode;
            pub type IpAddress = super::super::super::wasi::sockets::network::IpAddress;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct ResolveAddressStream {
                handle: _rt::Resource<ResolveAddressStream>,
            }
            impl ResolveAddressStream {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for ResolveAddressStream {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:sockets/ip-name-lookup@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]resolve-address-stream"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl ResolveAddressStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn resolve_next_address(
                    &self,
                ) -> Result<Option<IpAddress>, ErrorCode> {
                    unsafe {
                        #[repr(align(2))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 22]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 22],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/ip-name-lookup@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]resolve-address-stream.resolve-next-address"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result19 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                                    match l3 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l4 = i32::from(*ptr0.add(4).cast::<u8>());
                                                use super::super::super::wasi::sockets::network::IpAddress as V17;
                                                let v17 = match l4 {
                                                    0 => {
                                                        let e17 = {
                                                            let l5 = i32::from(*ptr0.add(6).cast::<u8>());
                                                            let l6 = i32::from(*ptr0.add(7).cast::<u8>());
                                                            let l7 = i32::from(*ptr0.add(8).cast::<u8>());
                                                            let l8 = i32::from(*ptr0.add(9).cast::<u8>());
                                                            (l5 as u8, l6 as u8, l7 as u8, l8 as u8)
                                                        };
                                                        V17::Ipv4(e17)
                                                    }
                                                    n => {
                                                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                                                        let e17 = {
                                                            let l9 = i32::from(*ptr0.add(6).cast::<u16>());
                                                            let l10 = i32::from(*ptr0.add(8).cast::<u16>());
                                                            let l11 = i32::from(*ptr0.add(10).cast::<u16>());
                                                            let l12 = i32::from(*ptr0.add(12).cast::<u16>());
                                                            let l13 = i32::from(*ptr0.add(14).cast::<u16>());
                                                            let l14 = i32::from(*ptr0.add(16).cast::<u16>());
                                                            let l15 = i32::from(*ptr0.add(18).cast::<u16>());
                                                            let l16 = i32::from(*ptr0.add(20).cast::<u16>());
                                                            (
                                                                l9 as u16,
                                                                l10 as u16,
                                                                l11 as u16,
                                                                l12 as u16,
                                                                l13 as u16,
                                                                l14 as u16,
                                                                l15 as u16,
                                                                l16 as u16,
                                                            )
                                                        };
                                                        V17::Ipv6(e17)
                                                    }
                                                };
                                                v17
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l18 = i32::from(*ptr0.add(2).cast::<u8>());
                                    super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                        l18 as u8,
                                    )
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result19
                    }
                }
            }
            impl ResolveAddressStream {
                #[allow(unused_unsafe, clippy::all)]
                pub fn subscribe(&self) -> Pollable {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:sockets/ip-name-lookup@0.2.0")]
                        unsafe extern "C" {
                            #[link_name = "[method]resolve-address-stream.subscribe"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        unsafe {
                            super::super::super::wasi::io::poll::Pollable::from_handle(
                                ret as u32,
                            )
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn resolve_addresses(
                network: &Network,
                name: &str,
            ) -> Result<ResolveAddressStream, ErrorCode> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:sockets/ip-name-lookup@0.2.0")]
                    unsafe extern "C" {
                        #[link_name = "resolve-addresses"]
                        fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import2(
                            (network).handle() as i32,
                            ptr0.cast_mut(),
                            len0,
                            ptr1,
                        )
                    };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result6 = match l3 {
                        0 => {
                            let e = {
                                let l4 = *ptr1.add(4).cast::<i32>();
                                unsafe { ResolveAddressStream::from_handle(l4 as u32) }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l5 = i32::from(*ptr1.add(4).cast::<u8>());
                                super::super::super::wasi::sockets::network::ErrorCode::_lift(
                                    l5 as u8,
                                )
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result6
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wavs {
    pub mod worker {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod layer_types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Timestamp {
                pub nanos: u64,
            }
            impl ::core::fmt::Debug for Timestamp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Timestamp").field("nanos", &self.nanos).finish()
                }
            }
            #[derive(Clone)]
            pub struct CosmosAddress {
                pub bech32_addr: _rt::String,
                /// prefix is the first part of the bech32 address
                pub prefix_len: u32,
            }
            impl ::core::fmt::Debug for CosmosAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CosmosAddress")
                        .field("bech32-addr", &self.bech32_addr)
                        .field("prefix-len", &self.prefix_len)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct CosmosEvent {
                pub ty: _rt::String,
                pub attributes: _rt::Vec<(_rt::String, _rt::String)>,
            }
            impl ::core::fmt::Debug for CosmosEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CosmosEvent")
                        .field("ty", &self.ty)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct CosmosChainConfig {
                pub chain_id: _rt::String,
                pub rpc_endpoint: Option<_rt::String>,
                pub grpc_endpoint: Option<_rt::String>,
                pub grpc_web_endpoint: Option<_rt::String>,
                pub gas_price: f32,
                pub gas_denom: _rt::String,
                pub bech32_prefix: _rt::String,
            }
            impl ::core::fmt::Debug for CosmosChainConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CosmosChainConfig")
                        .field("chain-id", &self.chain_id)
                        .field("rpc-endpoint", &self.rpc_endpoint)
                        .field("grpc-endpoint", &self.grpc_endpoint)
                        .field("grpc-web-endpoint", &self.grpc_web_endpoint)
                        .field("gas-price", &self.gas_price)
                        .field("gas-denom", &self.gas_denom)
                        .field("bech32-prefix", &self.bech32_prefix)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct EvmAddress {
                pub raw_bytes: _rt::Vec<u8>,
            }
            impl ::core::fmt::Debug for EvmAddress {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("EvmAddress")
                        .field("raw-bytes", &self.raw_bytes)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct EvmEventLogData {
                /// the raw log topics that can be decoded into an event
                pub topics: _rt::Vec<_rt::Vec<u8>>,
                /// the raw log data that can be decoded into an event
                pub data: _rt::Vec<u8>,
            }
            impl ::core::fmt::Debug for EvmEventLogData {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("EvmEventLogData")
                        .field("topics", &self.topics)
                        .field("data", &self.data)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct EvmChainConfig {
                pub chain_id: _rt::String,
                pub ws_endpoint: Option<_rt::String>,
                pub http_endpoint: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for EvmChainConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("EvmChainConfig")
                        .field("chain-id", &self.chain_id)
                        .field("ws-endpoint", &self.ws_endpoint)
                        .field("http-endpoint", &self.http_endpoint)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct TriggerSourceEvmContractEvent {
                pub address: EvmAddress,
                pub chain_name: _rt::String,
                pub event_hash: _rt::Vec<u8>,
            }
            impl ::core::fmt::Debug for TriggerSourceEvmContractEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TriggerSourceEvmContractEvent")
                        .field("address", &self.address)
                        .field("chain-name", &self.chain_name)
                        .field("event-hash", &self.event_hash)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct TriggerSourceCosmosContractEvent {
                pub address: CosmosAddress,
                pub chain_name: _rt::String,
                pub event_type: _rt::String,
            }
            impl ::core::fmt::Debug for TriggerSourceCosmosContractEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TriggerSourceCosmosContractEvent")
                        .field("address", &self.address)
                        .field("chain-name", &self.chain_name)
                        .field("event-type", &self.event_type)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct BlockIntervalSource {
                pub chain_name: _rt::String,
                pub n_blocks: u32,
                pub start_block: Option<u64>,
                pub end_block: Option<u64>,
            }
            impl ::core::fmt::Debug for BlockIntervalSource {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("BlockIntervalSource")
                        .field("chain-name", &self.chain_name)
                        .field("n-blocks", &self.n_blocks)
                        .field("start-block", &self.start_block)
                        .field("end-block", &self.end_block)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct TriggerSourceCron {
                pub schedule: _rt::String,
                pub start_time: Option<Timestamp>,
                pub end_time: Option<Timestamp>,
            }
            impl ::core::fmt::Debug for TriggerSourceCron {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TriggerSourceCron")
                        .field("schedule", &self.schedule)
                        .field("start-time", &self.start_time)
                        .field("end-time", &self.end_time)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum TriggerSource {
                EvmContractEvent(TriggerSourceEvmContractEvent),
                CosmosContractEvent(TriggerSourceCosmosContractEvent),
                BlockInterval(BlockIntervalSource),
                Cron(TriggerSourceCron),
                Manual,
            }
            impl ::core::fmt::Debug for TriggerSource {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        TriggerSource::EvmContractEvent(e) => {
                            f.debug_tuple("TriggerSource::EvmContractEvent")
                                .field(e)
                                .finish()
                        }
                        TriggerSource::CosmosContractEvent(e) => {
                            f.debug_tuple("TriggerSource::CosmosContractEvent")
                                .field(e)
                                .finish()
                        }
                        TriggerSource::BlockInterval(e) => {
                            f.debug_tuple("TriggerSource::BlockInterval")
                                .field(e)
                                .finish()
                        }
                        TriggerSource::Cron(e) => {
                            f.debug_tuple("TriggerSource::Cron").field(e).finish()
                        }
                        TriggerSource::Manual => {
                            f.debug_tuple("TriggerSource::Manual").finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct TriggerConfig {
                pub service_id: _rt::String,
                pub workflow_id: _rt::String,
                pub trigger_source: TriggerSource,
            }
            impl ::core::fmt::Debug for TriggerConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TriggerConfig")
                        .field("service-id", &self.service_id)
                        .field("workflow-id", &self.workflow_id)
                        .field("trigger-source", &self.trigger_source)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct TriggerDataEvmContractEvent {
                pub contract_address: EvmAddress,
                pub chain_name: _rt::String,
                pub log: EvmEventLogData,
                pub block_height: u64,
            }
            impl ::core::fmt::Debug for TriggerDataEvmContractEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TriggerDataEvmContractEvent")
                        .field("contract-address", &self.contract_address)
                        .field("chain-name", &self.chain_name)
                        .field("log", &self.log)
                        .field("block-height", &self.block_height)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct TriggerDataCosmosContractEvent {
                pub contract_address: CosmosAddress,
                pub chain_name: _rt::String,
                pub event: CosmosEvent,
                pub block_height: u64,
            }
            impl ::core::fmt::Debug for TriggerDataCosmosContractEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TriggerDataCosmosContractEvent")
                        .field("contract-address", &self.contract_address)
                        .field("chain-name", &self.chain_name)
                        .field("event", &self.event)
                        .field("block-height", &self.block_height)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct BlockIntervalData {
                pub chain_name: _rt::String,
                pub block_height: u64,
            }
            impl ::core::fmt::Debug for BlockIntervalData {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("BlockIntervalData")
                        .field("chain-name", &self.chain_name)
                        .field("block-height", &self.block_height)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct TriggerDataCron {
                pub trigger_time: Timestamp,
            }
            impl ::core::fmt::Debug for TriggerDataCron {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TriggerDataCron")
                        .field("trigger-time", &self.trigger_time)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum TriggerData {
                EvmContractEvent(TriggerDataEvmContractEvent),
                CosmosContractEvent(TriggerDataCosmosContractEvent),
                BlockInterval(BlockIntervalData),
                Cron(TriggerDataCron),
                Raw(_rt::Vec<u8>),
            }
            impl ::core::fmt::Debug for TriggerData {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        TriggerData::EvmContractEvent(e) => {
                            f.debug_tuple("TriggerData::EvmContractEvent")
                                .field(e)
                                .finish()
                        }
                        TriggerData::CosmosContractEvent(e) => {
                            f.debug_tuple("TriggerData::CosmosContractEvent")
                                .field(e)
                                .finish()
                        }
                        TriggerData::BlockInterval(e) => {
                            f.debug_tuple("TriggerData::BlockInterval").field(e).finish()
                        }
                        TriggerData::Cron(e) => {
                            f.debug_tuple("TriggerData::Cron").field(e).finish()
                        }
                        TriggerData::Raw(e) => {
                            f.debug_tuple("TriggerData::Raw").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct TriggerAction {
                pub config: TriggerConfig,
                pub data: TriggerData,
            }
            impl ::core::fmt::Debug for TriggerAction {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TriggerAction")
                        .field("config", &self.config)
                        .field("data", &self.data)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct WasmResponse {
                pub payload: _rt::Vec<u8>,
                pub ordering: Option<u64>,
            }
            impl ::core::fmt::Debug for WasmResponse {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("WasmResponse")
                        .field("payload", &self.payload)
                        .field("ordering", &self.ordering)
                        .finish()
                }
            }
            #[derive(Clone, Copy)]
            pub enum LogLevel {
                Error,
                Warn,
                Info,
                Debug,
                Trace,
            }
            impl ::core::fmt::Debug for LogLevel {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        LogLevel::Error => f.debug_tuple("LogLevel::Error").finish(),
                        LogLevel::Warn => f.debug_tuple("LogLevel::Warn").finish(),
                        LogLevel::Info => f.debug_tuple("LogLevel::Info").finish(),
                        LogLevel::Debug => f.debug_tuple("LogLevel::Debug").finish(),
                        LogLevel::Trace => f.debug_tuple("LogLevel::Trace").finish(),
                    }
                }
            }
        }
    }
}
#[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
pub mod host {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() = super::__link_custom_section_describing_imports;
    use super::_rt;
    pub type EvmChainConfig = super::wavs::worker::layer_types::EvmChainConfig;
    pub type CosmosChainConfig = super::wavs::worker::layer_types::CosmosChainConfig;
    pub type LogLevel = super::wavs::worker::layer_types::LogLevel;
    #[allow(unused_unsafe, clippy::all)]
    pub fn get_evm_chain_config(chain_name: &str) -> Option<EvmChainConfig> {
        unsafe {
            #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
            #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit<u8>; 9 * ::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea(
                [::core::mem::MaybeUninit::uninit(); 9 * ::core::mem::size_of::<*const u8>()],
            );
            let vec0 = chain_name;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "host")]
            unsafe extern "C" {
                #[link_name = "get-evm-chain-config"]
                fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
            }
            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                unreachable!()
            }
            unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
            let result15 = match l3 {
                0 => None,
                1 => {
                    let e = {
                        let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l5 = *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len6 = l5;
                        let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                        let l7 = i32::from(
                            *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                        );
                        let l11 = i32::from(
                            *ptr1.add(6 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                        );
                        super::wavs::worker::layer_types::EvmChainConfig {
                            chain_id: _rt::string_lift(bytes6),
                            ws_endpoint: match l7 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l8 = *ptr1
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l9 = *ptr1
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len10 = l9;
                                        let bytes10 =
                                            _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                                        _rt::string_lift(bytes10)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            http_endpoint: match l11 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l12 = *ptr1
                                            .add(7 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l13 = *ptr1
                                            .add(8 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len14 = l13;
                                        let bytes14 =
                                            _rt::Vec::from_raw_parts(l12.cast(), len14, len14);
                                        _rt::string_lift(bytes14)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        }
                    };
                    Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
            };
            result15
        }
    }
    #[allow(unused_unsafe, clippy::all)]
    pub fn get_cosmos_chain_config(chain_name: &str) -> Option<CosmosChainConfig> {
        unsafe {
            #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
            #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
            struct RetArea(
                [::core::mem::MaybeUninit<u8>; 17 * ::core::mem::size_of::<*const u8>()],
            );
            let mut ret_area = RetArea(
                [::core::mem::MaybeUninit::uninit(); 17 * ::core::mem::size_of::<*const u8>()],
            );
            let vec0 = chain_name;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "host")]
            unsafe extern "C" {
                #[link_name = "get-cosmos-chain-config"]
                fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
            }
            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                unreachable!()
            }
            unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
            let result26 = match l3 {
                0 => None,
                1 => {
                    let e = {
                        let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l5 = *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len6 = l5;
                        let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                        let l7 = i32::from(
                            *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                        );
                        let l11 = i32::from(
                            *ptr1.add(6 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                        );
                        let l15 = i32::from(
                            *ptr1.add(9 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                        );
                        let l19 = *ptr1.add(12 * ::core::mem::size_of::<*const u8>()).cast::<f32>();
                        let l20 =
                            *ptr1.add(13 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l21 =
                            *ptr1.add(14 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len22 = l21;
                        let bytes22 = _rt::Vec::from_raw_parts(l20.cast(), len22, len22);
                        let l23 =
                            *ptr1.add(15 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l24 =
                            *ptr1.add(16 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len25 = l24;
                        let bytes25 = _rt::Vec::from_raw_parts(l23.cast(), len25, len25);
                        super::wavs::worker::layer_types::CosmosChainConfig {
                            chain_id: _rt::string_lift(bytes6),
                            rpc_endpoint: match l7 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l8 = *ptr1
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l9 = *ptr1
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len10 = l9;
                                        let bytes10 =
                                            _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                                        _rt::string_lift(bytes10)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            grpc_endpoint: match l11 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l12 = *ptr1
                                            .add(7 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l13 = *ptr1
                                            .add(8 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len14 = l13;
                                        let bytes14 =
                                            _rt::Vec::from_raw_parts(l12.cast(), len14, len14);
                                        _rt::string_lift(bytes14)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            grpc_web_endpoint: match l15 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l16 = *ptr1
                                            .add(10 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l17 = *ptr1
                                            .add(11 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len18 = l17;
                                        let bytes18 =
                                            _rt::Vec::from_raw_parts(l16.cast(), len18, len18);
                                        _rt::string_lift(bytes18)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            gas_price: l19,
                            gas_denom: _rt::string_lift(bytes22),
                            bech32_prefix: _rt::string_lift(bytes25),
                        }
                    };
                    Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
            };
            result26
        }
    }
    #[allow(unused_unsafe, clippy::all)]
    pub fn config_var(key: &str) -> Option<_rt::String> {
        unsafe {
            #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
            #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit<u8>; 3 * ::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea(
                [::core::mem::MaybeUninit::uninit(); 3 * ::core::mem::size_of::<*const u8>()],
            );
            let vec0 = key;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "host")]
            unsafe extern "C" {
                #[link_name = "config-var"]
                fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
            }
            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                unreachable!()
            }
            unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
            let result7 = match l3 {
                0 => None,
                1 => {
                    let e = {
                        let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l5 = *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len6 = l5;
                        let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                        _rt::string_lift(bytes6)
                    };
                    Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
            };
            result7
        }
    }
    #[allow(unused_unsafe, clippy::all)]
    pub fn log(level: LogLevel, message: &str) -> () {
        unsafe {
            use super::wavs::worker::layer_types::LogLevel as V0;
            let result1 = match level {
                V0::Error => 0i32,
                V0::Warn => 1i32,
                V0::Info => 2i32,
                V0::Debug => 3i32,
                V0::Trace => 4i32,
            };
            let vec2 = message;
            let ptr2 = vec2.as_ptr().cast::<u8>();
            let len2 = vec2.len();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "host")]
            unsafe extern "C" {
                #[link_name = "log"]
                fn wit_import3(_: i32, _: *mut u8, _: usize);
            }
            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import3(_: i32, _: *mut u8, _: usize) {
                unreachable!()
            }
            unsafe { wit_import3(result1, ptr2.cast_mut(), len2) };
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    u32::MAX => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub use alloc_crate::alloc;
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_layer_trigger_world_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: __export_world_layer_trigger_world_cabi!($ty
        with_types_in $($path_to_types_root)*);
    };
}
#[doc(inline)]
pub(crate) use __export_layer_trigger_world_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.41.0:wavs:worker@0.4.0:layer-trigger-world:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 17448] = *b"\
 asm   wit-component-encoding A\
A^B1rnanosw 	timestamp  rbech32-ad\
drs
prefix-leny cosmos-address osspr\
tys
attributes cosmos-event ksrchai\
n-idsrpc-endpointgrpc-endpointgrpc-web-endpoint	gas-p\
ricev	gas-denomsbech32-prefixs cosmos-chain-config 	\
p}r	raw-bytes evm-address pr\
topicsdata evm-event-log-data rchain-i\
dsws-endpointhttp-endpoint evm-chain-config \
raddress
chain-names
event-hash !trigger-source-evm-c\
ontract-event raddress
chain-names
event-types\
 $trigger-source-cosmos-contract-event kwr
chain-names\
n-blocksystart-block	end-block block-interval-source\
 krschedules
start-timeend-time \
trigger-source-cron qevm-contract-event cosmos\
-contract-event block-interval cron manua\
l   trigger-source r
service-idsworkflow-ids\
trigger-source trigger-config rcontract-addres\
s
chain-nameslogblock-heightw trigger-data-evm-contr\
act-event !rcontract-address
chain-namesevent\
block-heightw \"trigger-data-cosmos-contract-event #r
chain\
-namesblock-heightw block-interval-data %rtrigger-\
time trigger-data-cron 'qevm-contract-event\" \
cosmos-contract-event$ block-interval& cron( raw\
  trigger-data )rconfig data* tri\
gger-action +rpayloadordering wasm-respons\
e -qerror  warn  info  debug  trace  \
 	log-level / wavs:worker/layer-types@0.4.0  \
 trigger-action trigger-action   wasm-respo\
nse wasm-response B
 pollableh \
@self  [method]pollable.ready@self\
  [method]pollable.blockppy@in\
  poll wasi:io/poll@0.2.0 \
pollableB pollable  w \
instant w duration @   now\
@   
resolutioni@when \
 subscribe-instant	@when  subscrib\
e-duration
 !wasi:clocks/monotonic-clock@0.2.0B \
errorh @self s [method]error.to-debug\
-string wasi:io/error@0.2.0 errorB\
(	 error   pollab\
le iqlast-operation-failed closed  \
 stream-error  input-stream output-strea\
mhp}j
@self	lenw \
 [method]input-stream.read \"[method]input-stream.blocking\
-readjw@self	lenw  [met\
hod]input-stream.skip \"[method]input-stream.blocking-skip\
i@self	  [method]input-stream.subscribe\
h@self  ![method]output-stream.check-write\
j @selfcontents
  [method]\
output-stream.write .[method]output-stream.blocking-write-and-flush\
@self  [method]output-stream.flush\
 $[method]output-stream.blocking-flush@self \
 [method]output-stream.subscribe@selflenw \
 \"[method]output-stream.write-zeroes[method]output-stream.b\
locking-write-zeroes-and-flush@selfsrc	lenw \
 [method]output-stream.splice %[method]output-stream.b\
locking-splice wasi:io/streams@0.2.0
 d\
uration input-stream output-streamB\
 duration   inpu\
t-stream  output-stream \
	 io-error  pollable \
q
get  head  post  put  delete  con\
nect  options  trace  patch  others  metho\
d 
qHTTP  HTTPS  others  scheme\
 ksk{rrcode	info-code DNS-error-pay\
load k}ralert-idalert-message TLS-\
alert-received-payload kyr
field-name
field-size\
 field-size-payload kwkq'DNS-timeout  	\
DNS-error destination-not-found  destination-unavailable  \
destination-IP-prohibited  destination-IP-unroutable  connection-ref\
used  connection-terminated  connection-timeout  connection-re\
ad-timeout  connection-write-timeout  connection-limit-reached  \
TLS-protocol-error  TLS-certificate-error  TLS-alert-received\
 HTTP-request-denied  HTTP-request-length-required  HTTP-reques\
t-body-size HTTP-request-method-invalid  HTTP-request-URI-inv\
alid  HTTP-request-URI-too-long   HTTP-request-header-section-size\
 HTTP-request-header-size !HTTP-request-trailer-section-size\
 HTTP-request-trailer-size HTTP-response-incomplete  !HT\
TP-response-header-section-size HTTP-response-header-size \
HTTP-response-body-size \"HTTP-response-trailer-section-size\
 HTTP-response-trailer-size HTTP-response-transfer-coding\
 HTTP-response-content-coding HTTP-response-timeout  HTT\
P-upgrade-failed  HTTP-protocol-error  loop-detected  configur\
ation-error  internal-error  
error-code q\
invalid-syntax  	forbidden  	immutable   header-error\
 s 	field-key p} field-value  \
 fields headers \" trailers \" \
incoming-request outgoing-request request-opti\
ons response-outparam{ status-code )\
 incoming-response incoming-body future-t\
railers outgoing-response outgoing-body\
 future-incoming-responsei\"@  [constructo\
r]fields2o!p3j1@entries4 \
[static]fields.from-list6h\"p!@self7name 8\
 [method]fields.get9@self7name  [meth\
od]fields.has:j @self7namevalue8 ;\
 [method]fields.set<@self7name ; [method]\
fields.delete=@self7namevalue! ; [method]f\
ields.append>@self7 [method]fields.entries?@\
self7 [method]fields.clone@h%@self \
  [method]incoming-request.methodB@self  \
 ([method]incoming-request.path-with-queryCk@self\
    [method]incoming-request.schemeE \"[method]incoming\
-request.authorityCi#@self     [method]in\
coming-request.headersGi,j  @self   \
  [method]incoming-request.consumeJi&@headers  \
  [constructor]outgoing-requestLh&i/j  \
@self    [method]outgoing-request.bodyP@\
self   [method]outgoing-request.methodQj  @\
self method   #[method]outgoing-request.set-meth\
odS@self   ([method]outgoing-request.path-with-qu\
eryT@self path-with-query   ,[method]out\
going-request.set-path-with-queryU@self    [\
method]outgoing-request.schemeV@self scheme  \
  #[method]outgoing-request.set-schemeW \"[method]outgoing-reques\
t.authorityT@self 	authority   &[method]o\
utgoing-request.set-authorityX@self     [meth\
od]outgoing-request.headersYi'@    [constructor]requ\
est-options[h'k@self    '[method]req\
uest-options.connect-timeout^@self duration  \
  +[method]request-options.set-connect-timeout_ *[method]request-\
options.first-byte-timeout^ .[method]request-options.set-first-byte-tim\
eout_ -[method]request-options.between-bytes-timeout^[method\
]request-options.set-between-bytes-timeout_i(i.j \
@param response   [static]response-outpa\
ram.setch+@self  *  [method]incoming-response.\
statuse@self    ![method]incoming-response.heade\
rsf@self    ![method]incoming-response.consume\
gh,ij  @self    [metho\
d]incoming-body.streamki-@this    [stati\
c]incoming-body.finishmh-i	@self    !\
[method]future-trailers.subscribepi$k j \
j  k @self    [method]future-\
trailers.getv@headers    [constructor]outgoi\
ng-responsewh.@self  * %[method]outgoing-response\
.status-codey@self status-code*   )[method]o\
utgoing-response.set-status-codez@self    ![meth\
od]outgoing-response.headers{@self    [metho\
d]outgoing-response.body|h/ij  @self\
    [method]outgoing-body.writej @\
this trailers   [static]outgoing-body.finish\
h0@self   *[method]future-incomin\
g-response.subscribei+jj\
 k@self  $[method]future-incoming\
-response.gethk@err \
 http-error-code wasi:http/types@0.2.0\
 outgoing-request request-options fut\
ure-incoming-response 
error-codeB\
 outgoing-request   request-options \
 future-incoming-response \
 
error-code iik	ij\
@requestoptions
  handle\
  wasi:http/outgoing-handler@0.2.0  evm-chain-conf\
ig  cosmos-chain-config  	log-levelB\
 evm-chain-config   cosmos-c\
hain-config  	log-level k\
@
chain-names  get-evm-chain-configk@\

chain-names  get-cosmos-chain-config	ks@\
keys 
 
config-var@levelmessages \
 log hostB
ossp @  \
 get-environmentps@   get-arguments\
ks@   initial-cwd wasi:cli/environment@0.2.0\
Bj  @status   exit \
wasi:cli/exit@0.2.0B input-stre\
am  i@   	get-stdin wasi:cli/st\
din@0.2.0B output-stream  \
i@   
get-stdout wasi:cli/stdout@0.2.0\
B output-stream  i@ \
  
get-stderr wasi:cli/stderr@0.2.0B\
 terminal-input wasi:cli/terminal-input@0.2.0\
B terminal-output wasi:cli/terminal-output@0.2.0\
 terminal-inputB termi\
nal-input  ik@   get-terminal-stdin\
 wasi:cli/terminal-stdin@0.2.0  terminal-ou\
tputB! terminal-output  ik\
@   get-terminal-stdout wasi:cli/terminal-st\
dout@0.2.0\"B! terminal-output  i\
k@   get-terminal-stderr wasi:cl\
i/terminal-stderr@0.2.0#Brsecondswnanosecondsy \
datetime  @   now 
resolution\
 wasi:clocks/wall-clock@0.2.0$ error \
datetimeBr input-stream  \
 output-stream % error \
& datetime w filesize \
munknownblock-devicecharacter-device	directoryfifosym\
bolic-linkregular-filesocket descriptor-type 
n\
readwritefile-integrity-syncdata-integrity-syncrequested-wri\
te-syncmutate-directory descriptor-flags nsyml\
ink-follow 
path-flags ncreate	directory	excl\
usivetruncate 
open-flags w 
link-count \
krtype
link-countsize	data-access-time\
stampdata-modification-timestampstatus-change-timestamp \
descriptor-stat q	no-change  now  	timestamp\
  new-timestamp rtypenames d\
irectory-entry m%accesswould-blockalreadybad-descri\
ptorbusydeadlockquotaexistfile-too-largeillegal-byte-seq\
uencein-progressinterruptedinvalidiois-directoryloop\
too-many-linksmessage-sizename-too-long	no-deviceno-entryno-l\
ockinsufficient-memoryinsufficient-spacenot-directory	not-empty\
not-recoverableunsupportedno-ttyno-such-deviceoverflownot-pe\
rmittedpipe	read-onlyinvalid-seektext-file-busycross-device\
 
error-code mnormal
sequentialrandom	will-ne\
ed	dont-needno-reuse advice rlowerwuppe\
rw metadata-hash-value  
descriptor d\
irectory-entry-streamh!ij$@self#\
offset	 % \"[method]descriptor.read-via-stream&ij\
'@self#offset	 ( #[method]descriptor.write-via-\
stream)@self# ( $[method]descriptor.append-via-stream*\
j @self#offset	length	advice +\
 [method]descriptor.advise,@self# + [method]descr\
iptor.sync-data-j@self# . [method]\
descriptor.get-flags/j@self#  [me\
thod]descriptor.get-type1@self#size	 + [method]\
descriptor.set-size2@self#data-access-timestampdata-\
modification-timestamp + [method]descriptor.set-times3p}\
o4j5@self#length	offset	\
 [method]descriptor.read7j	@self#buf\
fer4offset	 8 [method]descriptor.write9i\"j:\
@self# ; ![method]descriptor.read-directory< \
[method]descriptor.sync-@self#paths + &[method]descrip\
tor.create-directory-at=j@self# > \
[method]descriptor.stat?@self#
path-flagspaths >\
 [method]descriptor.stat-at@@self#
path-flagspat\
hsdata-access-timestampdata-modification-timestamp + [\
method]descriptor.set-times-atA@self#old-path-flagso\
ld-pathsnew-descriptor#new-paths + [method]descriptor.link-at\
Bi!j @self#
path-flagspaths
o\
pen-flagsflags   [method]descriptor.open-atEj\
s@self#paths   [method]descriptor.rea\
dlink-atG &[method]descriptor.remove-directory-at=@self\
#old-pathsnew-descriptor#new-paths + [method]descriptor.re\
name-atH@self#old-pathsnew-paths + [method]des\
criptor.symlink-atI ![method]descriptor.unlink-file-at=@\
self#other#  ![method]descriptor.is-same-objectJj \
@self#    [method]descriptor.metadata-hashL\
@self#
path-flagspaths   #[method]descriptor.metad\
ata-hash-atMh\"kj @self  \
 [method]directory-entry-stream.read-directory-entryQh\
k@err    filesystem-error-codeT \
wasi:filesystem/types@0.2.0' 
descriptorB\
( 
descriptor  iosp@  \
 get-directories wasi:filesystem/preopens@0.2.0)B\
 networkmunknownaccess-deniednot-supported\
invalid-argumentout-of-memorytimeoutconcurrency-conflictnot-in-p\
rogresswould-blockinvalid-statenew-socket-limitaddress-not-binda\
bleaddress-in-useremote-unreachableconnection-refusedconnection-\
resetconnection-aborteddatagram-too-largename-unresolvabletempor\
ary-resolver-failurepermanent-resolver-failure 
error-code \
mipv4ipv6 ip-address-family o}}}} \
ipv4-address o{{{{{{{{ ipv6-address q\
ipv4 ipv6  
ip-address 	r\
port{address ipv4-socket-address rport{	\
flow-infoyaddressscope-idy ipv6-socket-address \
qipv4 ipv6  ip-socket-address \
 wasi:sockets/network@0.2.0* networkB\
+ network  i@   instance-network\
 #wasi:sockets/instance-network@0.2.0, 
error-code\
 ip-socket-address ip-address-familyBD\
 pollable  + network \
- 
error-code . ip-soc\
ket-address / ip-address-family p\
}rdata
remote-address incoming-datagram \
krdata
remote-address outgoing-datagram\
  
udp-socket incoming-datagram-stream\
 outgoing-datagram-streamhhj @\
selfnetworklocal-address  [method]udp-sock\
et.start-bind@self  [method]udp-socket.fin\
ish-bindiioj@\
selfremote-address  [method]udp-socket.stream\
j@self   [method]udp-socket.loc\
al-address ![method]udp-socket.remote-address@s\
elf 	 ![method]udp-socket.address-familyj}\
@self   $[method]udp-socket.unicast-hop-limit!@\
selfvalue}  ([method]udp-socket.set-unicast-hop-limit\"\
jw@self # &[method]udp-socket.receive-buff\
er-size$@selfvaluew  *[method]udp-socket.set-r\
eceive-buffer-size% #[method]udp-socket.send-buffer-size$ '[me\
thod]udp-socket.set-send-buffer-size%i@self & \
[method]udp-socket.subscribe'hpj)@\
self(max-resultsw * ([method]incoming-datagram-stream.receive+\
@self( & *[method]incoming-datagram-stream.subscribe,h\
@self- # +[method]outgoing-datagram-stream.check-send.\
p@self-	datagrams/ # %[method]outgoing-datagram-str\
eam.send0@self- & *[method]outgoing-datagram-stream.subscr\
ibe1 wasi:sockets/udp@0.2.00 
udp-socketB\
+ network  - 
error-code\
 / ip-address-family 1\
 
udp-socket ij@address-fam\
ily 	 create-udp-socket
 $wasi:sockets/udp-create-s\
ocket@0.2.02BT input-stream  \
 output-stream  polla\
ble  duration +\
 network - 
error-code 
\
. ip-socket-address / ip-address-\
family mreceivesendboth shutdown-type \
 
tcp-sockethh	j @se\
lfnetworklocal-address  [method]tcp-socket.sta\
rt-bind@self  [method]tcp-socket.finish-bi\
nd@selfnetworkremote-address  \
 [method]tcp-socket.start-connectiio\
j@self  ![method]tcp-socket.finish-con\
nect [method]tcp-socket.start-listen  [method]t\
cp-socket.finish-listenioj\
@self   [method]tcp-socket.accept!j\
@self \"  [method]tcp-socket.local-address#\
 ![method]tcp-socket.remote-address#@self  \
[method]tcp-socket.is-listening$@self  ![method]tc\
p-socket.address-family%@selfvaluew  *[method]\
tcp-socket.set-listen-backlog-size&j@self\
 ' %[method]tcp-socket.keep-alive-enabled(@selfval\
ue  )[method]tcp-socket.set-keep-alive-enabled)j\
@self * '[method]tcp-socket.keep-alive-idle-time+\
@selfvalue  +[method]tcp-socket.set-keep-alive-idl\
e-time, &[method]tcp-socket.keep-alive-interval+ *[method]tcp-\
socket.set-keep-alive-interval,jy@self -\
 #[method]tcp-socket.keep-alive-count.@selfvaluey \
 '[method]tcp-socket.set-keep-alive-count/j}@\
self  [method]tcp-socket.hop-limit1@selfv\
alue}   [method]tcp-socket.set-hop-limit2jw\
@self &[method]tcp-socket.receive-buffer-size4 *[me\
thod]tcp-socket.set-receive-buffer-size& #[method]tcp-socket.send-buffe\
r-size4 '[method]tcp-socket.set-send-buffer-size&i@\
self [method]tcp-socket.subscribe6@self\
shutdown-type  [method]tcp-socket.shutdown7 wasi:\
sockets/tcp@0.2.03 
tcp-socketB+\
 network  - 
error-code \
/ ip-address-family 4 
tcp-socket\
 ij@address-family 	 \
create-tcp-socket
 $wasi:sockets/tcp-create-socket@0.2.05\
 
ip-addressB pollable  \
+ network - 
error-code \
6 
ip-address  resolve-address-stream\
hkj
@self	 [me\
thod]resolve-address-stream.resolve-next-addressi@se\
lf	  ([method]resolve-address-stream.subscribeh\
ij@networknames  resol\
ve-addresses !wasi:sockets/ip-name-lookup@0.2.07Bp}\
@lenw   get-random-bytes@  w get-r\
andom-u64 wasi:random/random@0.2.08Bp}@\
lenw   get-insecure-random-bytes@  w get-i\
nsecure-random-u64 wasi:random/insecure@0.2.09B\
oww@    insecure-seed wasi:random/insecure-\
seed@0.2.0:kj;s@trigger-action < \
run= %wavs:worker/layer-trigger-world@0.4.0  laye\
r-trigger-world   G	producersprocessed-bywit-component\
0.227.1wit-bindgen-rust0.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
````

## File: components/evm-price-oracle/src/lib.rs
````rust
mod trigger;
use trigger::{decode_trigger_event, encode_trigger_output, Destination};
use wavs_wasi_utils::{
    evm::alloy_primitives::hex,
    http::{fetch_json, http_request_get},
};
pub mod bindings;
use crate::bindings::{export, Guest, TriggerAction, WasmResponse};
use alloy_sol_types::SolValue;
use serde::{Deserialize, Serialize};
use wstd::{http::HeaderValue, runtime::block_on};

struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    /// Main entry point for the price oracle component.
    /// WAVS is subscribed to watch for events emitted by the blockchain.
    /// When WAVS observes an event is emitted, it will internally route the event and its data to this function (component).
    /// The processing then occurs before the output is returned back to WAVS to be submitted to the blockchain by the operator(s).
    ///
    /// This is why the `Destination::Ethereum` requires the encoded trigger output, it must be ABI encoded for the solidity contract.
    /// Failure to do so will result in a failed submission as the signature will not match the saved output.
    ///
    /// After the data is properly set by the operator through WAVS, any user can query the price data from the blockchain in the solidity contract.
    /// You can also return `None` as the output if nothing needs to be saved to the blockchain. (great for performing some off chain action)
    ///
    /// This function:
    /// 1. Receives a trigger action containing encoded data
    /// 2. Decodes the input to get a cryptocurrency ID (in hex)
    /// 3. Fetches current price data from CoinMarketCap
    /// 4. Returns the encoded response based on the destination
    fn run(action: TriggerAction) -> std::result::Result<Option<WasmResponse>, String> {
        let (trigger_id, req, dest) =
            decode_trigger_event(action.data).map_err(|e| e.to_string())?;

        let hex_data = match String::from_utf8(req.clone()) {
            Ok(input_str) if input_str.starts_with("0x") => {
                // Local testing: hex string input
                hex::decode(&input_str[2..])
                    .map_err(|e| format!("Failed to decode hex string: {}", e))?
            }
            _ => {
                // Production: direct binary ABI input
                req.clone()
            }
        };

        let decoded = <String as SolValue>::abi_decode(&hex_data)
            .map_err(|e| format!("Failed to decode ABI string: {}", e))?;

        let id =
            decoded.trim().parse::<u64>().map_err(|_| format!("Invalid number: {}", decoded))?;

        println!("Decoded crypto ID: {}", id);

        let res = block_on(async move {
            let resp_data = get_price_feed(id).await?;
            println!("resp_data: {:?}", resp_data);
            serde_json::to_vec(&resp_data).map_err(|e| e.to_string())
        })?;

        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
            Destination::CliOutput => Some(WasmResponse { payload: res.into(), ordering: None }),
        };
        Ok(output)
    }
}

/// Fetches cryptocurrency price data from CoinMarketCap's API
///
/// # Arguments
/// * `id` - CoinMarketCap's unique identifier for the cryptocurrency
///
/// # Returns
/// * `PriceFeedData` containing:
///   - symbol: The cryptocurrency's ticker symbol (e.g., "BTC")
///   - price: Current price in USD
///   - timestamp: Server timestamp of the price data
///
/// # Implementation Details
/// - Uses CoinMarketCap's v3 API endpoint
/// - Includes necessary headers to avoid rate limiting:
///   * User-Agent to mimic a browser
///   * Random cookie with current timestamp
///   * JSON content type headers
///
/// As of writing (Mar 31, 2025), the CoinMarketCap API is free to use and has no rate limits.
/// This may change in the future so be aware of issues that you may encounter going forward.
/// There is a more proper API for pro users that you can use
/// - <https://coinmarketcap.com/api/documentation/v1/>
async fn get_price_feed(id: u64) -> Result<PriceFeedData, String> {
    let url = format!(
        "https://api.coinmarketcap.com/data-api/v3/cryptocurrency/detail?id={}&range=1h",
        id
    );

    let current_time = std::time::SystemTime::now().elapsed().unwrap().as_secs();

    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    req.headers_mut()
        .insert("User-Agent", HeaderValue::from_static("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36"));
    req.headers_mut().insert(
        "Cookie",
        HeaderValue::from_str(&format!("myrandom_cookie={}", current_time)).unwrap(),
    );

    let json: Root = fetch_json(req).await.map_err(|e| e.to_string())?;

    // round to the nearest 3 decimal places
    let price = (json.data.statistics.price * 100.0).round() / 100.0;
    // timestamp is 2025-04-30T19:59:44.161Z, becomes 2025-04-30T19:59:44
    let timestamp = json.status.timestamp.split('.').next().unwrap_or("");

    Ok(PriceFeedData { symbol: json.data.symbol, price, timestamp: timestamp.to_string() })
}

/// Represents the price feed response data structure
/// This is the simplified version of the data that will be sent to the blockchain
/// via the Submission of the operator(s).
#[derive(Debug, Serialize, Deserialize)]
pub struct PriceFeedData {
    symbol: String,
    timestamp: String,
    price: f64,
}

/// Root response structure from CoinMarketCap API
/// Generated from the API response using <https://transform.tools/json-to-rust-serde>
/// Contains detailed cryptocurrency information including price statistics
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Root {
    pub data: Data,
    pub status: Status,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Data {
    pub id: f64,
    pub name: String,
    pub symbol: String,
    pub statistics: Statistics,
    pub description: String,
    pub category: String,
    pub slug: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Statistics {
    pub price: f64,
    #[serde(rename = "totalSupply")]
    pub total_supply: f64,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CoinBitesVideo {
    pub id: String,
    pub category: String,
    #[serde(rename = "videoUrl")]
    pub video_url: String,
    pub title: String,
    pub description: String,
    #[serde(rename = "previewImage")]
    pub preview_image: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Status {
    pub timestamp: String,
    pub error_code: String,
    pub error_message: String,
    pub elapsed: String,
    pub credit_count: f64,
}
````

## File: components/evm-price-oracle/src/trigger.rs
````rust
use crate::bindings::wavs::worker::layer_types::{
    TriggerData, TriggerDataEvmContractEvent, WasmResponse,
};
use alloy_sol_types::SolValue;
use anyhow::Result;
use wavs_wasi_utils::decode_event_log_data;

/// Represents the destination where the trigger output should be sent
///
/// # Variants
/// - `Ethereum`: Output will be ABI encoded and sent to an Ethereum contract
/// - `CliOutput`: Raw output for local testing/debugging
/// Note: Cosmos destination is also possible but not implemented in this example
pub enum Destination {
    Ethereum,
    CliOutput,
}

/// Decodes incoming trigger event data into its components
///
/// # Arguments
/// * `trigger_data` - The raw trigger data received from WAVS
///
/// # Returns
/// A tuple containing:
/// * `u64` - Trigger ID for tracking the request
/// * `Vec<u8>` - The actual data payload
/// * `Destination` - Where the processed result should be sent
///
/// # Implementation Details
/// Handles two types of triggers:
/// 1. EvmContractEvent - Decodes Ethereum event logs using the NewTrigger ABI
/// 2. Raw - Used for direct CLI testing with no encoding
pub fn decode_trigger_event(trigger_data: TriggerData) -> Result<(u64, Vec<u8>, Destination)> {
    match trigger_data {
        TriggerData::EvmContractEvent(TriggerDataEvmContractEvent { log, .. }) => {
            let event: solidity::NewTrigger = decode_event_log_data!(log)?;
            let trigger_info =
                <solidity::TriggerInfo as SolValue>::abi_decode(&event._triggerInfo)?;
            Ok((trigger_info.triggerId, trigger_info.data.to_vec(), Destination::Ethereum))
        }
        TriggerData::Raw(data) => Ok((0, data.clone(), Destination::CliOutput)),
        _ => Err(anyhow::anyhow!("Unsupported trigger data type")),
    }
}

/// Encodes the output data for submission back to Ethereum
///
/// # Arguments
/// * `trigger_id` - The ID of the original trigger request
/// * `output` - The data to be encoded, must implement AsRef<[u8]>
///
/// # Returns
/// ABI encoded bytes ready for submission to Ethereum
pub fn encode_trigger_output(trigger_id: u64, output: impl AsRef<[u8]>) -> WasmResponse {
    WasmResponse {
        payload: solidity::DataWithId {
            triggerId: trigger_id,
            data: output.as_ref().to_vec().into(),
        }
        .abi_encode(),
        ordering: None,
    }
}

/// Private module containing Solidity type definitions
///
/// The `sol!` macro from alloy_sol_macro reads a Solidity interface file
/// and generates corresponding Rust types and encoding/decoding functions.
///
/// In this case, it reads "../../src/interfaces/ITypes.sol" which defines:
/// - NewTrigger event
/// - TriggerInfo struct
/// - DataWithId struct
///
/// Documentation:
/// - <https://docs.rs/alloy-sol-macro/latest/alloy_sol_macro/macro.sol.html>
/// (You can also just sol! arbitrary solidity types like `event` or `struct` too)
pub mod solidity {
    use alloy_sol_macro::sol;
    pub use ITypes::*;

    // The objects here will be generated automatically into Rust types.
    // If you update the .sol file, you must re-run `cargo build` to see the changes.
    sol!("../../src/interfaces/ITypes.sol");

    // Define a simple struct representing the function that encodes string input
    sol! {
        function addTrigger(string data) external;
    }
}
````

## File: components/evm-price-oracle/Cargo.toml
````toml
[package]
name = "evm-price-oracle"
edition.workspace = true
version.workspace = true
authors.workspace = true
rust-version.workspace = true
repository.workspace = true

[dependencies]
wit-bindgen-rt ={ workspace = true }
wavs-wasi-utils = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
alloy-sol-macro = { workspace = true }
wstd = { workspace = true }
alloy-sol-types = { workspace = true }
anyhow = { workspace = true }

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "s"
debug = false
strip = true
lto = true

[package.metadata.component]
package = "component:evm-price-oracle"
target = "wavs:worker/layer-trigger-world@0.4.0"
````

## File: components/evm-price-oracle/config.json
````json
{
  "__tool": "github.com/reecepbcups/docci",
  "paths": [
    "README.md",
    "docs/tutorial"
  ],
  "env_vars": {},
  "pre_cmds": [],
  "log_level": "ERROR",
  "cleanup_cmds": [
    "killall anvil || true",
    "docker compose rm --stop --force --volumes || true"
  ]
}
````

## File: components/evm-price-oracle/Makefile
````
OUTPUT_DIR?=../../compiled


## wasi-build: building the WAVS wasi component(s)
wasi-build:
	@echo "Building component: evm-price-oracle"
	@cargo component build --release; cargo fmt
	@mkdir -p $(OUTPUT_DIR)
	@cp ../../target/wasm32-wasip1/release/*.wasm $(OUTPUT_DIR)
.PHONY: wasi-build
````

## File: components/golang-evm-price-oracle/src/cmc.go
````go
package main

// Root represents the top-level JSON response from CoinMarketCap API
type Root struct {
	Status Status `json:"status"`
	Data   Data   `json:"data"`
}

// Status contains API response status information
type Status struct {
	Timestamp string `json:"timestamp"`
}

// Data contains cryptocurrency data
type Data struct {
	Symbol     string     `json:"symbol"`
	Statistics Statistics `json:"statistics"`
}

// Statistics contains price statistics
type Statistics struct {
	Price float64 `json:"price"`
}

// PriceFeedData is the output structure with essential price information
type PriceFeedData struct {
	Symbol    string  `json:"symbol"`
	Price     float64 `json:"price"`
	Timestamp string  `json:"timestamp"`
}
````

## File: components/golang-evm-price-oracle/src/main.go
````go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"math"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/Lay3rLabs/wavs-wasi/go/types"
	wavs "github.com/Lay3rLabs/wavs-wasi/go/wavs/worker/layer-trigger-world"
	trigger "github.com/Lay3rLabs/wavs-wasi/go/wavs/worker/layer-types"

	wasiclient "github.com/dev-wasm/dev-wasm-go/lib/http/client"
	"go.bytecodealliance.org/cm"
)

func init() {
	wavs.Exports.Run = func(triggerAction wavs.TriggerAction) types.TriggerResult {
		triggerID, requestInput, dest := decodeTriggerEvent(triggerAction.Data)

		result, err := compute(requestInput.Slice(), dest)
		if err != nil {
			return cm.Err[types.TriggerResult](err.Error())
		}
		fmt.Printf("Computation Result: %v
", string(result))

		return routeResult(triggerID, result, dest)
	}
}

// compute is the main function that computes the price of the crypto currency
func compute(input []uint8, dest types.Destination) ([]byte, error) {
	if dest == types.CliOutput {
		input = bytes.TrimRight(input, " ")
	}

	id, err := strconv.Atoi(string(input))
	if err != nil {
		return nil, fmt.Errorf("failed to parse input: %w", err)
	}

	priceFeed, err := fetchCryptoPrice(id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch price: %w", err)
	}

	priceJson, err := json.Marshal(priceFeed)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal JSON: %w", err)
	}

	return priceJson, nil
}

// routeResult sends the computation result to the appropriate destination
func routeResult(triggerID uint64, result []byte, dest types.Destination) types.TriggerResult {
	switch dest {
	case types.CliOutput:
		return types.Ok(result, cm.None[uint64]())
	case types.Ethereum:
		// WAVS & the contract expects abi encoded data
		encoded := types.EncodeTriggerOutput(triggerID, result)
		fmt.Printf("Encoded output (raw): %x
", encoded)
		return types.Ok(encoded, cm.None[uint64]())
	default:
		return cm.Err[types.TriggerResult](fmt.Sprintf("unsupported destination: %s", dest))
	}
}

// decodeTriggerEvent is the function that decodes the trigger event from the chain event to Go.
func decodeTriggerEvent(triggerAction trigger.TriggerData) (trigger_id uint64, req cm.List[uint8], dest types.Destination) {
	// Handle CLI input case
	if triggerAction.Raw() != nil {
		raw := *triggerAction.Raw()
		fmt.Printf("Raw input: %s
", string(raw.Slice()))
		return 0, raw, types.CliOutput
	}

	// Handle Ethereum event case
	ethEvent := triggerAction.EvmContractEvent()
	if ethEvent == nil {
		panic("triggerAction.EthContractEvent() is nil")
	}

	// if you modify the contract trigger from the default event, you will need to create a custom `DecodeTriggerInfo` function
	// to match the solidity contract data types.
	triggerInfo := types.DecodeTriggerInfo(ethEvent.Log.Data.Slice())

	fmt.Printf("Trigger ID: %v
", triggerInfo.TriggerID)
	fmt.Printf("Creator: %s
", triggerInfo.Creator.String())
	fmt.Printf("Input Data: %v
", string(triggerInfo.Data))

	return triggerInfo.TriggerID, cm.NewList(&triggerInfo.Data[0], len(triggerInfo.Data)), types.Ethereum
}

// fetchCryptoPrice fetches the price of the crypto currency from the CoinMarketCap API by their ID.
func fetchCryptoPrice(id int) (*PriceFeedData, error) {
	// Create a new HTTP client with WASI transport
	client := &http.Client{
		Transport: wasiclient.WasiRoundTripper{},
	}

	// Prepare the URL
	url := fmt.Sprintf("https://api.coinmarketcap.com/data-api/v3/cryptocurrency/detail?id=%d&range=1h", id)

	// Create a new HTTP request
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	// Set the headers
	currentTime := time.Now().Unix()
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("User-Agent", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36")
	req.Header.Set("Cookie", fmt.Sprintf("myrandom_cookie=%d", currentTime))

	// Make the request
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// Read and parse the response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// Parse the JSON
	var root Root
	if err := json.Unmarshal(body, &root); err != nil {
		return nil, err
	}

	// round to 2 decimal places
	price := math.Round(root.Data.Statistics.Price*100) / 100

	// timestamp is 2025-04-30T19:59:44.161Z, becomes 2025-04-30T19:59:44
	timestamp := strings.Split(root.Status.Timestamp, ".")[0]

	return &PriceFeedData{
		Symbol:    root.Data.Symbol,
		Price:     price,
		Timestamp: timestamp,
	}, nil
}

// empty main function to satisfy wasm-ld (wit)
func main() {}
````

## File: components/golang-evm-price-oracle/config.json
````json
{
    "__tool": "github.com/reecepbcups/docci",
    "paths": [
      "components/golang-evm-price-oracle/README.md"
    ],
    "env_vars": {},
    "pre_cmds": [],
    "log_level": "ERROR",
    "cleanup_cmds": [
      "killall anvil || true",
      "docker compose rm --stop --force --volumes || true",
      "docker rm -f wavs wavs-aggregator wavs-deploy-service-manager wavs-deploy-eigenlayer || true"
    ]
  }
````

## File: components/golang-evm-price-oracle/go.mod
````
module github.com/Lay3rLabs/wavs-foundry-template/components/golang-evm-price-oracle

go 1.24.3

replace (
	// fix: tinygo >0.35 support
	github.com/defiweb/go-eth => github.com/Reecepbcups/go-eth v0.7.1
	// fix: assignment mismatch: 3 variables but rlp.Decode returns 2 values
	github.com/defiweb/go-rlp => github.com/defiweb/go-rlp v0.3.0
	// namespace import fix
	github.com/dev-wasm/dev-wasm-go/lib => github.com/Reecepbcups/dev-wasm-go/lib v1.0.0
)

require (
	github.com/Lay3rLabs/wavs-wasi/go v0.4.0
	github.com/dev-wasm/dev-wasm-go/lib v0.0.0-20240907000152-b653306ed695
	go.bytecodealliance.org/cm v0.2.2
)

require (
	github.com/btcsuite/btcd/btcec/v2 v2.3.2 // indirect
	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 // indirect
	github.com/defiweb/go-anymapper v0.3.0 // indirect
	github.com/defiweb/go-eth v0.7.0 // indirect
	github.com/defiweb/go-rlp v0.3.0 // indirect
	github.com/defiweb/go-sigparser v0.6.0 // indirect
	github.com/stretchr/testify v1.10.0 // indirect
	golang.org/x/crypto v0.36.0 // indirect
	golang.org/x/sys v0.31.0 // indirect
)
````

## File: components/golang-evm-price-oracle/Makefile
````
WAVS_PACKAGE=wavs:worker@0.4.0
WAVS_WIT_WORLD=wavs:worker/layer-trigger-world
# get the first line of the go.mod and get the last element after the last /, then replace - with _
GO_MOD_NAME?=$(shell head -n 1 go.mod | cut -d' ' -f2 | rev | cut -d'/' -f1 | rev | tr '-' '_')

OUTPUT_DIR?=../../compiled

check-package:
	@if [ ! -f $(WAVS_PACKAGE).wasm ]; then \
		echo "Downloading WAVS package: $(WAVS_PACKAGE)"; \
		wkg get ${WAVS_PACKAGE} --overwrite --format wasm --output ${WAVS_PACKAGE}.wasm; \
	fi

## wasi-build: building the WAVS wasi component
wasi-build: check-package
	@echo "Building component: $(GO_MOD_NAME) [takes a few seconds...]"
	@go mod tidy
	@mkdir -p $(OUTPUT_DIR)
	@tinygo build -target=wasip2 -o $(OUTPUT_DIR)/$(GO_MOD_NAME).wasm --wit-package $(WAVS_PACKAGE).wasm --wit-world $(WAVS_WIT_WORLD) ./src
	@echo "WASI component built: $(GO_MOD_NAME).wasm"
.PHONY: wasi-build

.PHONY: help
help: Makefile
	@echo
	@echo " Choose a command run"
	@echo
	@sed -n 's/^##//p' $< | column -t -s ':' |  sed -e 's/^/ /'
	@echo
````

## File: components/golang-evm-price-oracle/README.md
````markdown
# Golang Ethereum Price Oracle

A WAVS component that fetches the price of a crypto currency from CoinMarketCap and returns it to the Ethereum contract, in Go.

## System Setup

### Mac

```bash docci-os=mac
brew tap tinygo-org/tools
brew install tinygo
```

### Arch Linux

```bash docci-ignore
sudo pacman -Sy tinygo
```

### Ubuntu Linux

```bash docci-os=linux docci-if-not-installed="tinygo"
# https://tinygo.org/getting-started/install/linux/
wget --quiet https://github.com/tinygo-org/tinygo/releases/download/v0.37.0/tinygo_0.37.0_amd64.deb
sudo dpkg -i tinygo_0.37.0_amd64.deb && rm tinygo_0.37.0_amd64.deb
```

## Core Packages

```bash docci-if-not-installed="cast"
curl -L https://foundry.paradigm.xyz | bash && $HOME/.foundry/bin/foundryup
```

```bash
make setup
```

```bash docci-if-not-installed="cargo-binstall"
cargo install cargo-binstall
```

```bash docci-if-not-installed="wasm-tools"
cargo binstall wasm-tools --no-confirm
```

<!-- matches the value in the wavs-wasi for generation of the bindings -->
```bash occi-if-not-installed="wit-bindgen-go"
go install go.bytecodealliance.org/cmd/wit-bindgen-go@ecfa620df5beee882fb7be0740959e5dfce9ae26
wit-bindgen-go --version
```

## Verify installs

```bash
tinygo version
wkg --version
```

## Build Component

Build all wasi components from the root of the repo. You can also run this command within each component directory.

```bash
# Builds only this component, not all.
WASI_BUILD_DIR=golang-evm-price-oracle make wasi-build
```

## Execute Component

Run the component with the `wasi-exec` command in the root of the repo

```bash docci-output-contains="LTC"
COMPONENT_FILENAME=golang_evm_price_oracle.wasm INPUT_DATA=2 make wasi-exec-fixed
```

---

## Run main README

Run through the main readme, but use `export COMPONENT_FILENAME=golang_evm_price_oracle.wasm` instead of the default.
````

## File: components/golang-evm-price-oracle/wkg.lock
````
# This file is automatically generated.
# It is not intended for manual editing.
version = 1

[[packages]]
name = "wasi:cli"
registry = "wa.dev"

[[packages.versions]]
requirement = "=0.2.0"
version = "0.2.0"
digest = "sha256:e7e85458e11caf76554b724ebf4f113259decf0f3b1ee2e2930de096f72114a7"
````

## File: components/js-evm-price-oracle/config.json
````json
{
    "__tool": "github.com/reecepbcups/docci",
    "paths": [
      "components/js-evm-price-oracle/README.md"
    ],
    "env_vars": {},
    "pre_cmds": [],
    "log_level": "ERROR",
    "cleanup_cmds": [
      "killall anvil || true",
      "docker compose rm --stop --force --volumes || true",
      "docker rm -f wavs wavs-aggregator wavs-deploy-service-manager wavs-deploy-eigenlayer || true"
    ]
  }
````

## File: components/js-evm-price-oracle/index.ts
````typescript
import { TriggerAction, WasmResponse,  } from "./out/wavs:worker@0.4.0";
import { TriggerSource, TriggerSourceManual } from "./out/interfaces/wavs-worker-layer-types";
import { decodeTriggerEvent, encodeOutput, Destination } from "./trigger";
import { AbiCoder } from "ethers";

async function run(triggerAction: TriggerAction): Promise<WasmResponse> {
  let event = decodeTriggerEvent(triggerAction.data);
  let triggerId = event[0].triggerId;

  let num = processInput(event[0].data, triggerAction.config.triggerSource);
  let result = await compute(num);

  switch (event[1]) {
    case Destination.Cli:
      return {
        payload: result,
        ordering: undefined,
      } as WasmResponse; // return raw bytes back
    case Destination.Ethereum:
      return {
        payload: encodeOutput(triggerId, result),
        ordering: undefined,
      } as WasmResponse; // return encoded bytes back
    case Destination.Cosmos:
      break;
  }

  throw new Error(
    "Unknown destination: " + event[1] + " for trigger ID: " + triggerId
  );
}

async function compute(num: number): Promise<Uint8Array> {
  const priceFeed = await fetchCryptoPrice(num);
  const priceJson = priceFeedToJson(priceFeed);

  return new TextEncoder().encode(priceJson);
}

function processInput(input: Uint8Array, triggerSource: { tag: string }): number {
  // Prepare the input data based on trigger type
  const processedInput = prepareInputData(input, triggerSource.tag);

  // Single ABI decoding step
  const abiCoder = new AbiCoder();
  const res = abiCoder.decode(["string"], processedInput);
  const decodedString = res[0] as string;

  console.log("Decoded input:", decodedString, "triggerSource.tag:", triggerSource.tag);

  // Validate the decoded string is a valid number
  const num = decodedString.trim();
  if (isNaN(parseInt(num))) {
    throw new Error(`Input is not a valid number: ${num}`);
  }

  return parseInt(num); // Return the validated number
}


function prepareInputData(input: Uint8Array, triggerTag: string): Uint8Array {
  if (triggerTag === "manual") {
    return input; // Use input directly for manual triggers
  }

  // For evm-contract-event: handle potential hex string conversion
  try {
    const inputStr = new TextDecoder().decode(input);
    if (!inputStr.startsWith("0x")) {
      throw new Error("Input is not a valid hex string: " + inputStr);
    }

    // Convert hex string to bytes
    const hexString = inputStr.slice(2); // Remove "0x" prefix
    return new Uint8Array(
      hexString.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16))
    );
  } catch {
    return input; // If UTF-8 decode fails, assume it's already binary
  }
}

// ======================== CMC ========================

// Define the types for the CMC API response
interface Root {
  status: Status;
  data: Data;
}

interface Status {
  timestamp: string;
}

interface Data {
  symbol: string;
  statistics: Statistics;
}

interface Statistics {
  price: number;
}

// Output structure with essential price information
interface PriceFeedData {
  symbol: string;
  price: number;
  timestamp: string;
}

/**
 * Fetches the price of a cryptocurrency from the CoinMarketCap API by their ID.
 * @param id The CoinMarketCap ID of the cryptocurrency
 * @returns A Promise that resolves to PriceFeedData
 */
async function fetchCryptoPrice(id: number): Promise<PriceFeedData> {
  // Prepare the URL
  const url = `https://api.coinmarketcap.com/data-api/v3/cryptocurrency/detail?id=${id}&range=1h`;

  // Set the headers
  const currentTime = Math.floor(Date.now() / 1000);
  const headers = {
    Accept: "application/json",
    "Content-Type": "application/json",
    "User-Agent":
      "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36",
    Cookie: `myrandom_cookie=${currentTime}`,
  };

  try {
    // Make the request
    const response = await fetch(url, {
      method: "GET",
      headers,
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    // Parse the JSON response
    const root: Root = await response.json();

    // round to 2 decimal places on root.data.statistics.price
    let price = Math.round(root.data.statistics.price * 100) / 100;

    // timestamp is 2025-04-30T19:59:44.161Z, becomes 2025-04-30T19:59:44
    let timestamp = root.status.timestamp.split(".")[0];

    return {
      symbol: root.data.symbol,
      price: price,
      timestamp: timestamp,
    };
  } catch (error) {
    throw new Error(
      `Failed to fetch crypto price: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

// Example of how to convert the PriceFeedData to JSON
function priceFeedToJson(priceFeed: PriceFeedData): string {
  try {
    return JSON.stringify(priceFeed);
  } catch (error) {
    throw new Error(
      `Failed to marshal JSON: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

export { run };
````

## File: components/js-evm-price-oracle/Makefile
````
WAVS_PACKAGE=wavs:worker@0.4.0
WAVS_WIT_WORLD=wavs:worker/layer-trigger-world
OUTPUT_DIR?=../../compiled

check-package:
	@if [ ! -f $(WAVS_PACKAGE).wasm ]; then \
		echo "Downloading WAVS package: $(WAVS_PACKAGE)"; \
		wkg get ${WAVS_PACKAGE} --overwrite --format wasm --output $(WAVS_PACKAGE).wasm; \
	fi

# if @bytecodealliance/jco is not installed, then run npm i here
check-jco:
	@npx jco --version || npm i

# converts the entire .wasm package into a single .wit file, easily consumable by the jco command
convert-wasm-to-wit:
	@wasm-tools component wit $(WAVS_PACKAGE).wasm -o $(WAVS_PACKAGE).wit

## build-bindings: building the WAVS bindings
build-bindings: check-jco check-package
	@npx jco types $(WAVS_PACKAGE).wasm --out-dir out/

## wasi-build: building the WAVS wasi component
wasi-build: check-jco build-bindings convert-wasm-to-wit
	@echo "Building component: js_evm_price_oracle"
	@npx tsc --outDir out/ --target es6 --strict --module preserve index.ts
	@npx esbuild ./index.js --bundle --outfile=out/out.js --platform=node --format=esm
	@npx jco componentize out/out.js --wit $(WAVS_PACKAGE).wit --world-name $(WAVS_WIT_WORLD) --out ../../compiled/js_evm_price_oracle.wasm

.PHONY: help
help: Makefile
	@echo
	@echo " Choose a command run"
	@echo
	@sed -n 's/^##//p' $< | column -t -s ':' |  sed -e 's/^/ /'
	@echo
````

## File: components/js-evm-price-oracle/package.json
````json
{
    "name": "js-evm-price-oracle",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "type": "module",
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "author": "Reece Williams <reecepbcups@gmail.com>",
    "license": "ISC",
    "devDependencies": {
        "@bytecodealliance/componentize-js": "^0.18.0",
        "@bytecodealliance/jco": "^1.10.2",
        "esbuild": "^0.25.0",
        "ethers": "^6.13.5"
    }
}
````

## File: components/js-evm-price-oracle/README.md
````markdown
# Typescript Ethereum Price Oracle

A WAVS component that fetches the price of a crypto currency from CoinMarketCap and returns it to the Ethereum contract, in Typescript.

## System Setup

Follow the main [README.md](../../README.md) to install all the necessary dependencies.

## Core Packages

```bash docci-if-not-installed="cast"
curl -L https://foundry.paradigm.xyz | bash && $HOME/.foundry/bin/foundryup
```

```bash docci-if-not-installed="wasm-tools"
cargo binstall wasm-tools --no-confirm
```

```bash
make setup
```

```bash
npm --prefix ./components/js-evm-price-oracle/ install
```

## Build Component

Build all wasi components from the root of the repo. You can also run this command within each component directory.

```bash docci-output-contains="Successfully written"
# Builds only this component, not all.
warg reset
WASI_BUILD_DIR=js-evm-price-oracle make wasi-build
```

## Execute Component

Run the component with the `wasi-exec` command in the root of the repo

```bash docci-output-contains="LTC"
COMPONENT_FILENAME=js_evm_price_oracle.wasm INPUT_DATA=2 make wasi-exec
```

---

## Run main README

Run through the main readme, but use `export COMPONENT_FILENAME=js_evm_price_oracle.wasm` instead of the default.
````

## File: components/js-evm-price-oracle/trigger.ts
````typescript
import { TriggerData } from "./out/interfaces/wavs-worker-layer-types";
import { getBytes, hexlify, Interface } from "ethers";
import { AbiCoder } from "ethers";

enum Destination {
  Cli = "Cli",
  Ethereum = "Ethereum",
  Cosmos = "Cosmos",
}

// === Contract Types ===
type TriggerInfoType = {
  triggerId: number;
  creator: string;
  data: Uint8Array;
};

// ITypes.sol Types
const DataWithId = "tuple(uint64 triggerId, bytes data)";
const TriggerInfo = "tuple(uint64 triggerId, address creator, bytes data)";
const EventName = "NewTrigger";
const eventInterface = new Interface([
  `event ${EventName}(bytes _triggerInfo)`,
]);

function encodeOutput(triggerId: number, outputData: Uint8Array): Uint8Array {
  try {
    const encoded = new AbiCoder().encode(
      [DataWithId],
      [
        {
          triggerId: triggerId,
          data: outputData,
        },
      ]
    );

    // Convert the hex string back to Uint8Array
    return getBytes(encoded);
  } catch (error) {
    console.error("Error encoding output:", error);
    // Return a simple fallback if encoding fails
    return new Uint8Array([0]);
  }
}

function decodeTriggerEvent(
  triggerAction: TriggerData
): [TriggerInfoType, Destination] {
  if (triggerAction.tag === "raw") {
    return [
      {
        triggerId: 0,
        data: triggerAction.val,
        creator: "",
      },
      Destination.Cli,
    ];
  }

  if (triggerAction.tag === "evm-contract-event") {
    const ethContractEvent = triggerAction.val;

    try {
      const topics = ethContractEvent.log.topics.map((t) => hexlify(t));
      // Decode the NewTrigger event to get the encoded _triggerInfo bytes
      const decodedEvent = eventInterface.decodeEventLog(
        EventName,
        ethContractEvent.log.data,
        topics
      );

      // One-step decoding of the TriggerInfo struct
      const [triggerInfo] = new AbiCoder().decode(
        [TriggerInfo],
        decodedEvent._triggerInfo
      );

      return [
        {
          triggerId: Number(triggerInfo.triggerId),
          creator: triggerInfo.creator,
          data: getBytes(triggerInfo.data),
        },
        Destination.Ethereum,
      ];
    } catch (error) {
      throw new Error("Error processing eth contract event: " + error);
    }
  }

  throw new Error(
    "Unknown triggerAction type or not supported: " + triggerAction.tag
  );
}

export { decodeTriggerEvent, encodeOutput, Destination };
````

## File: docs/handbook/components/blockchain-interactions.mdx
````
---
title: Blockchain interactions
description: Interacting with blockchains from WAVS components
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

Components can interact with blockchains and smart contracts by using crates like [`wavs-wasi-utils`](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/). This page provides an overview of the dependencies and configuration needed to interact with Ethereum and other EVM-compatible chains.

### `wavs-wasi-utils` crate

The `wavs-wasi-utils` crate provides a set of helpful functions for making HTTP requests and interacting with the blockchain. It also provides a macro for decoding trigger data for use in the component.

Learn more in the [crate documentation](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/index.html).

The `decode_event_log_data` macro is a utility for decoding Ethereum event logs from triggers into typed Rust events. It takes raw log data (topics and data) from the WAVS worker bindings and converts it into a Rust type that implements `SolEvent`.

## Dependencies

The following dependencies are commonly required in your component's `Cargo.toml` for Ethereum interactions:

```toml
[dependencies]
# Core WAVS blockchain functionality
wit-bindgen-rt = { workspace = true, features = ["bitflags"] }  # Required for WASI bindings
wavs-wasi-utils = "0.4.0"                                # Blockchain interaction utilities
wstd = "0.5.3"                                                  # WASI standard library

# Alloy crates for Ethereum interaction
alloy-sol-macro = { version = "1.1.0", features = ["json"] }    # sol! macro for interfaces
alloy-sol-types = "1.1.0"                                       # ABI handling & type generation
alloy-network = "0.15.10"                                       # Network trait and Ethereum network type
alloy-provider = { version = "0.15.10", default-features = false, features = ["rpc-api"] }  # RPC provider
alloy-rpc-types = "0.15.10"                                     # RPC type definitions
alloy-contract = "0.15.10"                                      # Contract interaction utilities

# Other useful crates
anyhow = "1.0.98"                                              # Error handling
serde = { version = "1.0.219", features = ["derive"] }         # Serialization/deserialization
serde_json = "1.0.140"                                         # JSON handling
```

Note: The `workspace = true` syntax can be used if your project is part of a workspace that defines these versions centrally. Otherwise, use the explicit versions shown above.

## Chain configuration

Chain configurations are defined in the root `wavs.toml` file. This allows components to access RPC endpoints and chain IDs without hardcoding them.

```toml wavs.toml
# Local / Testnet
[default.chains.evm.local]
chain_id = "31337"
ws_endpoint = "ws://localhost:8545"
http_endpoint = "http://localhost:8545"
poll_interval_ms = 7000

# Mainnet
[default.chains.evm.ethereum]
chain_id = "1"
ws_endpoint = "wss://eth.drpc.org"
http_endpoint = "https://eth.drpc.org"
```

### Sol! macro

The `sol!` macro from `alloy-sol-macro` allows you to generate Rust types from Solidity interface files.

You can write Solidity definitions (interfaces, structs, enums, custom errors, events, and function signatures) directly inside the `sol!` macro invocation in your Rust code.

At compile time, the `sol!` macro parses that Solidity syntax and automatically generates the equivalent Rust types, structs, enums, and associated functions (like `abi_encode()` for calls or `abi_decode()` for return data/events) needed to interact with smart contracts based on those definitions.

Required Dependencies:

```toml
[dependencies]
alloy-sol-macro = { workspace = true }  # For Solidity type generation
alloy-sol-types = { workspace = true }  # For ABI handling
```

Basic Pattern:

```rust
mod solidity {
    use alloy_sol_macro::sol;

    // Generate types from Solidity file
    sol!("../../src/interfaces/ITypes.sol");

    // Or define types inline
    sol! {
        struct TriggerInfo {
            uint64 triggerId;
            bytes data;
        }

        event NewTrigger(TriggerInfo _triggerInfo);
    }
}
```

In the template, the `sol!` macro is used in the `trigger.rs` component file to generate Rust types from the `ITypes.sol` file.

```rust trigger.rs
pub mod solidity {
    use alloy_sol_macro::sol;
    pub use ITypes::*;

    // The objects here will be generated automatically into Rust types.
    // If you update the .sol file, you must re-run `cargo build` to see the changes.
    sol!("../../src/interfaces/ITypes.sol");

    // Define a simple struct representing the function that encodes string input
    sol! {
        function addTrigger(string data) external;
    }
}
```

The macro reads a Solidity interface file and generates corresponding Rust types and encoding/decoding functions. In the example above, it reads `ITypes.sol` which defines:
- `NewTrigger` event
- `TriggerInfo` struct
- `DataWithId` struct

More documentation on the `sol!` macro can be found at: https://docs.rs/alloy-sol-macro/latest/alloy_sol_macro/macro.sol.html


## Accessing configuration and provider

WAVS provides host bindings to get the chain config for a given chain name in the wavs.toml file. The `new_evm_provider` from [`wavs-wasi-utils`](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/evm/fn.new_evm_provider.html) can be used to create a provider for a given chain.

```rust lib.rs
use crate::bindings::host::get_evm_chain_config;
use alloy_network::Ethereum;
use alloy_provider::RootProvider;
use wavs_wasi_utils::evm::new_evm_provider;

// Get the chain config for a specific chain defined in wavs.toml
let chain_config = get_evm_chain_config("local").unwrap();

// Create an Alloy provider instance using the HTTP endpoint
let provider: RootProvider<Ethereum> = new_evm_provider::<Ethereum>(
    chain_config.http_endpoint.unwrap(),
);
```

## Example: Querying NFT balance

Here's an [example](https://github.com/Lay3rLabs/wavs-art/blob/main/components/autonomous-artist/src/evm.rs) demonstrating how to query the balance of an ERC721 NFT contract for a given owner address:

```rust lib.rs
// Import required dependencies
use crate::bindings::host::get_evm_chain_config;  // WAVS host binding to get chain configuration
use alloy_network::Ethereum;                      // Ethereum network type
use alloy_provider::RootProvider;                 // Provider for making RPC calls
use alloy_sol_types::sol;                         // Macro for generating Solidity bindings
use wavs_wasi_utils::evm::{                      // WAVS utilities for EVM interaction
    alloy_primitives::{Address, U256},           // Ethereum primitive types
    new_evm_provider,                            // Function to create EVM provider
};
use alloy_rpc_types::TransactionInput;
use wstd::runtime::block_on;                      // Utility to run async code in sync context

// Define the ERC721 interface using the sol! macro
// This generates Rust types and functions for interacting with the contract
sol! {
    interface IERC721 {
        // Define the balanceOf function that returns how many NFTs an address owns
        function balanceOf(address owner) external view returns (uint256);
    }
}
// Function to check if an address owns any NFTs from a specific contract
pub fn query_nft_ownership(address: Address, nft_contract: Address) -> Result<bool, String> {
    // block_on allows us to run async code in a synchronous function
    block_on(async move {
        // Get the chain configuration for the local network
        let chain_config = get_evm_chain_config("local").unwrap();
        // Create a provider that will handle RPC communication
        let provider: RootProvider<Ethereum> = new_evm_provider::<Ethereum>(
            chain_config.http_endpoint.unwrap()
        );

        // Create a contract instance using the generated IERC721 interface
        let balance_call = IERC721::balanceOf { owner: address };

        let tx = alloy_rpc_types::eth::TransactionRequest {
            to: Some(TxKind::Call(nft_contract)),
            input: TransactionInput { input: Some(balance_call.abi_encode().into()), data: None },
            ..Default::default()
        };

        // Call the balanceOf function on the contract
        // .call() executes the function as a view call (no state changes)
        let result = provider.call(tx).await.map_err(|e| e.to_string())?;

        // Return true if the address owns at least one NFT (balance > 0)
        let balance: U256 = U256::from_be_slice(&result);
        Ok(balance > U256::ZERO)
    })
}
```

You can also use the `alloy-contract` crate to interact with smart contracts. See the [alloy-contract docs](https://crates.io/crates/alloy-contract) page for more information.

See the [wavs-wasi-utils documentation](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/) and the [Alloy documentation](https://docs.rs/alloy/latest/alloy/) for more detailed information.


### Alloy ecosystem crates

The Alloy ecosystem provides a comprehensive set of crates for Ethereum development:

- [`alloy-primitives`](https://docs.rs/alloy-primitives/latest/alloy_primitives/): Core Ethereum types (`Address`, `U256`, `Bytes`, etc.)
- [`alloy-provider`](https://docs.rs/alloy-provider/latest/alloy_provider/): Ethereum node interaction (RPC, WebSocket, batching)
- [`alloy-network`](https://docs.rs/alloy-network/latest/alloy_network/): Network types and chain-specific functionality
- [`alloy-sol-types`](https://docs.rs/alloy-sol-types/latest/alloy_sol_types/): ABI handling and type generation
- [`alloy-contract`](https://docs.rs/alloy-contract/latest/alloy_contract/): Contract interaction utilities

### Utility crates

Essential utility crates for WAVS components:

- [`wstd`](https://docs.rs/wstd/latest/wstd/): WASI standard library with `block_on` for async operations
- [`serde`](https://docs.rs/serde/latest/serde/)/[`serde_json`](https://docs.rs/serde_json/latest/serde_json/): Data serialization and JSON handling
- [`anyhow`](https://docs.rs/anyhow/latest/anyhow/): Error handling and propagation
````

## File: docs/handbook/components/component.mdx
````
---
title: Component overview
description: Understanding WAVS service components and their structure
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

Service components contain the main business logic of a WAVS service.

## Component languages

WAVS enables developers to write components in different programming languages. These languages are compiled to WebAssembly (WASM) bytecode where they can be executed off-chain in the WAVS runtime.

The examples in this documentation are mainly written in Rust, but there are also examples of components written in the following languages:

-  [Go example](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/components/golang-evm-price-oracle)
-  [Typescript / JS example](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/components/js-evm-price-oracle)

## Component structure

A basic component has three main parts:

- Decoding incoming [trigger data](../triggers#trigger-lifecycle).
- Processing the data (this is the custom business logic of your component).
- Encoding and returning the result for submission (if applicable).

### Trigger inputs

When building WASI components, keep in mind that components can receive the [trigger data](../triggers#trigger-lifecycle) in two ways:

1. **On-chain events**: When triggered by an EVM event, the data comes through the `TriggerAction` with `TriggerData::EvmContractEvent`.

2. **Local testing**: When using `make wasi-exec` command in the template to test a component, the data comes through `TriggerData::Raw`.

Here's how the example component handles both cases in `trigger.rs`:

```rust
// In trigger.rs

pub fn decode_trigger_event(trigger_data: TriggerData) -> Result<(u64, Vec<u8>, Destination)> {
    match trigger_data {
        // On-chain Event
        // - Receive a log that needs to be decoded using the contract's ABI
        // - Decode into our Solidity types generated by the sol! macro from the Solidity interface
        TriggerData::EvmContractEvent(TriggerDataEvmContractEvent { log, .. }) => {
            // Decode Ethereum event logs using the `decode_event_log_data!` macro
            let event: solidity::NewTrigger = decode_event_log_data!(log)?;
            let trigger_info =
                <solidity::TriggerInfo as SolValue>::abi_decode(&event._triggerInfo)?;
            Ok((trigger_info.triggerId, trigger_info.data.to_vec(), Destination::Ethereum))
        }
        // Local Testing (wasi-exec)
        // - Receive raw bytes directly
        // - No ABI decoding is needed
        TriggerData::Raw(data) => Ok((0, data.clone(), Destination::CliOutput)),
        _ => Err(anyhow::anyhow!("Unsupported trigger data type")),
    }
}


pub mod solidity { // Define the Solidity types for the incoming trigger event using the `sol!` macro
    use alloy_sol_macro::sol;
    pub use ITypes::*;

    // The objects here will be generated automatically into Rust types.
    // the interface shown here is used in the example trigger contract in the template.
    sol!("../../src/interfaces/ITypes.sol");

    // The addTrigger function from the trigger contract
    sol! {
        function addTrigger(string data) external;
    }
}
```

The component decodes the incoming event trigger data using the `decode_event_log_data!` macro from the [`wavs-wasi-utils` crate](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/macro.decode_event_log_data.html).

The `sol!` macro from `alloy-sol-macro` is used to define Solidity types in Rust. This macro reads a Solidity interface file and generates corresponding Rust types and encoding/decoding functions. For more information, visit the [Blockchain interactions page](./blockchain-interactions#sol-macro).

### Component logic

Components must implement the `Guest` trait, which is the main interface between your component and the WAVS runtime.

The `run` function is the entry point for your business logic: it receives and decodes the trigger data, processes it according to your component's logic, and returns the results.


```rust
// In lib.rs
impl Guest for Component {
    fn run(action: TriggerAction) -> Result<Option<WasmResponse>, String> {
        // 1. Decode the trigger data using the decode_trigger_event function from trigger.rs
        let (trigger_id, req, dest) = decode_trigger_event(action.data)?;
        // 2. Process the data (your business logic)
        let res = block_on(async move {
            let resp_data = get_price_feed(id).await?;
            serde_json::to_vec(&resp_data)
        })?;

        // 3. Encode the output based on destination
        let output = match dest {
            // For on-chain submissions, the output is abi encoded using the encode_trigger_output function from trigger.rs
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
            // For local testing via wasi-exec, the output is returned as raw bytes
            Destination::CliOutput => Some(WasmResponse {
                payload: res.into(),
                ordering: None
            }),
        };
        Ok(output)
    }
}
```

Components can contain any compatible logic, including [blockchain interactions](./blockchain-interactions), [network requests](./network-requests), off-chain computations, and more. To learn about the types of components that WAVS is best suited for, visit the [design considerations](../../design) page.

#### Logging in a component

Components can use logging to debug and track the execution of the component.

**Logging in development**:

Use `println!()` to write to stdout/stderr. This is visible when running `make wasi-exec` locally in the template.

```rust lib.rs
println!("Debug message: {:?}", data);
```

**Logging in production**

For production, you can use a `host::log()` function which takes a `LogLevel` and writes its output via the tracing mechanism. Along with the string that the developer provides, it attaches additional context such as the `ServiceID`, `WorkflowID`, and component `Digest`.

```rust lib.rs
use bindings::host::{self, LogLevel};

host::log(LogLevel::Info, "Production logging message");
```

### Component output

After processing data in the `run` function, the component can encode the output data for submission back to Ethereum. In the template example, this is done using the `encode_trigger_output` function in the trigger.rs file.

```rust
/// Encodes the output data for submission back to Ethereum
pub fn encode_trigger_output(trigger_id: u64, output: impl AsRef<[u8]>) -> WasmResponse {
    WasmResponse {
        payload: solidity::DataWithId {
            triggerId: trigger_id,
            data: output.as_ref().to_vec().into(),
        }
        .abi_encode(),  // ABI encode the struct for blockchain submission
        ordering: None, // Optional ordering parameter for transaction sequencing
    }
}
```

Outputs for components are returned as a `WasmResponse` struct, which is a wrapper around the output data of the component for encoding and submission back to Ethereum. It contains a `payload` field that is the encoded output data and an optional `ordering` field that is used to order the transactions in the workflow. The `WasmResponse` is submitted to WAVS which routes it according to the workflow's submission logic.

## Component definition

A component is defined in the [workflow](../workflows) object of the [service.json](../service) file. Below is an example of the different fields that can be defined in the component object.

```json service.json
// ... other parts of the service manifest
//  "workflows": {
//   "workflow-example": {
//    "trigger": { ... }, the trigger for the workflow
        "component": { // the WASI component containing the business logic of the workflow
            "source": { // Where the component code comes from
            "Registry": {
                "registry": {
                "digest": "882b992af8f78e0aaceaf9609c7ba2ce80a22c521789c94ae1960c43a98295f5", // SHA-256 hash of the component's bytecode
                "domain": "localhost:8090",
                "version": "0.1.0",
                "package": "example:evmrustoracle"
                }
            }
        },
        "permissions": {  // What the component can access
            "allowed_http_hosts": "all",  // Can make HTTP requests to any host
            "file_system": true  // Can access the filesystem
        },
        "fuel_limit": null,  // Computational limits for the component
        "time_limit_seconds": 1800,  // Can run for up to 30 minutes
        "config": {  // Configuration variables passed to the component
            "variable_1": "0xb5d4D4a87Cb07f33b5FAd6736D8F1EE7D255d9E9",  // NFT contract address
            "variable_2": "0x34045B4b0cdfADf87B840bCF544161168c8ab85A"  // Reward token address
        },
        "env_keys": [  // Secret environment variables the component can access from .env
            "WAVS_ENV_API_KEY",  // secret API key with prefix WAVS_ENV_
        ]
    },
//    "submit": { ... } // submission logic for the workflow
// ... the rest of the service manifest
```

For more information on component configuration variables and keys, visit the [variables](./variables) page.

## Registry

WAVS uses a registry to store the WASM components. A service like [wa.dev](https://wa.dev) is recommended for proper distribution in production. A similar registry environment is emulated locally in docker compose for rapid development without an API key:

- Build your component
- Compile the component
- Upload the component to the registry
- Set the registry in your service using the wavs-cli command in the `build_service.sh` script:

`wavs-cli workflow component --id ${WORKFLOW_ID} set-source-registry --domain ${REGISTRY} --package ${PKG_NAMESPACE}:${PKG_NAME} --version ${PKG_VERSION}`
````

## File: docs/handbook/components/network-requests.mdx
````
---
title: Network requests
description: Making HTTP requests from WAVS components
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

Components can make network requests to external APIs using the [`wavs-wasi-utils` crate](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/index.html).

To learn how to use variables like API keys in a component, visit the [Variables page](./variables).

### Dependencies

The following dependencies are required for making HTTP requests from a component:

```toml Cargo.toml
[dependencies]
wavs-wasi-utils = "0.4.0"   # HTTP utilities
wstd = "0.5.3"                     # Runtime utilities (includes block_on)
serde = { version = "1.0.219", features = ["derive"] }  # Serialization
serde_json = "1.0.140"             # JSON handling
```

Since WASI components run in a synchronous environment but network requests are asynchronous, you can use `block_on` from the `wstd` crate to bridge this gap. The `block_on` function allows you to run async code within a synchronous context, which is essential for making HTTP requests in WAVS components.

### Making HTTP requests

The `wavs-wasi-utils` crate provides several functions for making HTTP requests. See the [HTTP module documentation](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/http/index.html) for more details.

```rust
// Request functions
http_request_get(url)              // Creates a GET request
http_request_post_json(url, data)  // Creates a POST request with JSON data
http_request_post_form(url, data)  // Creates a POST request with form data

// Response functions
fetch_json(request)    // Fetches and parses JSON response
fetch_string(request)  // Fetches response as string
fetch_bytes(request)   // Fetches raw response bytes
```

### Example: GET request with headers

Here's an example showing how to make a GET request with custom headers:

```rust lib.rs
use wstd::runtime::block_on;
use wstd::http::HeaderValue;
use wavs_wasi_utils::http::{fetch_json, http_request_get};
use serde::{Deserialize, Serialize};

// Define response type with serde derive for automatic JSON parsing
#[derive(Debug, Serialize, Deserialize)]
struct ApiResponse {
    // ... your response fields
}

async fn make_request() -> Result<ApiResponse, String> {
    let url = "https://api.example.com/endpoint";
    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    // Set headers for API requests
    req.headers_mut().insert(
        "Accept",
        HeaderValue::from_static("application/json")
    );
    req.headers_mut().insert(
        "Content-Type",
        HeaderValue::from_static("application/json")
    );
    req.headers_mut().insert(
        "User-Agent",
        HeaderValue::from_static("Mozilla/5.0")
    );
    // Use fetch_json to automatically parse the response
    let json: ApiResponse = fetch_json(req)
        .await
        .map_err(|e| e.to_string())?;
    Ok(json)
}

// Use block_on to handle async code in sync context
fn process_data() -> Result<ApiResponse, String> {
    block_on(async move {
        make_request().await
    })?
}
```

### Example: POST request with JSON data

For making POST requests with JSON data, you can use the `http_request_post_json` helper function:

```rust lib.rs
use wstd::runtime::block_on;
use wavs_wasi_utils::http::{fetch_json, http_request_post_json};
use serde::{Deserialize, Serialize};

// Define request and response types with serde derive
#[derive(Debug, Serialize, Deserialize)]
struct PostData {
    key1: String,
    key2: i32,
}

#[derive(Debug, Serialize, Deserialize)]
struct PostResponse {
    // ... response fields
}

async fn make_post_request() -> Result<PostResponse, String> {
    let url = "https://api.example.com/endpoint";
    let post_data = PostData {
        key1: "value1".to_string(),
        key2: 42,
    };
    // http_request_post_json automatically sets JSON headers
    let response: PostResponse = fetch_json(
        http_request_post_json(&url, &post_data)?
    ).await.map_err(|e| e.to_string())?;
    Ok(response)
}

fn process_data() -> Result<PostResponse, String> {
    block_on(async move {
        make_post_request().await
    })?
}
```

For more details, visit the [wavs-wasi-utils documentation](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/).
````

## File: docs/handbook/components/variables.mdx
````
---
title: Variables
description: Managing configuration variables in WAVS components
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

Components can be configured with two types of variables:

## Public variables

These variables can be used for non-sensitive information that can be viewed publicly. These variables are set in the `config` field of a service manifest. All config values are stored as strings, even for numbers.

To add public variables:

1. Add the public variables to the `config` field in the service manifest:

```json
"component": {
    "config": {
        "api_endpoint": "https://api.example.com",  // Access using host::config_var()
        "max_retries": "3"  // Config values are always strings
    }
}
```

2. Access them in the component using `host::config_var()`:

```rust
let value = host::config_var("api_endpoint");
```

## Environment keys

Environment keys are private and can be used for sensitive data like API keys. These variables are set by operators in their environment and are not viewable by anyone. These variables must be prefixed with `WAVS_ENV_`. Each operator must set these variables in their environment before deploying the service. WAVS validates that all environment variables are set before allowing the service to run.

To add private variables:

1. Create a new `.env` file in WAVS template:

```bash
# copy the example file
cp .env.example .env
```

Variables can also be set in your `~/.bashrc`, `~/.zshrc`, or `~/.profile` files.

2. Set the environment variable in your `.env` file:

```bash
# .env file
WAVS_ENV_MY_API_KEY=your_secret_key_here
```

3. Access the environment key from a component:

```rust
let api_key = std::env::var("WAVS_ENV_MY_API_KEY")?;
```

4. Before deploying a service, add the environment key to the `env_keys` array in the service manifest:

```json
"component": {
    "env_keys": [
        "WAVS_ENV_API_KEY"  // Environment variables the component can access. Must be prefixed with WAVS_ENV_
    ]
}
```

## Local Execution

When running components locally (raw), use the `--config` flag to set values in a KEY=VALUE format, comma-separated: `--config a=1,b=2`.

```bash
wavs-cli exec --component <COMPONENT> --input <INPUT> --config api_endpoint=https://api.example.com
```
````

## File: docs/handbook/ai.mdx
````
---
title: AI-powered component creation
description: Use Claude or Cursor to create one-shot components with minimal prompting
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->


The WAVS Foundry Template contains built-in AI rulefiles for creating "one-shot" components with minimal prompting in Cursor or Claude Code.

These rulefiles are an experimental feature and may not work as expected every time. Components created with AI should not be used in production without thorough review and testing.

<Callout title="LLM resources" type="info">
  For more information on AI tools and AI-accessible documentation, visit the [LLM resources page](/resources/llms).
</Callout>

## Claude Code

- Follow the [Claude Code installation instructions](https://docs.anthropic.com/en/docs/claude-code/getting-started) to install Claude Code and link your account.
- The Claude rulefile is `claude.md` and contains instructions for Claude on how to create a component.
- Learn more about Claude rulefiles: https://docs.anthropic.com/en/docs/claude-code/memory

## Cursor

- Download Cursor: https://www.cursor.com/downloads
- The Cursor rulefiles are located in the `.cursor/rules` directory.
- When using Cursor, always attach the `component-rules.mdc` file to the chat with your prompt.
- Learn more about Cursor rulefiles: https://docs.cursor.com/context/rules

## Using AI to create components

1. Clone the [WAVS Foundry Template](https://github.com/Lay3rLabs/wavs-foundry-template) and follow the system setup requirements in the README.

```sh
git clone https://github.com/Lay3rLabs/wavs-foundry-template.git
cd wavs-foundry-template
git checkout main
# Follow the system setup requirements in the README.
```

2. Open Claude Code or Cursor in the root of the template.

```sh
claude
# or
cursor .
```

<Callout title="Sandboxed Claude Code" type="info">

You can run a sandboxed instance of [Claude Code](https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview) in a Docker container that only has access to this project's files by running the following command from the root of the project:

```bash docci-ignore
npm run claude-code
# or with no restrictions (--dangerously-skip-permissions)
npm run claude-code:unrestricted
```

</Callout>

3. Enter your prompt in the agent chat. You can use the following examples as a starting point, or you can create your own prompt.

<Callout title="Attaching rulefiles" type="warn">
If you are using cursor, always attach `component-rules.mdc` file to the chat with your prompt.

```
@component-rules.mdc <your prompt>
```

</Callout>

### Prompt examples

These simple examples are provided to get you started.

#### API component

You can make a very simple prompt to create a component that can bring API responses verifiably onchain by including the API endpoint:

```
Let's make a component that takes the input of a zip code, queries the openbrewerydb, 
and returns the breweries in the area.
@https://api.openbrewerydb.org/v1/breweries?by_postal=92101&per_page=3
```

#### Contract balance component

You can also make components that interact with the blockchain:

```
I want to build a new component that takes the input of a wallet address,
queries the usdt contract, and returns the balance of that address.
```

#### Verifiable AI component

```
Please make a component that takes a prompt as input, sends an api request to OpenAI,
and returns the response.

  Use this api structure:
  {
    "seed": $SEED,
    "model": "gpt-4o",
    "messages": [
      {"role": "system", "content": "You are a helpful assistant."},
      {"role": "user", "content": "<PROMPT>"}
    ]
  }

My api key is WAVS_ENV_OPENAI_KEY in my .env file.
```

You'll need an [OPENAI API account and key](https://platform.openai.com/login) to use this prompt. The agent will include your API key in the component as a [private variable](./components/variables).

Make sure to include your API key in a `.env` file:

```sh
# copy the .env.example file
cp .env.example .env
# place your key in .env (must be prefixed with WAVS_ENV_)
WAVS_ENV_OPENAI_KEY=your_api_key
```

This example utilizes the OpenAI API with a [seed](https://platform.openai.com/docs/advanced-usage#reproducible-outputs) to make the response more deterministic. Please note that OpenAI models are not guaranteed to be 100% deterministic. This example is for demonstration purposes and should not be used in production.

## Component creation process

4. After receiving the prompt, the agent will start creating your component. Review the agent's work and accept changes carefully. Make sure to double check what the agent is doing and be safe about accepting changes.

5. The agent will start by planning its component and will create a `plan.md` file. The agent will then make a new component and files according to this plan.

6. The agent will test its component for errors by running validation tests using `make validate-component COMPONENT=your-component`.

7. The agent may need to make changes after running the Validation tests. After making changes, the agent will build the component using `WASI_BUILD_DIR=components/my-component make wasi-build`.

8. After successfully building your component, it's time to test it. The following command can be used to test your component logic without deploying WAVS. Make sure to replace the placeholders with the correct inputs.

```sh
# Run this command to build the component:
WASI_BUILD_DIR=components/openai-response make wasi-build

# Once built, test it with:
export COMPONENT_FILENAME=openai_response.wasm
export INPUT_DATA="Only respond with yes or no: Is AI beneficial to the world?"
make wasi-exec
```

The agent may try to run the `make wasi-exec` command themselves. You should prompt the agent to give you the command instead, as it can't run the command without permissions.


9. Your component should execute and return a response. If there are any errors, share them with the agent for troubleshooting.

If you have any questions, join the WAVS DEVS Telegram channel: https://t.me/layer_xyz/818

## Tips for working with AI agents

- While this repo contains rulefiles with enough context for creating simple components, coding agents are unpredictable and may inevitably run into problems.
- Feel free to update the rulefiles for your specific purposes or if you run into regular errors.
- Coding agents can sometimes try to over-engineer their fixes for errors. If you feel it is not being productive, it may be beneficial to start fresh. You may need to adjust your prompt.
- If you are building a complex component, it may be helpful to have the agent build a simple component first and then expand upon it.
- The agent may try to fix warnings unnecessarily. You can tell the agent to ignore minor warnings and any errors found in `bindings.rs` (it is auto-generated).

### Prompting

This repo is designed to be used with short prompts for simple components. However, often, coding agents will do better with more context.

When creating a prompt, consider the following:

- Agents work best with short, clear instructions.
- Provide relevant documentation (preferably as an `.md` file or other ai-digestible content).
- Provide endpoints.
- You may need to provide API response structure if the agent is not understanding responses.
- Be specific about what you want the agent to build.
- Agents work systematically to build components. For best results, agent should make a plan before they start building.
- Be patient. Coding agents are not perfect. They may make mistakes.

## Troubleshooting

- You can ask the agent to fix errors it may not be able to catch when executing components. Make sure to give the agent full context of the error.
- LLMs can be unpredictable. Minimal prompts provide a lot of room for creativity/error. If the agent is not able to fix an error after trying, sometimes deleting the component, clearing the history, and starting fresh can help.
- The agent may try to edit the bindings.rs file to "fix" it. The agent never needs to do this, and you should tell the agent to not do this.
- The agent is supposed to provide you with the `make wasi-exec` command. Sometimes it will try to run this itself and it will fail. Instead, ask it to give you the command.
- When copying and pasting the full `make wasi-exec` command, be careful with line breaks. You may need to reformat long lines to avoid breaking the command.
````

## File: docs/handbook/commands.mdx
````
---
title: Makefile commands
description: CLI commands for WAVS development
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

## Commands

Use `make help` to see all the commands:

```bash
make help
```

Here are the available `make` commands and their descriptions:

```bash
build                     building the project
wasi-build                building WAVS wasi components | WASI_BUILD_DIR
wasi-exec                 executing the WAVS wasi component(s) with ABI function | COMPONENT_FILENAME, INPUT_DATA
wasi-exec-fixed           the same as wasi-exec, except uses a fixed input as bytes (used in Go & TS components) | COMPONENT_FILENAME, INPUT_DATA
clean                     cleaning the project files
clean-docker              remove unused docker containers
validate-component        validate a WAVS component against best practices
fmt                       formatting solidity and rust code
test                      running tests
setup                     install initial dependencies
start-all-local           starting anvil and core services (like IPFS for example)
get-trigger-from-deploy   getting the trigger address from the script deploy
get-submit-from-deploy    getting the submit address from the script deploy
wavs-cli                  running wavs-cli in docker
upload-component          uploading the WAVS component | COMPONENT_FILENAME, WAVS_ENDPOINT
deploy-service            deploying the WAVS component service json | SERVICE_URL, CREDENTIAL, WAVS_ENDPOINT
get-trigger               get the trigger id | SERVICE_TRIGGER_ADDR, RPC_URL
show-result               showing the result | SERVICE_SUBMISSION_ADDR, TRIGGER_ID, RPC_URL
upload-to-ipfs            uploading the a service config to IPFS | SERVICE_FILE, [PINATA_API_KEY]
update-submodules         update the git submodules
check-requirements        verify system requirements are installed
```

For more information on commands when using the template, visit the [WAVS tutorial](/tutorial/1-overview).
````

## File: docs/handbook/overview.mdx
````
---
title: Handbook overview
description: Guide to WAVS handbook structure and contents
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

<Callout title="Follow the tutorial" type="info">
{/* todo: verify all links are correct. */}

Before reading this guide, follow the [Oracle component tutorial](/tutorial/1-overview) to learn the basics of building a WAVS service.

</Callout>

This handbook provides an overview of the different parts that make up a WAVS AVS.

## Tutorial

- [Oracle component tutorial](/tutorial/1-overview) - Start here to learn the basics of building a WAVS service.

## Core Concepts

- [How it works](../how-it-works) - Learn about the different parts that make up a WAVS AVS.
- [Design](../design) - Learn about the design considerations for building a WAVS AVS.

## Services

- [Service](./service) - Learn about WAVS services, their structure, and how they are defined in the service manifest.
- [Workflows](./workflows) - Understand how workflows define execution paths in your service, including triggers, components, and submissions.
- [Triggers](./triggers) - Explore the different types of triggers that can initiate your service, including EVM events, Cosmos events, cron jobs, and block intervals.
- [Submission and Aggregator](./submission) - Discover how results are submitted to the blockchain through the aggregator service and submission contracts.

## Components
- [Component overview](./components/component) - Learn about the structure and lifecycle of WAVS components, including how to handle triggers and process data.
- [Variables](./components/variables) - Understand how to configure components with public and private variables.
- [Blockchain interactions](./components/blockchain-interactions) - Discover how to interact with blockchains and smart contracts from your components.
- [Network requests](./components/network-requests) - Learn how to make HTTP requests to external APIs from your components.

## Development
- [Template](./template) - Get started with the WAVS template, including its structure, configuration files, and how to customize it for your service.
- [Makefile commands](./commands) - Reference for the available makefile commands to build, deploy, and manage your service.
- [AI-powered component creation](./ai) - Learn how to use AI coding agents to create components.

Each section provides detailed information and examples to help you understand and build your WAVS service. Start with the Service section to understand the basic concepts, then explore the other sections based on your needs.
````

## File: docs/handbook/service.mdx
````
---
title: Service manifest and manager
description: Overview of the service.json manifest file and service manager contract
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

A service is a collection of smart contracts, operators, and offchain components that make up a WAVS AVS. The different parts of a service are defined in a service manifest or `service.json` file. This file can be stored on IPFS or an HTTP/HTTPS server, and its URL is set on the service manager contract during deployment, allowing the system to fetch the service definition when needed.

The service manifest defines the configuration and different parts of a WAVS service, including information about the service, [workflows](/handbook/workflows), [components](/handbook/components/component), [submission](/handbook/submission), [service manager contract](#service-manager), and more.

## Generate Manifest

You can create the service.json file using the `wavs-cli service` command. The template provides a script to generate a single-component service with ease, [build_service.sh](https://github.com/Lay3rLabs/wavs-foundry-template/blob/main/script/build-service.sh).

## Example Manifest

```json service.json
{
    // Basic service information
    "id": "example-service-123",
    "name": "Example WAVS Service",
    // Workflows define the different execution paths in your service
    "workflows": {
        // Each workflow has a unique ID
        "default": {
            // Trigger defines what initiates the workflow
            "trigger": {
                // This example uses an EVM contract event trigger
                "evm_contract_event": {
                    "chain_name": "ethereum",
                    "address": "0x1234567890123456789012345678901234567890",
                    "event_hash": "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"
                }
            },

            // Component defines the WASI component to execute
            "component": {
                "source": {
                    "Registry": {
                        "registry": {
                        //  (SHA-256) hash that identifies a specific version of a WASI component's code in WAVS
                        "digest": "882b992af8f78e0aaceaf9609c7ba2ce80a22c521789c94ae1960c43a98295f5",
                        // The domain the warg WASI component is hosted on
                        "domain": "localhost:8090",
                        // The version of this component
                        "version": "0.1.0",
                        // The package name of the component on the domain registry
                        "package": "example:evmrustoracle"
                        }
                    }
                },

                // Permissions define what the component can access
                "permissions": {
                    // HTTP host permissions
                    "allowed_http_hosts": "all"  // Options: "all", ["host1", "host2"], or "none"
                    // File system permissions
                    "file_system": true
                },

                // Resource limits
                "fuel_limit": 1000000,           // Optional: Maximum compute units
                "time_limit_seconds": 30,        // Optional: Maximum execution time

                // Component-specific configuration
                "config": {
                    "endpoint": "https://api.example.com",
                    "timeout": "30s"
                },

                // Environment variables to be passed to the component
                "env_keys": [
                    "WAVS_ENV_API_KEY",
                    "WAVS_ENV_SECRET"
                ]
            },

            // Submit defines where the results are sent
            "submit": {
                // The aggregator configuration
                "aggregator": {
                    "url": "http://127.0.0.1:8001"
                }
            },

            "aggregators": [
                {
                    "evm": {
                        // The identifier for the chain the submission contract (set in wavs.toml)
                        "chain_name": "ethereum",
                        // The address of the submission contract with the service handler interface
                        "address": "0xfedcba9876543210fedcba9876543210fedcba98",
                        // The maximum amount of gas for submission
                        "max_gas": 1000000  // Optional
                    }
                }
            ]
        } //other workflows can be added here
    },

    // Service status
    "status": "active",  // Options: "active" or "inactive"

    // Service manager configuration
    "manager": {
        "evm": {
            "chain_name": "ethereum",
            // The address of the service manager contract
            "address": "0xabcdef1234567890abcdef1234567890abcdef12"
        }
    }
}
```

## Upload

This file should be uploaded to IPFS, or some other hosted service that all operators can access. The template launches a local IPFS for testing. Use a service like [Pinata](https://app.pinata.cloud/developers/api-keys) for production services.

```bash
# Upload to local or remote IPFS (smart routes based on .env deploy configuration)
SERVICE_FILE=${SERVICE_FILE} make upload-to-ipfs

# smart grabs the IPFS gateway and fetches the content that was uploaded
export IPFS_GATEWAY=$(sh script/get-ipfs-gateway.sh)
curl "${IPFS_GATEWAY}${ipfs_cid}"

# Then the admin of the contracts can set it
cast send ${WAVS_SERVICE_MANAGER_ADDRESS} 'setServiceURI(string)' "${SERVICE_URI}" -r ${RPC_URL} --private-key ${DEPLOYER_PK}
```

For more information on the different parts of a service manifest, see the following sections:

- [Workflows](./workflows)
- [Triggers](./triggers)
- [Components](./components/component)
- [Submission and aggregator](./submission)

## Service manager

The service manager contract defines the set of registered operators for a service. Only operators registered in this contract are considered valid signers for result submissions in a service. Each registered operator is assigned a weight. These weights count toward a threshold for their submission power.

The service manager also maintains a service URI that points to the service manifest, connecting the operators to the service.

Signatures are created by operators using their private keys to sign an envelope containing the data, and these signatures are collected by the aggregator which then submits them to the service manager contract for validation. The service manager contract validates that the signatures are from registered operators, checks that their total weight meets the threshold, and ensures the operators are properly sorted before allowing the data to be processed by the [service handler](/handbook/submission) contract.
````

## File: docs/handbook/submission.mdx
````
---
title: Submission and aggregator
description: Creating and configuring submission contracts and the aggregator
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

This page describes the submission and aggregator services used to submit results from a workflow to a submission contract on an EVM chain.

## Submit definition

The `submit` field in a service.json file specifies the submission logic for a service. The `aggregator` type sends results to an aggregator service, which validates the results and submits them to a target contract on an EVM chain.

```json service.json
    "submit": {  // Where results are sent
        "aggregator": {  // Type of submission (aggregator)
            "url": "http://127.0.0.1:8001"  // Local aggregator endpoint
        }
    },
    "aggregators": [  // The final submission address that the aggregator will submit to
        {
            "evm": {  // EVM chain configuration
                "chain_name": "local",  // Local Ethereum chain
                "address": "0xd6f8ff0036d8b2088107902102f9415330868109",  // Submission contract address
                "max_gas": 5000000  // Maximum gas limit for transactions
            }
        }
    ]
```
Submit can also be set to `none` if the service does not need to submit results to a contract. The component will still run, but the results will not be submitted.

## Submission contract

A service handler or submission contract handles the logic for verifying the submission of a component's output to the blockchain. The only requirement for a submission contract is that it must implement the `handleSignedEnvelope()` function using the `IWavsServiceHandler` interface to validate data and signatures using the service manager. This interface is defined in the `@wavs` package: https://www.npmjs.com/package/@wavs/solidity?activeTab=code

<Callout title="Chaining workflows" type="info">

Workflows can be chained together by setting the trigger event of one workflow to the submission event of another workflow. For more information on chaining workflows, see the [Workflows page](./workflows).

</Callout>

## Template submission example

The [template submission contract](https://github.com/Lay3rLabs/wavs-foundry-template/blob/main/src/contracts/WavsSubmit.sol) uses the `handleSignedEnvelope()` function to validate operator signatures and store the processed data from the component. The `DataWithId` struct must match the output format from the component. In the template, each trigger has a unique ID that links the data to its source.

Below is a simplified version of the template submission contract:

```solidity WavsSubmit.sol
import {IWavsServiceManager} from "@wavs/interfaces/IWavsServiceManager.sol";
import {IWavsServiceHandler} from "@wavs/interfaces/IWavsServiceHandler.sol";
import {ITypes} from "interfaces/ITypes.sol";

// Contract must implement IWavsServiceHandler to receive data
// ITypes provides the DataWithId struct and other type definitions
contract SimpleSubmit is ITypes, IWavsServiceHandler {

    /// @notice Service manager instance - used to validate incoming data and signatures
    IWavsServiceManager private _serviceManager;

    /**
     * @notice Initialize the contract with a service manager
     * @param serviceManager The service manager instance that will validate data
     */
    constructor(IWavsServiceManager serviceManager) {
        _serviceManager = serviceManager;
    }

    /// @inheritdoc IWavsServiceHandler
    /// @notice Main entry point for receiving and processing data
    /// @param envelope Contains the event ID and the actual data payload
    /// @param signatureData Contains operator signatures for validation
    function handleSignedEnvelope(Envelope calldata envelope, SignatureData calldata signatureData) external {
        // First validate the data and signatures through the service manager
        // This ensures the data is properly signed by authorized operators
        _serviceManager.validate(envelope, signatureData);

        // Decode the payload into your expected data structure
        // The payload format must match what your component outputs
        DataWithId memory dataWithId = abi.decode(envelope.payload, (DataWithId));
        // At this point, you can safely process the validated data
        // Add your custom logic here to handle the data
    }
}
```

## Aggregator

The aggregator is used to collect and validate responses from multiple operators before submitting them to the blockchain. It acts as an intermediary that receives signed responses from operators, validates each operator's signature, aggregates signatures when enough operators have responded, and submits the aggregated data to the submission contract. The aggregator supports exact match aggregation, meaning that consensus is reached if a threshold amount of submitted responses from operators are identical. Visit the [design considerations page](/design) for more information on aggregation and service design.

WAVS currently uses ECDSA signatures for aggregation, but will also support BLS signatures in the future.

## Aggregator submission flow

1. An operator runs a component which returns a `WasmResponse` containing:
   - `payload`: The result data
   - `ordering`: Optional ordering information
2. The operator creates an Envelope containing the result data and signs it with their private key, creating an signature.
3. A Packet containing the envelope, signature, and route information (service ID and workflow ID) is created and sent to the aggregator's `/packet` endpoint.
4. The aggregator validates the packet's signature by recovering the operator's address and adds it to a queue of packets with the same trigger event and service ID.
5. When enough packets accumulate to meet the threshold (determined by the service manager contract), the aggregator:
   - Combines the signatures from all packets into a single SignatureData structure
   - Validates the combined signatures on-chain through the service manager contract
6. If validation succeeds, the aggregator sends the operator signatures and payload result data as a single transaction to the `handleSignedEnvelope()` function on the submit contract specified in the service's manifest.
7. The `handleSignedEnvelope()` function validates the data and signatures via the service manager contract.
````

## File: docs/handbook/template.mdx
````
---
title: Template overview
description: Overview of the WAVS foundry template
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

<Callout title="Follow the tutorial" type="info">

Before reading this guide, follow the [Oracle component tutorial](/tutorial/1-overview) to learn the basics of building a WAVS service.

</Callout>

Use the info in this guide to customize the template to create your own custom service. Check out the [WAVS design considerations](/design) page to learn which use-cases WAVS is best suited for.

## Foundry Template structure

[The WAVS template](https://github.com/Lay3rLabs/wavs-foundry-template) is made up of the following main files:

```bash
wavs-foundry-template/
├── README.md
├── makefile               # Commands, variables, and configs
├── components/            # WASI components
│   └── evm-price-oracle/
│       ├── src/
│       │   ├── lib.rs         # Main Component logic
│       │   ├── trigger.rs     # Trigger handling
│       │   └── bindings.rs    # Bindings generated by `make build`
│       └── Cargo.toml     # Component dependencies
├── compiled/              # WASM files compiled by `make build`
├── src/
│   ├── contracts/        # Trigger and submission contracts
│   └── interfaces/       # Solidity interfaces
├── script/               # Deployment & interaction scripts
├── wavs.toml             # WAVS service configuration
├── docs/                 # Documentation
├── .cursor/rules/        # Cursor AI rulefiles
├── claude.md             # Claude AI rulefile
└── .env                  # Private environment variables
```

- The `README` file contains the tutorial commands.
- The `makefile` contains commands for building and deploying the service. It also contains configurable variables for the service and deployment.
- The `components` directory contains the component logic for your service. Running `make wasi-build` will automatically generate bindings and compile components into the `compiled` directory.
- The `src` directory contains the Solidity contracts and interfaces for trigger and submission contracts.
- The `script` directory contains the scripts used in the makefile commands to deploy, trigger, and test the service.
- The `.env` file contains private environment variables and keys. Use `cp .env.example .env` to copy the example `.env` file.
- The `.cursor/rules` directory and `claude.md` file contain rulefiles for [building components with Cursor AI and Claude AI agents](/handbook/ai).

## Toml files

There are several toml files in the template that are used to configure the service:

- `wavs.toml` is used to configure the WAVS service itself, including chains (local, testnets, mainnet) and configurations.
- `Cargo.toml` in the root directory is used to configure the workspace and includes dependencies, build settings, and component metadata.
- `components/*/Cargo.toml` in each component directory is used to configure the Rust component and includes dependencies, build settings, and component metadata. It can inherit dependencies from the root `Cargo.toml` file using `workspace = true`.

These files can be customized to suit your specific needs, and many settings can be overridden using environment variables.

The following is an example of a component's `Cargo.toml` file structure:

```toml
[package]
name = "evm-price-oracle"
edition.workspace = true
version.workspace = true
authors.workspace = true
rust-version.workspace = true
repository.workspace = true

[dependencies]
wit-bindgen-rt ={ workspace = true }
wavs-wasi-utils = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
alloy-sol-macro = { workspace = true }
wstd = { workspace = true }
alloy-sol-types = { workspace = true }
anyhow = { workspace = true }

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "s"
debug = false
strip = true
lto = true

[package.metadata.component]
package = "component:evm-price-oracle"
target = "wavs:worker/layer-trigger-world@0.4.0"

```

## wavs.toml config

The [`wavs.toml`](https://github.com/Lay3rLabs/wavs-foundry-template/blob/main/wavs.toml) file contains configuration settings for all WAVS components:
- Default general settings (shared across all processes)
- WAVS server-specific settings
- CLI-specific settings
- Aggregator-specific settings

### Environment Variable Overrides

Environment variables can override configuration values using these patterns:
- WAVS server settings: `WAVS_<UPPERCASE_KEY>`
- CLI settings: `WAVS_CLI_<UPPERCASE_KEY>`
- Aggregator settings: `WAVS_AGGREGATOR_<UPPERCASE_KEY>`
````

## File: docs/handbook/triggers.mdx
````
---
title: Triggers
description: Setting up and managing WAVS service triggers
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->


{/* todo: verify all code examples. link to appropriate pages. */}

A trigger prompts a WAVS service to run. Operators listen for the trigger event specified by the service and execute the corresponding component off-chain. Triggers can be any onchain event emitted from any contract.

### Trigger lifecycle

1. A service is deployed with a service.json manifest which contains information on the service and [workflow](/handbook/workflows) logic (components, triggers, [submission](/handbook/submission) logic).

2. Operators maintain lookup maps to track and verify triggers. For EVM and Cosmos events, they map chain names, contract addresses, and event identifiers to trigger IDs. Block interval triggers are tracked by chain name with countdown timers, while cron triggers are managed in a priority queue ordered by execution time.

3. When a trigger is detected, operators verify it against their lookup maps according to trigger type. If a match is found, a TriggerAction is created with the trigger configuration and event data.

4. `TriggerAction` has 2 fields: `TriggerConfig` which contains the service, workflow, and trigger configuration, and `TriggerData`contains the trigger data based on the trigger type.

```rust
pub struct TriggerAction {
    pub config: TriggerConfig,  // Contains service_id, workflow_id, and trigger type
    pub data: TriggerData,      // Contains the actual trigger data
}

pub struct TriggerConfig {
    pub service_id: ServiceID,
    pub workflow_id: WorkflowID,
    pub trigger: Trigger,
}

pub enum TriggerData {
    CosmosContractEvent { //For Cosmos event triggers
        contract_address: layer_climb_address::Address, /// The address of the contract that emitted the event
        chain_name: ChainName, /// The name of the chain where the event was emitted
        event: cosmwasm_std::Event, /// The data that was emitted by the contract
        block_height: u64, /// The block height where the event was emitted
    },
    EvmContractEvent { //For EVM event triggers
        contract_address: alloy_primitives::Address, /// The address of the contract that emitted the event
        chain_name: ChainName, /// The name of the chain where the event was emitted
        log: LogData, /// The raw event log
        block_height: u64, /// The block height where the event was emitted
    },
    BlockInterval { //For block interval triggers
        chain_name: ChainName, /// The name of the chain where the blocks are checked
        block_height: u64, /// The block height where the event was emitted
    },
    Cron { //For cron triggers
        trigger_time: Timestamp, /// The trigger time
    }
}
```

5. The TriggerAction is converted to a WASI-compatible format and passed to the component where it is decoded and processed. The component decodes the incoming event trigger data using the `decode_event_log_data!` macro from the [`wavs-wasi-utils` crate](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/macro.decode_event_log_data.html). Visit the [components page](./components/component) for more information on decoding and processing trigger data in your component.


## Trigger configuration

Triggers define when and how the component should be executed. Each workflow needs a trigger to be set. They are set in the `trigger` field of the [`service.json` file](/handbook/service).

### EVM event trigger

This trigger listens for specific events emitted by contracts on EVM-compatible chains, executing the component when a matching event is detected. Event triggers pass raw log data to the component.

```json

"trigger": {
  "evm_contract_event": {
    "address": "0x00000000219ab540356cbb839cbe05303d7705fa", // Contract address to monitor
    "chain_name": "ethereum", // Chain to monitor
    "event_hash": "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef" // Event hash (32 bytes)
  }
}

```

Your evm chain information must be set in `wavs.toml` under the `[default.chains.evm.<chain_name>]` section:

```toml wavs.toml
# Mainnet
[default.chains.evm.ethereum]
chain_id = "1"
ws_endpoint = "wss://eth.drpc.org"
http_endpoint = "https://eth.drpc.org"
```

You'll need to set your EVM chain credential in your `.env` file to establish a connection for monitoring the EVM chain:

```env .env
WAVS_CLI_EVM_CREDENTIAL="0x5ze146f435835b1762ed602088740d201b68fd94bf808f97fd04588f1a63c9ab"
```

### Cosmos event trigger

This trigger monitors events emitted by Cosmos smart contracts, executing your component when a matching event type is detected from the specified contract address. Cosmos event triggers pass the contract data that was emitted by the contract to the component.

```json
  "trigger": {
    "cosmos_contract_event": {
      "address": {
        "Cosmos": {
          "bech32_addr": "neutron1qlaq54uh9f52d3p66q77s6kh9k9ee3vasy8gkdkk3yvgezcs6zts0mkcv4", // Contract address to monitor
          "prefix_len": 7 // Length of the Bech32 prefix (7 for Neutron)
        }
      },
      "chain_name": "neutron", // Chain to monitor
      "event_type": "send_nft" // Event type to watch
    }
  },
```

Your chain information must be set in `wavs.toml` under the `[default.chains.cosmos.<chain_name>]` section:

```toml wavs.toml
# == Cosmos chains ==

[default.chains.cosmos.neutron]
chain_id = "pion-1"
bech32_prefix = "neutron"
rpc_endpoint = "https://rpc-falcron.pion-1.ntrn.tech"
grpc_endpoint = "http://grpc-falcron.pion-1.ntrn.tech:80"
gas_price = 0.0053
gas_denom = "untrn"
```

Your Cosmos mnemonic must be set in your `.env` file to establish a connection for monitoring the Cosmos chain:

```env .env
WAVS_CLI_COSMOS_MNEMONIC="large slab plate twenty laundry illegal vacuum phone drum example topic reason"
```

### Cron trigger

Executes your component on a schedule defined by a cron expression, with optional start and end times to control the execution window. If no start or end time is provided, the component will start immediately and run indefinitely. Cron triggers pass the trigger timestamp to the component.

```json

  "trigger": {
    "cron": {
      "schedule": "0 */5 * * * *",  // Every 5 minutes (at 0 seconds)
      "start_time": 1704067200000000000,  // Optional start time in nanoseconds since Unix epoch (2024-01-01T00:00:00Z) (default: null)
      "end_time": 1735689599000000000     // Optional end time in nanoseconds since Unix epoch (default: null)
    }
  }

// Cron Expression Format:
// * * * * * *
// │ │ │ │ │ │
// │ │ │ │ │ └── Day of week (0-6, where 0 is Sunday)
// │ │ │ │ └──── Month (1-12)
// │ │ │ └────── Day of month (1-31)
// │ │ └──────── Hour (0-23)
// │ └────────── Minute (0-59)
// └──────────── Second (0-59)
//
// Each field can be:
// - A number:    `5`      (exact time)
// - A range:     `1-5`    (1 through 5)
// - A list:      `1,3,5`  (1, 3, and 5)
// - A step:      `*/5`    (every 5 units)
// - An asterisk: `*`      (every unit)
//
// Common examples:
// - `0 */5 * * * *`     - Every 5 minutes (at 0 seconds)
// - `0 0 */6 * * *`     - Every 6 hours (at 0 minutes and 0 seconds)
// - `0 0 0 * * *`       - Every day at midnight (00:00:00)
// - `0 0 12 * * *`      - Every day at noon (12:00:00)
// - `0 0 12 1 * *`      - Noon on the first day of every month
// - `0 0 12 * * 1`      - Noon every Monday
```

[Crontab.guru](https://crontab.guru/) is a helpful tool for making cron expressions.

<Callout title="Cron trigger latency" type="info">

There may be slight variations in Cron trigger execution time between operators due to network latency and clock drift. Cron triggers are best suited for tasks that don't require precise synchronization between operators:
- Triggering components that don't need exact synchronization.
- Collecting data from external services with monotonic pagination.
- Background tasks where eventual consistency is acceptable.

If you need precise timing synchronization between operators, consider using [block-based triggers](#block-trigger) instead.

</Callout>

### Block trigger

Executes your component at regular block intervals on a specified EVM or Cosmos chain, useful for chain-specific operations that need to run periodically. Block interval triggers pass the block height and chain name to the component.

```json
"trigger": {
  "block_interval": {
    "chain_name": "ethereum-mainnet",
    "n_blocks": 10,
    "start_block": null,  // Optional blockheight to start
    "end_block": null     // Optional blockheight to end
  }
}
```
````

## File: docs/handbook/workflows.mdx
````
---
title: Workflows
description: Building and managing WAVS service workflows
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

A WAVS service is a collection of one or more workflows that define the different execution paths in your service.

Each workflow consists of three parts:

- [**Trigger**](./triggers): Defines what event initiates the workflow
- [**Component**](./components/component): The WASM component that processes the event
- [**Submit**](./submission): Specifies where to send the results

## Workflow Structure

Workflows are defined in the service manifest JSON file, which contains the necessary information on which trigger, component, and submission logic are needed.

The following example shows a workflow with a cron trigger and a submission to an aggregator:

```json service.json
// ... other parts of the service manifest
"workflows": { //workflows are added here
"0196c34d-003d-7412-a3f3-70f8ec664e12": {  // a unique workflow ID (default is a generated UUID v7)
    "trigger": {  // Defines what starts the workflow
        "cron": {  // Type of trigger (cron job)
            "schedule": "0 * * * * *",  // Runs every minute at 0 seconds
            "start_time": null,
            "end_time": null
        }
    },
    "component": { // the WASI component containing the business logic of the workflow
        "source": {  // Where the component code comes from
            "Digest": "65747b4b1a7fa98cab6abd9a81a6102068de77b1040b94de904112272b226f51"  // SHA-256 hash of the component's bytecode
        },
        "permissions": {  // What the component can access
            "allowed_http_hosts": "all",  // Can make HTTP requests to any host
            "file_system": true  // Can access the filesystem
        },
        "fuel_limit": null,  // Computational limits for the component
        "time_limit_seconds": 1800,  // Can run for up to 30 minutes
        "config": {  // Configuration passed to the component
            "nft": "0xb5d4D4a87Cb07f33b5FAd6736D8F1EE7D255d9E9",  // NFT contract address
            "reward_token": "0x34045B4b0cdfADf87B840bCF544161168c8ab85A"  // Reward token address
        },
        "env_keys": [  // Secret environment variables the component can access from .env
            "WAVS_ENV_API_KEY",  // secret API key with prefix WAVS_ENV_
        ]
    },
    "submit": {  // Where results are sent
        "aggregator": {  // Type of submission (aggregator)
            "url": "http://127.0.0.1:8001"  // Local aggregator endpoint
        }
    },
    "aggregators": [  // The final submission address that the aggregator will submit to
        {
            "evm": {  // EVM chain configuration
                "chain_name": "local",  // Local Ethereum chain
                "address": "0xd6f8ff0036d8b2088107902102f9415330868109",  // Contract address
                "max_gas": 5000000  // Maximum gas limit for transactions
            }
        }
    ]
}
// other workflows can be added here...
},

// ... the rest of the service manifest
```

## Multi-workflow services

A WAVS service can have one or multiple workflows. You can specify multiple workflows as objects in the service manifest. Each workflow can have a different trigger, component, and submission logic. All workflows in a service will share the same service manager and operator set.

{/* todo: link above to service manager page. */}

```json
{
  "workflows": {
    "workflow-uuid-1": {
      "trigger": { ... },
      "component": { ... },
      "submit": { ... }
    },
    "workflow-uuid-2": {
      "trigger": { ... },
      "component": { ... },
      "submit": { ... }
    }
    // ... more workflows can be added here
  }
}
```

## Workflow isolation

Each workflow execution is completely isolated with components running in separate WebAssembly environments. Each execution has its own memory space and components cannot directly access each other's memory or state.

## Sharing state

WAVS services are designed to process data rather than store data. Data should be stored externally. To share data between workflows or components, the first workflow should submit data to an external system such as an onchain smart contract and the second workflow should read the data from the same system.

```
A: Trigger -> component -> onchain submission storage
B: Trigger -> component (reads from A's onchain submission storage) -> onchain submission storage
```

1. Workflow A submits data to a contract or external system
2. Workflow B reads data from the same contract or system

Visit the [WAVS design considerations page](../design) for more information on best practices for WAVS services and storing data.

## Chaining workflows

You can chain workflows together to create more complex execution flows. To have one workflow trigger another, set the event trigger of the second workflow to the onchain submission event of the first workflow.

```json
{
  "workflows": {
    "workflow-uuid-1": {
      "trigger": { ... }, // trigger for first workflow
      "component": { ... }, // component for first workflow
      "submit": { ... } // submission logic for first workflow
    },
    "workflow-uuid-2": {
      "trigger": { ... }, // trigger for second workflow is the onchain submission event of the first workflow
      "component": { ... }, // component for second workflow
      "submit": { ... } // submission logic for second workflow
    }
  }
}
```
You can also chain different services together with this method by setting the trigger of the second service to the onchain submission event of the first service.

## Multichain services

WAVS enables multichain services by allowing contract event or block height triggers on Cosmos or EVM chains (with more coming soon). This architecture lets you create cross-chain services that monitor events or block heights on one chain and submit the results to Ethereum. Visit the [Trigger page](./triggers) for more info.
````

## File: docs/resources/llms.mdx
````
---
title: LLM docs
description: Access WAVS documentation in formats optimized for AI tools and integration.
---



The LLM text format presents documentation in a clean, plain text format optimized for large language models (LLMs) like Claude, ChatGPT, and others.

## llms.txt

The `llms.txt` format is a structured index of documentation pages organized by sections, including page titles, URLs and descriptions. This format is ideal for AI assistants to understand the documentation structure without processing the full content.

[https://docs.wavs.xyz/llms.txt](https://docs.wavs.xyz/llms.txt)

```
curl https://docs.wavs.xyz/llms.txt
```

## llms-full.txt

The `llms-full.txt` format returns all documentation pages as a single text document.

[https://docs.wavs.xyz/llms-full.txt](https://docs.wavs.xyz/llms-full.txt)

```
curl https://docs.wavs.xyz/llms-full.txt
```

Returns all documentation pages as a single text document.


## Markdown Format

Get any page as standard Markdown by appending `.md` to its URL.

```
curl https://docs.wavs.xyz/path/to/page.md
```

Examples:
- `/overview.md` - Overview page as Markdown
- `/tutorial/1-overview.md` - Tutorial introduction as Markdown
- `/handbook/service.md` - Service handbook as Markdown
````

## File: docs/tutorial/1-overview.mdx
````
---
title: 1. Oracle service tutorial
description: Introduction to WAVS tutorial series
---
<!--docsignore
import { HomeIcon, AppWindow, CircuitBoard, Layers, Microscope, Grid2x2, CloudSun, ChevronRight } from 'lucide-react';
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Scrollycoding } from "@/components/scrollycoding";
import { link } from "@/components/link.tsx";
docsignore-->

<img alt="Start-building" src="https://raw.githubusercontent.com/Lay3rLabs/WAVS-docs/refs/heads/main/public/start-building.png" />

In this guide, you will build a simple oracle service that fetches Bitcoin price data from [coinmarketcap.com](https://coinmarketcap.com/api/). This example is built using the [WAVS Foundry Template](https://github.com/Lay3rLabs/wavs-foundry-template), which contains the tools you need to build your own custom service.

The price oracle service example has three basic parts:

1. [A trigger contract](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/src/contracts/WavsTrigger.sol): A trigger can be any on-chain event emitted from a contract. This event **triggers** a service to run. In the WAVS Foundry Template, there is a simple trigger contract that stores trigger requests, assigns them unique IDs, and emits an event when a new trigger is added. In this example, the trigger event `addTrigger` will pass data pertaining to the ID of an asset for the CoinMarketCap price feed.

2. [A service component](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/components/evm-price-oracle/src/lib.rs): The service component contains the business logic of a service. It is written in Rust, compiled to WASM, and run by operators in the WAVS runtime. In this example, operators will listen for a new trigger event to be emitted and then run the service component off-chain, using the asset ID data from the trigger event as input. The component contains logic to fetch the price of the asset from the CoinMarketCap price feed API, which is then processed and encoded before being sent back on-chain.

3. [A submission contract](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/src/contracts/WavsSubmit.sol): Also known as the "service handler," this contract contains the on-chain submission logic for the service. It validates and stores the processed data returned by the WAVS component. When an operator submits a response, the contract verifies the data's integrity by checking the operator's signature and then associates it with the original trigger ID, bringing the queried price on-chain.

These three parts come together to create a basic oracle service using WAVS. To learn more about services and how they work, visit the [How it works page](../how-it-works).

## Video tutorial

{/* todo: needs a 0.4 demo video */}

You can follow along with this guide by watching the video tutorial:
   <div style={{display: "flex", justifyContent: "center", alignItems: "center", paddingBottom: "2em"}}>
     <iframe width="560" height="315" src="https://www.youtube.com/embed/X3XCbSF9Epc" title="WAVS Tutorial" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
   </div>


<Card
  icon={<ChevronRight />}
  href="/tutorial/2-setup"
  title="Get Started"
  description="Click here to set up your environment and start building your service."
/>
````

## File: docs/tutorial/2-setup.mdx
````
---
title: 2. System setup
description: Setting up development environment for WAVS
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
docsignore-->

The following installations are required to run this example. Follow the steps below to set up your system.

<Callout title="System recommendations" type="info">

This tutorial is designed for Windows WSL, Linux, and macOS systems.

</Callout>

## Environment

Install [VS Code](https://code.visualstudio.com/download) and the [Solidity extension](https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity) if you don't already have them.

## Rust

Run the following command to install [Rust](https://www.rust-lang.org/tools/install).


```bash docci-ignore
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

<Callout title="Homebrew Rust not supported" type="error">

If you installed Rust using Homebrew, you will need to uninstall it and install it again using the rustup command.

```bash docci-ignore
brew uninstall rust
```
Then run:
```bash docci-ignore
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```
</Callout>

<Callout title="Fresh Install" type="info">

If you just installed Rust for the first time, you will need to run the following commands:

```bash docci-ignore
# Install required target and toolchain
rustup toolchain install stable
rustup target add wasm32-wasip2
```
</Callout>


<Callout title="Upgrade Rust" type="info">

If you already have a previous version of Rust installed, you will need to run the following commands to upgrade it to the latest stable version:

```bash docci-ignore
# Remove old targets if present
rustup target remove wasm32-wasi || true
rustup target remove wasm32-wasip1 || true

# Update and add required target
rustup update stable
rustup target add wasm32-wasip2
```
</Callout>


## Cargo components

Install the following for building WebAssembly components. Visit the [Cargo Component documentation](https://github.com/bytecodealliance/cargo-component#installation) for more information.

{/* This section is also in [](./5-build.mdx). Remember to update there as well */}
```bash docci-ignore
cargo install cargo-binstall
cargo binstall cargo-component wasm-tools warg-cli wkg --locked --no-confirm --force

# Configure default registry
# Found at: $HOME/.config/wasm-pkg/config.toml
wkg config --default-registry wa.dev

# Allow publishing to a registry
#
# if WSL: `warg config --keyring-backend linux-keyutils`
warg key new
```

<Callout title="WSL Ubuntu GLIB out of date" type="error">

If you are on Ubuntu LTS but encounter an error like `wkg: /lib/x86_64-linux-gnu/libm.so.6: version 'GLIBC_2.38' not found (required by wkg)`:

```bash
sudo do-release-upgrade
```
</Callout>

## Foundry

[Foundry](https://book.getfoundry.sh/) is a solidity development suite. The Foundry toolchain contains Anvil (a local testnet node), Forge (build and test smart contracts), Cast (an RPC call CLI), and Chisel (a Solidity REPL).


1. Install Foundryup, the official Foundry installer.

```bash docci-ignore
curl -L https://foundry.paradigm.xyz | bash
```

2. Install Foundry

```bash docci-ignore
foundryup
```

## Docker

Visit the [Docker Documentation](https://docs.docker.com/get-started/get-docker/) for more info.

<Tabs groupId="language" items={['MacOS', 'Linux']} persist>

  <Tab value="MacOS">
    ```bash docci-ignore
    brew install --cask docker
    ```
  </Tab>

  <Tab value="Linux">

  The following commands will install Docker and [Docker Compose](https://docs.docker.com/compose/).

    ```bash docci-ignore
    # Install Docker
    sudo apt -y install docker.io
    # Install Docker Compose
    sudo apt-get install docker-compose-v2
    ```
  </Tab>

</Tabs>

<Callout title="Docker for MacOS" type="warn">

{/* This section is also in [](./5-build.mdx). Remember to update there as well */}

If prompted, remove container with `sudo apt remove containerd.io`

If you are using Docker Desktop, make sure it is open and running for this tutorial.

Before proceeding, make sure that the following setting is updated:

**Enable Host Networking**: Open Docker and navigate to -> Settings -> Resources -> Network. Make sure that 'Enable Host Networking' is turned on.

Alternatively, you can install the following:

```bash docci-ignore
brew install chipmk/tap/docker-mac-net-connect && sudo brew services start chipmk/tap/docker-mac-net-connect
```

If you are running on a Mac with an ARM chip, you will need to do the following:

- Set up Rosetta:

```bash docci-ignore
softwareupdate --install-rosetta
```

- Enable Rosetta (Docker Desktop: Settings -> General -> enable "Use Rosetta for x86_64/amd64 emulation on Apple Silicon")

</Callout>

## Make

Visit the [Make Documentation](https://www.gnu.org/software/make/manual/make.html) for more info.


<Tabs groupId="language" items={['MacOS', 'Linux']} persist>

  <Tab value="MacOS">
    ```bash docci-ignore
    brew install make
    ```
  </Tab>

  <Tab value="Linux">
    ```bash docci-ignore
    sudo apt -y install make
    ```
  </Tab>

</Tabs>


## JQ

Visit the [JQ Documentation](https://jqlang.org/download/) for more info.

<Tabs groupId="language" items={['MacOS', 'Linux']} persist>

  <Tab value="MacOS">
    ```bash docci-ignore
    brew install jq
    ```
  </Tab>

  <Tab value="Linux">
    ```bash docci-ignore
    sudo apt -y install jq
    ```
  </Tab>

</Tabs>

## Node.js

Node v21+ is needed for the WAVS template. Visit the [NVM Installation guide](https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating) to install Node Version Manager and update your Node version.

```bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash
nvm install --lts
```

After setting up your system, continue to the next page to create your project.
````

## File: docs/tutorial/3-project.mdx
````
---
title: 3. Create your project
description: Creating and configuring WAVS project structure
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
docsignore-->

{/* todo: update --branch main once the template is updated */}

1. After setting up your environment, open a terminal and run the following command to create your WAVS Foundry Template project. In this example, your project will be called `my-wavs`.

```bash docci-ignore
forge init --template Lay3rLabs/wavs-foundry-template my-wavs --branch main
```

2. Then, enter your project:

```bash docci-ignore
cd my-wavs
```

3. Run the following command to open your project in VS code, or open it in the editor of your choice:

```bash docci-ignore
code .
```

## Explore the template

This template repo contains all the files you'll need to build, run, and test WAVS services locally.

The template already contains the necessary files for the oracle example to run. For example, the trigger ([`WavsTrigger.sol`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/src/contracts/WavsTrigger.sol)) and submission ([`WavsSubmit.sol`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/src/contracts/WavsSubmit.sol)) contracts can be found in the [`/my-wavs/src/contracts`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/src) folder.

In [`/evm-price-oracle/src/lib.rs`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/components/evm-price-oracle/src/lib.rs) you'll find the oracle service component.

This template uses a [`Makefile`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/Makefile) and environment variables to help with your developer experience. If you are ever curious about one of the `Make` commands in the following sections, you can always look at the [`Makefile`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/Makefile) to learn more.

<Callout title="Info" type="info">

You can run the following command from the root of the repo to see all of the commands and environment variable overrides available:

```bash docci-ignore
make help
```

</Callout>

The next sections will show you how to deploy your contracts and components, set up WAVS, and run the oracle example.


## Build and test your contracts

Run the following commands from the root of your project to install necessary dependencies, build the template contracts, and run tests using Forge.

```bash
# Install dependencies
make setup

# Build the contracts
forge build

# Run the solidity tests.
forge test
```

The last command runs a basic unit test which verifies that the `SimpleTrigger` contract in `/WavsTrigger.sol` correctly stores and retrieves trigger data.
````

## File: docs/tutorial/4-component.mdx
````
---
title: 4. Oracle component walkthrough
description: evm-price-oracle component walkthrough
---
<!--docsignore
import { HoverContainer } from "@/components/hover-container";
import { Callout } from 'fumadocs-ui/components/callout';
import { link } from "@/components/link.tsx";
docsignore-->

The core logic of the price oracle in this example is located in the [`/evm-price-oracle/src/lib.rs` file](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/components/evm-price-oracle/src/lib.rs). Scroll down to follow a walkthrough of the code for the oracle component.

## trigger.rs

The [trigger.rs](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/components/evm-price-oracle/src/trigger.rs) file handles the decoding of incoming trigger data from the trigger event emitted by the trigger contract. The component uses `decode_event_log_data!()` from the [wavs-wasi-utils crate](https://docs.rs/wavs-wasi-utils/latest/wavs_wasi_utils/) to decode the event log data and prepares it for processing within the WAVS component. Trigger.rs handles both ABI encoded data for trigger and submission data and raw data for local testing. For more information on different trigger types, visit the [Triggers page](../handbook/triggers). To learn more about trigger input handling, visit the [Component page](../handbook/components/component#trigger-inputs).

```rust trigger.rs
use crate::bindings::wavs::worker::layer_types::{
    TriggerData, TriggerDataEvmContractEvent, WasmResponse,
};
use alloy_sol_types::SolValue;
use anyhow::Result;
use wavs_wasi_utils::decode_event_log_data;

/// Represents the destination where the trigger output should be sent
pub enum Destination {
    Ethereum,
    CliOutput,
}

/// Decodes incoming trigger event data into its components
/// Handles two types of triggers:
/// 1. EvmContractEvent - Decodes Ethereum event logs using the NewTrigger ABI
/// 2. Raw - Used for direct CLI testing with no encoding
pub fn decode_trigger_event(trigger_data: TriggerData) -> Result<(u64, Vec<u8>, Destination)> {
    match trigger_data {
        TriggerData::EvmContractEvent(TriggerDataEvmContractEvent { log, .. }) => {
            let event: solidity::NewTrigger = decode_event_log_data!(log)?;
            let trigger_info =
                <solidity::TriggerInfo as SolValue>::abi_decode(&event._triggerInfo)?;
            Ok((trigger_info.triggerId, trigger_info.data.to_vec(), Destination::Ethereum))
        }
        TriggerData::Raw(data) => Ok((0, data.clone(), Destination::CliOutput)),
        _ => Err(anyhow::anyhow!("Unsupported trigger data type")),
    }
}

/// Encodes the output data for submission back to Ethereum
pub fn encode_trigger_output(trigger_id: u64, output: impl AsRef<[u8]>) -> WasmResponse {
    WasmResponse {
        payload: solidity::DataWithId {
            triggerId: trigger_id,
            data: output.as_ref().to_vec().into(),
        }
        .abi_encode(),
        ordering: None,
    }
}

/// The `sol!` macro from alloy_sol_macro reads a Solidity interface file
/// and generates corresponding Rust types and encoding/decoding functions.
pub mod solidity {
    use alloy_sol_macro::sol;
    pub use ITypes::*;

    // The objects here will be generated automatically into Rust types.
    sol!("../../src/interfaces/ITypes.sol");

    // Encode string input from the trigger contract function
    sol! {
        function addTrigger(string data) external;
    }
}
```

Visit the [Blockchain interactions page](../handbook/components/blockchain-interactions) for more information on the `sol!` macro and how to use it to generate Rust types from Solidity interfaces.

## Oracle component logic

The [`lib.rs`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/components/evm-price-oracle/src/lib.rs) file contains the main component logic for the oracle. The first section of the code imports the required modules for requests, serialization, and bindings, defines the component struct, and exports the component for execution within the WAVS runtime.

```rust lib.rs
mod trigger;
use trigger::{decode_trigger_event, encode_trigger_output, Destination};
use wavs_wasi_utils::{
    evm::alloy_primitives::hex,
    http::{fetch_json, http_request_get},
};
pub mod bindings;
use crate::bindings::{export, Guest, TriggerAction, WasmResponse};
use alloy_sol_types::SolValue;
use serde::{Deserialize, Serialize};
use wstd::{http::HeaderValue, runtime::block_on};
```

The `run` function is the main entry point for the price oracle component. WAVS is subscribed to watch for events emitted by the blockchain. When WAVS observes an event is emitted, it will internally route the event and its data to this function (component). The processing then occurs before the output is returned back to WAVS to be submitted to the blockchain by the operator(s).

This is why the `Destination::Ethereum` requires the encoded trigger output, it must be ABI encoded for the solidity contract.

After the data is submitted to the blockchain, any user can query the price data from the blockchain in the solidity contract. You can also return `None` as the output if nothing needs to be saved to the blockchain (useful for performing some off chain action).

The `run` function:

1. Receives a trigger action containing encoded data
2. Decodes the input to get a cryptocurrency ID (in hex)
3. Fetches current price data from CoinMarketCap
4. Returns the encoded response based on the destination

```rust lib.rs

struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {

    fn run(action: TriggerAction) -> std::result::Result<Option<WasmResponse>, String> {
        let (trigger_id, req, dest) =
            decode_trigger_event(action.data).map_err(|e| e.to_string())?;

        let hex_data = match String::from_utf8(req.clone()) {
            Ok(input_str) if input_str.starts_with("0x") => {
                // Local testing: hex string input
                hex::decode(&input_str[2..])
                    .map_err(|e| format!("Failed to decode hex string: {}", e))?
            }
            _ => {
                // Production: direct binary ABI input
                req.clone()
            }
        };

        let decoded = <String as SolValue>::abi_decode(&hex_data)
            .map_err(|e| format!("Failed to decode ABI string: {}", e))?;

        let id =
            decoded.trim().parse::<u64>().map_err(|_| format!("Invalid number: {}", decoded))?;

        let res = block_on(async move {
            let resp_data = get_price_feed(id).await?;
            println!("resp_data: {:?}", resp_data);
            serde_json::to_vec(&resp_data).map_err(|e| e.to_string())
        })?;

        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
            Destination::CliOutput => Some(WasmResponse { payload: res.into(), ordering: None }),
        };
        Ok(output)
    }
}
```

Visit the [Component page](../handbook/components/component) for more information on the `run` function and the main requirements for component structure.

## Fetching price data

The `get_price_feed` function is responsible for fetching price data from CoinMarketCap's API. It takes the cryptocurrency ID passed from the trigger as input and returns a structured `PriceFeedData` containing the symbol, current price in USD, and server timestamp. For more information on making network requests in WAVS components, visit the [Network Requests page](../handbook/components/network-requests).

```rust lib.rs
async fn get_price_feed(id: u64) -> Result<PriceFeedData, String> {
    let url = format!(
        "https://api.coinmarketcap.com/data-api/v3/cryptocurrency/detail?id={}&range=1h",
        id
    );

    let current_time = std::time::SystemTime::now().elapsed().unwrap().as_secs();

    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    req.headers_mut()
        .insert("User-Agent", HeaderValue::from_static("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36"));
    req.headers_mut().insert(
        "Cookie",
        HeaderValue::from_str(&format!("myrandom_cookie={}", current_time)).unwrap(),
    );

    let json: Root = fetch_json(req).await.map_err(|e| e.to_string())?;

    // round to the nearest 3 decimal places
    let price = (json.data.statistics.price * 100.0).round() / 100.0;
    // timestamp is 2025-04-30T19:59:44.161Z, becomes 2025-04-30T19:59:44
    let timestamp = json.status.timestamp.split('.').next().unwrap_or("");

    Ok(PriceFeedData { symbol: json.data.symbol, price, timestamp: timestamp.to_string() })
}
```

## Handling the response

The processed price data is returned as a `WasmResponse` which contains the response payload. The response is formatted differently based on the destination.

```rust lib.rs
let output = match dest {
    Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
    Destination::CliOutput => Some(WasmResponse { payload: res.into(), ordering: None }),
};
Ok(output)
```
- For `Destination::CliOutput`, the raw data is returned directly for local testing and debugging using the `wasi-exec` command.
- For `Destination::Ethereum`, the data is ABI encoded using `encode_trigger_output`. This ensures that processed data is formatted correctly before being sent to the [submission contract](../handbook/submission).

In `trigger.rs`, the `WasmResponse` struct is used to standardize the format of data returned from components. The `payload` field contains the processed data from the component.

```rust trigger.rs
pub fn encode_trigger_output(trigger_id: u64, output: impl AsRef<[u8]>) -> WasmResponse {
    WasmResponse {
        payload: solidity::DataWithId {
            triggerId: trigger_id,
            data: output.as_ref().to_vec().into(),
        }
        .abi_encode(),
        ordering: None,
    }
}
```

For more information on component outputs, visit the [Component page](../handbook/components/component#component-output). To learn more about submission logic, visit the [Submission page](../handbook/submission).

The Service handbook contains more detailed information on each part of developing services and components. Visit the [Service handbook overview](../handbook/overview) to learn more.

## Next steps

Continue to the [next section](./5-build) to learn how to build and test your component.
````

## File: docs/tutorial/5-build.mdx
````
---
title: 5. Build and test components
description: Building and testing WAVS service components
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
docsignore-->

<Callout title="Before proceeding" type="warn">

{/* This section is also in [](./2-setup.mdx). Remember to update there as well */}

1. Make sure that Docker is installed. If you are using Docker Desktop, make sure it is open and running. If you are using Mac OS, make sure that your[ Docker app is configured correctly](./2-setup#docker).

2. Make sure that you have already run the following commands from the [system setup section](./2-setup#cargo-components).

```bash docci-ignore
cargo install cargo-binstall
cargo binstall cargo-component wasm-tools warg-cli wkg --locked --no-confirm --force

# Configure default registry
wkg config --default-registry wa.dev

# Allow publishing to a registry
#
# if WSL: `warg config --keyring-backend linux-keyutils`
warg key new
```


</Callout>

## Build components

Run the following command in your terminal to build your component. Exclude `WASI_BUILD_DIR` to build all components.

```bash docci-if-file-not-exists="./compiled/evm_price_oracle.wasm"
WASI_BUILD_DIR=components/evm-price-oracle make wasi-build
```

This command will build any components present in the `/components` directory, as well as auto-generate bindings and compile the components to WASM. The output will be placed in the `compiled` directory.

<Callout title="Build command" type="info">
You can also use the command below to build your solidity contracts and components in one command:


```bash docci-if-file-not-exists="./compiled/evm_price_oracle.wasm"
make build
```

</Callout>

## Testing and debugging

You can use the following command to execute the component using Cast. This command is handy for testing components without having to deploy WAVS.

An ID of 1 is Bitcoin. Nothing will be saved on-chain, just the output of the component is shown.


```bash
make wasi-exec
```

This command runs your component locally in a simulated environment and lets you easily view `print` statements for debugging. Running this command in the oracle example will print the information from the oracle [component code](./4-component). Visit the [component walkthrough](../handbook/components/component#logging-in-a-component) for more information on logging during testing and production.


Upon successful execution, you should receive a result similar to the following:

```bash docci-ignore
resp_data: Ok(PriceFeedData { symbol: "BTC", timestamp: "2025-02-14T01:23:03.963Z", price: 96761.74120116462 })
 INFO Fuel used:
1477653

Result (hex encoded):
7b2273796d626f6c223a22425443222c2274696d657374616d70223a22323032352d30322d31345430313a32333a30332e3936335a222c227072696365223a39363736312e37343132303131363436327d

Result (utf8):
{"symbol":"BTC","timestamp":"2025-02-14T01:23:03.963Z","price":96761.74120116462}
```

<Callout title="Fuel" type="info">

In the output above, the `INFO Fuel used` value represents the computational power consumed during execution. Similar to how on-chain transactions have a gas limit to cap transaction costs, WAVS enforces a fuel limit to control off-chain computational workload and protect against DoS attacks.

The maximum fuel allocation can be adjusted in the `Makefile` to accommodate different processing needs.

</Callout>
````

## File: docs/tutorial/6-run-service.mdx
````
---
title: 6. Run your service
description: Deploying and running WAVS services
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
docsignore-->

## Local: Start Anvil, WAVS, and deploy Eigenlayer

1. Create a `.env` file for your project by copying over the example with the following command:

```bash
cp .env.example .env
```

2. Use the following command to start an Anvil test chain, IPFS, Registry, and some optional telemetry. This only runs with `LOCAL` being set in the `.env` (default).

```bash docci-background docci-delay-after=5
make start-all-local
```

<Callout title="Keep WAVS running" type="info">

The command must remain running in your terminal. Open another terminal to run other commands.

You can stop the services with `ctrl+c`. Some MacOS terminals require pressing this twice.

</Callout>

<Callout title="Run super simple" type="info">

You can skip all the setup steps below and just run a single command to deploy and run the entire service setup

```bash
export RPC_URL=`bash ./script/get-rpc.sh`
export AGGREGATOR_URL=http://127.0.0.1:8001

bash ./script/deploy-script.sh
```

This performs all the below steps (with the exception of actually triggering the contract).

</Callout>

With the chain running, you can deploy and run your service.

## Create Deployer

An account is required to upload the contracts and to be the original admin of them. The `create-deployer.sh` script creates a new wallet then sets a balance if using a local deployment, or waits until it has testnet funds before returning.

You can skip this step by setting `FUNDED_KEY=` in `.env` to a private key of your choice that has network funds.

```bash docci-delay-after=2
bash ./script/create-deployer.sh
```

## Deploy EigenLayer Middleware

Local deployments use the real testnet contracts via a forked anvil instance. This middleware will setup all the required contracts and configurations for the base of your AVS.

```bash docci-delay-after=2
COMMAND=deploy make wavs-middleware
```

## Deploy solidity contracts

The `deploy-contracts.sh` script is used to deploy the trigger and submission solidity contracts to the chain.

```bash docci-delay-per-cmd=2
source script/deploy-contracts.sh
```

## Deploy Service

Deploy the compiled component with the contract information from the previous steps.

```bash docci-delay-per-cmd=3
export COMPONENT_FILENAME=evm_price_oracle.wasm
export PKG_NAME="evmrustoracle"
export PKG_VERSION="0.1.0"
# ** Testnet Setup: https://wa.dev/account/credentials/new -> warg login
source script/upload-to-wasi-registry.sh || true

# Testnet: set values (default: local if not set)
# export TRIGGER_CHAIN=holesky
# export SUBMIT_CHAIN=holesky

# Package not found with wa.dev? -- make sure it is public
export AGGREGATOR_URL=http://127.0.0.1:8001
REGISTRY=${REGISTRY} source ./script/build-service.sh
```

The build-service.sh script is used to create a service manifest (service.json) with the configuration for the service, including a workflow with the trigger event, component, aggregator, submission logic, and more. Visit the [Service handbook](../handbook/service) for more information on service configuration.

## Upload to IPFS

The `ipfs-upload.sh` script is used to upload the service manifest to IPFS where it can be referenced by its URI.

```bash docci-delay-per-cmd=2
# Upload service.json to IPFS
SERVICE_FILE=.docker/service.json source ./script/ipfs-upload.sh
```

## Aggregator

Start the [aggregator](../handbook/submission#aggregator) and register the service with the aggregator. The aggregator is used to collect and validate responses from multiple operators before submitting them to the blockchain.

```bash docci-delay-per-cmd=2
bash ./script/create-aggregator.sh 1

IPFS_GATEWAY=${IPFS_GATEWAY} bash ./infra/aggregator-1/start.sh

wget -q --header="Content-Type: application/json" --post-data="{\"uri\": \"${IPFS_URI}\"}" ${AGGREGATOR_URL}/register-service -O -
```

## Start WAVS

Create an operator and start WAVS. The create-operator.sh script configures the operator's environment and starts running WAVS.

```bash
bash ./script/create-operator.sh 1

IPFS_GATEWAY=${IPFS_GATEWAY} bash ./infra/wavs-1/start.sh

# Deploy the service JSON to WAVS so it now watches and submits.
# 'opt in' for WAVS to watch (this is before we register to Eigenlayer)
WAVS_ENDPOINT=http://127.0.0.1:8000 SERVICE_URL=${IPFS_URI} IPFS_GATEWAY=${IPFS_GATEWAY} make deploy-service
```

## Register service specific operator

Each service gets its own key path (hd_path). The first service starts at 1 and increments from there. The following commands are used to register the operator with the [service manager contract](../handbook/service#service-manager).

```bash
SERVICE_INDEX=0 source ./script/avs-signing-key.sh

# Local:
export WAVS_SERVICE_MANAGER_ADDRESS=$(jq -r .addresses.WavsServiceManager ./.nodes/avs_deploy.json)
# TESTNET: set WAVS_SERVICE_MANAGER_ADDRESS

COMMAND="register ${OPERATOR_PRIVATE_KEY} ${AVS_SIGNING_ADDRESS} 0.001ether" make wavs-middleware

# Verify registration
COMMAND="list_operators" PAST_BLOCKS=500 make wavs-middleware
```

## Trigger the service

Next, use your deployed trigger contract to trigger the oracle to be run. In the following command, you'll specify the `INPUT_DATA` as abi encoded `1`, which corresponds to the ID of Bitcoin.

Running this command will execute [`/script/Trigger.s.sol`](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/script/Trigger.s.sol) and pass the ID to the trigger contract, starting the following chain of events:

1. The trigger contract will emit an event with the specified ID as its data.
2. Operators listening for the event will receive the data and run it in the oracle component off-chain.
3. The oracle component will use the ID to query the price of Bitcoin from the CoinMarketCap API.
4. The returned data will be signed by operators and passed to the [aggregator and then the submission contract](../handbook/submission), which will verify the operator's signature and submit the price of Bitcoin on-chain 🎉


```bash docci-delay-per-cmd=2
# Request BTC from CMC
export INPUT_DATA=`cast abi-encode "addTrigger(string)" "1"`
# Get the trigger address from previous Deploy forge script
export SERVICE_TRIGGER_ADDR=`make get-trigger-from-deploy`

# uses FUNDED_KEY as the executor (local: anvil account)
source .env

forge script ./script/Trigger.s.sol ${SERVICE_TRIGGER_ADDR} ${INPUT_DATA} --sig 'run(string,string)' --rpc-url ${RPC_URL} --broadcast
```

## Show the result

Run the following to view the result of your service in your terminal:

```bash docci-delay-per-cmd=2 docci-output-contains="BTC"
# Get the latest TriggerId and show the result via `script/ShowResult.s.sol`
TRIGGER_ID=1 RPC_URL=${RPC_URL} make show-result
```

Congratulations, you've just made a simple Bitcoin price oracle service using WAVS!

Proceed to the [Prediction Market demo](./7-prediction) to learn how a similar oracle service can be used in a prediction market.

Check out the [Service handbook](../handbook/overview) to learn more about services and creating components.
````

## File: docs/tutorial/7-prediction.mdx
````
---
title: 7. Prediction market
description: prediction market demo overview
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
docsignore-->

{/* todo: verify the info in this page and update if needed */}
Now that you've built a simple oracle service, take a look at the [WAVS Demo Repo](https://github.com/Lay3rLabs/wavs-demos/blob/main/demos/PREDICTION_MARKET_DEMO.md) to see a similar component used in action to resolve a prediction market.

This page will give an overview of the prediction market demo, how it works, and how the oracle component is used to resolve markets.

Prediction market demo repo: https://github.com/Lay3rLabs/wavs-demos/tree/main

## What is a prediction market?

A prediction market is a marketplace that gathers insights about the future by rewarding participants for making accurate predictions based on available information. For example, a prediction market could be created for whether it will snow in Oslo on November 5th. Users can create positions by depositing money based on two outcomes: yes or no. After the event transpires, an oracle service can be used to bring in the weather outcome, resolving the market and rewarding those who predicted correctly.

## How does it work?

### Market Solidity contracts

These contracts handle the creation of markets and conditional tokens.

[`conditional-tokens-contracts`](https://github.com/Lay3rLabs/conditional-tokens-contracts) - these contracts are forked from Gnosis and updated to a recent Solidity version, and they are the core protocol that creates a conditional share in a future outcome.

[`conditional-tokens-market-makers`](https://github.com/Lay3rLabs/conditional-tokens-market-makers) - these contracts are forked from Gnosis and updated to a recent Solidity version, and they are the market makers that create a market based on the conditional shares above.

[`PredictionMarketFactory.sol`](https://github.com/Lay3rLabs/wavs-prediction-market/blob/main/src/contracts/PredictionMarketFactory.sol) - this contract sets up all the contracts required for a functioning prediction market using the forked contracts above, and it has the power to resolve the market once the outcome is determined by the oracle AVS.

### Extending the trigger contract

In this demo, the oracle that resolves the market is triggered by the [`PredictionMarketOracleController.sol`](https://github.com/Lay3rLabs/wavs-prediction-market/blob/main/src/contracts/PredictionMarketOracleController.sol) contract.

This contract contains modifications to the `WavsTrigger.sol` contract from the [WAVS Foundry Template repo](https://github.com/Lay3rLabs/wavs-foundry-template/tree/main/src/contracts/WavsTrigger.sol). Similar to the simple trigger contract, it passes data to the oracle AVS via the `NewTrigger` event.

It extends the contract by storing trigger metadata, validating signed AVS outputs, and interacting with the external contracts mentioned above (`PredictionMarketFactory`, `MarketMaker`, and `ConditionalTokens`).

It also contains logic to enforce a payment when a trigger is added:

```rust
function addTrigger(
        TriggerInputData calldata triggerData
    ) external payable returns (ITypes.TriggerId triggerId) {
        require(msg.value == 0.1 ether, "Payment must be exactly 0.1 ETH");
```

Take a look at the [`PredictionMarketOracleController.sol`](https://github.com/Lay3rLabs/wavs-prediction-market/blob/main/src/contracts/PredictionMarketOracleController.sol) file to get an idea of how the contract is structured.

This contract is responsible for interacting with the oracle service, triggering WAVS to run the oracle, waiting for the oracle's response, and telling the market factory to resolve the market.

### Oracle WASI component

Similar to the oracle you created in the tutorial, the prediction market uses a simple oracle service to resolve a market by bringing off-chain data on-chain.

This[ WASI component](https://github.com/Lay3rLabs/wavs-prediction-market/blob/main/components/prediction-market-oracle/src/lib.rs) runs in WAVS and fetches the prediction market's resolution when necessary. A wallet executes the [`PredictionMarketOracleController.sol`](https://github.com/Lay3rLabs/wavs-prediction-market/blob/main/src/contracts/PredictionMarketOracleController.sol#L65) contract's `addTrigger` function, which triggers WAVS to run this oracle by emitting an event. Then, WAVS commits the response from this oracle component with a signature back to the contract on-chain, and the market is resolved.

Below is the `run` function for the Prediction Market oracle component. This function is responsible for fetching the price of Bitcoin and resolving the market based on the price.

```rust
impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<WasmResponse>, String> {
        let market_maker_address =
            config_var("market_maker").ok_or_else(|| "Failed to get market maker address")?;
        let conditional_tokens_address = config_var("conditional_tokens")
            .ok_or_else(|| "Failed to get conditional tokens address")?;

        let trigger_info = decode_trigger_event(action.data)?;

        let bitcoin_price = block_on(get_price_feed(1))?;

        // Resolve the market as YES if the price of Bitcoin is over $1.
        let result = bitcoin_price > 1.0;

        Ok(Some(WasmResponse {
            payload: encode_trigger_output(
                trigger_info.triggerId,
                Address::from_str(&market_maker_address).unwrap(),
                Address::from_str(&conditional_tokens_address).unwrap(),
                result,
            ),
            ordering: None,
        }))
    }
}
```

Performing this market resolution via WAVS means prediction markets can exist in a fully decentralized manner. Because money is on the line, entrusting any party to honestly resolve the market is a critical security decision—WAVS enables distributing this trust over multiple independent parties, taking advantage of the verifiability and security of the existing WAVS infrastructure instead of relying on any centralized individual.

## Try it out

You can run the prediction market demo locally by following the steps from the [README](https://github.com/Lay3rLabs/wavs-prediction-market/tree/main).

Follow along in the video tutorial to see how to run the prediction market demo locally:



   <div style={{display: "flex", justifyContent: "center", alignItems: "center", paddingBottom: "2em"}}>
     <iframe width="560" height="315" src="https://www.youtube.com/embed/BT0CjXCJhbY" title="WAVS Tutorial" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
   </div>
````

## File: docs/benefits.mdx
````
---
title: WAVS benefits
description: Key advantages and use cases of WAVS platform
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
docsignore-->

<img alt="WAVS" src="https://raw.githubusercontent.com/Lay3rLabs/WAVS-docs/refs/heads/main/public/banners/benefits.png" />

>WAVS is a platform that makes building AVSs easier.

**The problem**: creating an AVS the traditional way is complicated. It requires a lot of preliminary development work, such as building custom contracts, scaffolding infrastructure, working with Dockerized components, and coordinating with operators. Most of the development centers around creating AVS infrastructure, which is generally more complicated than the core logic of the service itself.

**There is an easier way**: WAVS provides a base layer of AVS infrastructure so you can focus solely on creating the core logic of your service. This logic is written in Rust (with other languages available soon) and compiled as a lightweight WASI component which can be deployed to the WAVS platform and run as an AVS by operators. These components are run off-chain by operators in the WAVS (WASI-AVS) runtime at near-native speed, and the results are brought verifiably on-chain. A service of services, WAVS allows an AVS to dynamically run and manage multiple components that work together to build flexible and intelligent applications.

## Why WAVS?

WAVS redefines the AVS paradigm, making AVSs easier to build, less expensive to run, and enabling the next generation of composable, intelligent blockchain protocols.

1. Dynamic and Cost-Effective Service Management
    - Flexibility: Add, update, or manage components dynamically without having to coordinate upgrades with an entire operator set.
    - Cost-effective and performant: Multiple AVSs run on the WAVS runtime
        - WASI service components are lightweight compared to Docker, saving storage and startup time.
        - WASI components have instantaneous initialization vs. Docker's redundant OS layers and slower boot times.
2. Simplified Development
    - Focus on your application logic, not overhead:
        - With templates, there's no need to write multiple custom contracts to parse events or aggregate signatures.
        - WAVS handles common AVS infrastructure, leaving AVS developers to focus on their core logic.
3. Multichain Ready
    - WAVS is built to operate across multiple blockchain environments and will be released with support for EVM networks.
    - WAVS will foster a multichain ecosystem for AVSs to interact and interoperate.
4. Intelligent Protocols & Composability
    - Enable asynchronous, verifiable execution flows across multiple on and off-chain components.
    - Compose multiple services to create dynamic intelligent protocols that surpass the limitations of traditional smart contracts.
````

## File: docs/design.mdx
````
---
title: WAVS design considerations
description: Best practices and design patterns for WAVS services
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

The WAVS approach to AVS design focuses on the lightweight and agile nature of components, with an emphasis on performance and security.

WAVS works best with the "serverless function" approach, wherein the priority of service component logic is to process data from external sources rather than store it locally. In this model, a component can receive input data from external sources, process it, and submit the verifiable outputs to external sources.

## Aggregation and deterministic queries

WAVS currently supports "exact match" [aggregation](./handbook/submission#aggregator), meaning that consensus is reached if a threshold amount of submitted responses from operators are identical. This approach fits many common use cases, but it means that developers must build their components to receive and process data only from deterministic or immutable sources, such as:

- Data from the input event trigger
- Ethereum queries at a given block height
- IPFS data or other Content-Addressable Storage
- Web2 APIs that are trusted to return the same result on every query
- Seeded application parameters (e.g. Ollama for AI models)

For example, when designing a price oracle, a **blockheight** or **timestamp** should be specified in the query logic. This ensures that the query is deterministic and that the same data point is retrieved by all operators.

Conversely, a component that is designed to fetch "current price" would be non-deterministic and may result in a consensus error. Operators may run components at slightly different times, leading to discrepancies in the data they receive. This design should be avoided, as aggregation for this would require custom BFT averaging logic which is not currently supported. However, adding custom logic to process non-exact matches will be available in future releases.

## State

Persistent state introduces additional challenges in AVS design with WAVS: operators may execute triggers at different times or, in some cases, not run them at all if they join an AVS after it has been running for some time. Components that rely on operator-local mutable state risk failing consensus due to inconsistencies in execution. For these reasons, it is best practice to avoid storing operator-local mutable state within your components.

This functionality would require features such as state synchronization (P2P), guaranteed execution ordering, and Merkle-proof validation which are not yet supported.

## Caching

WAVS provides components with an optional local data directory that can be used for caching. This storage method should only be used to cache data as a performance optimization and not as a replacement for external state stores.

It is best practice when using a cache to reference external data from deterministic immutable sources to avoid consensus failures.

Keep the following points in mind when using cached data:

1. Caching should be used as a performance optimization only.
2. Use immutable or deterministic external data sources with specific time stamps or block heights.
3. Design your component logic to work even if the cache is cleared. Cache state is not shared among operators, and any operator should be able to rebuild the cache from scratch.
4. Don't use caching to store state that depends on previous executions or mutable data.
````

## File: docs/how-it-works.mdx
````
---
title: How it works
description: Technical overview of WAVS architecture and components
---
<!--docsignore
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
docsignore-->

<img alt="WAVS" src="https://raw.githubusercontent.com/Lay3rLabs/WAVS-docs/refs/heads/main/public/banners/how.png" />

WAVS is a decentralized execution framework for AVSs (Autonomous Verifiable Services), enabling the results of off-chain computation to be brought verifiably on-chain. It provides a runtime for executing WASI-based service components, allowing developers to define event-driven off-chain workflows while inheriting Ethereum's security via EigenLayer restaking.

## The flow

Before diving into each part of a WAVS service individually, it's important to understand the basic execution flow of WAVS.

<img alt="WAVS overview" src="https://raw.githubusercontent.com/Lay3rLabs/WAVS-docs/refs/heads/main/public/diagrams/workflows.png" />

1. A service is a collection of on-chain contracts and off-chain logic run by a set of registered operators, bringing the results of off-chain computation on-chain verifiably. A service's operator set is defined in a service manager contract. A service manifest (service.json) defines the configuration and different parts of a WAVS service, including information about the service, workflows, components, submission, watch trigger, aggregator, and more. The service contracts and manifest are deployed and operators register to run the service.

2. Services contain one or more workflows, which define the different execution paths in your service. Each workflow contains a trigger, a service component, and submission logic. Triggers are defined events that activate a workflow. Registered operators running WAVS nodes maintain lookup maps to track and detect triggers. Triggers can be:
   - Any on-chain EVM or Cosmos event from a specified contract address and event signature
   - Cron jobs that activate at specified intervals
   - Blockheight triggers that activate at a specified block height on EVM or Cosmos chains

3. When a trigger is detected, operators run the workflow's corresponding service component off-chain in the WAVS runtime.

4. Each operator signs the result of their off-chain computation and submits it to the aggregator.

5. The aggregator accepts results from the operators and verifies that the result payloads match and that the signatures are valid. Once enough verified submissions are received (the threshold is defined in the service manager), the aggregator submits the bundled signatures and result payloads as a single transaction to the submission contract specified in the service's manifest.

6. The `handleSignedEnvelope()` function on the submission contract validates the data and signatures via the service manager contract. The workflow is complete, bringing the result of the off-chain computation verifiably on-chain. Services and workflows can be chained together by setting the submission event of one workflow to be the trigger of another.

## WAVS parts

### Service manager

The service manager is a contract that defines a service's operator set. It is used to register operators and define their weights, set the threshold for aggregator submissions, and maintain the URI of the service manifest. For more information, see the [Service page](./handbook/service#service-manager).

### Service manifest

The service manifest is a JSON file that defines the configuration and different parts of a WAVS service, including information about the service, workflows, components, submission, service manager contract, aggregator configuration, and more. For more information, see the [Service page](./handbook/service).

### Workflows

Workflows are the building blocks of a WAVS service flow. They define the different execution paths of a service, including the trigger, component, and submission logic. For more information, see the [Workflows page](./handbook/workflows).

### Triggers

A trigger is the event that activates a WAVS service. Triggers can be EVM or Cosmos events, cron, or blockheight triggers. When a specified event is triggered, WAVS operators detect it and execute the corresponding service component off-chain. The results are then verified and submitted back on-chain, completing the execution cycle. For more information, see the [Triggers page](./handbook/triggers).

### Service components

Service components are the heart of the WAVS platform, encapsulating the core logic that powers a service. They contain the off-chain business logic for a service, [written in Rust, Go, or JavaScript](./handbook/components/component#component-languages) (with other languages coming soon). These service components are compiled to WASM and are uploaded to the WAVS platform where they can be run by operators. In the WAVS runtime, service components are sandboxed from each other and from the node's operating system. This way, operators and AVS services maintain a clean separation, with AVS builders defining service components and operators having to opt in to each service.

Service components are lightweight and built for adaptability. Building a service used to take thousands of lines of code and the configuration of dozens of files to execute even the simplest logic. With WAVS, service components can consist of a few lines of code that can be dynamically deployed to the WAVS platform.

Service components are also designed for composability: an AVS can chain multiple components together, creating decentralized flows of off-chain and on-chain executions. These intelligent protocols merge the performance of off-chain computation with on-chain verifiability, creating a complex mesh of decentralized transaction flows.

To learn more, visit the [Components page](./handbook/components/component). For a hands-on example of a service component, visit the [tutorial](./tutorial/1-overview).

### WAVS runtime

The WAVS (WASI-AVS) runtime serves as the off-chain execution environment for all services running on the WAVS platform. Powered by operators running the WAVS node software, it provides a structured framework for deploying and managing service components that run within a WASI (WebAssembly System Interface) environment. You can think of WASI as a lightweight OS-like interface, offering a standard set of APIs that allow service components to perform system-level operations such as file handling and environment interactions. WAVS enables service components to execute securely within this WASI-powered sandbox, ensuring isolation from both the host system and other components.

### WASM and WASI

[WASM (Web Assembly)](https://webassembly.org/) is a high-performance, low-level binary format that can be compiled from multiple programming languages. WASM can even run in web browsers at near-native speed. By leveraging WASM, AVSs built with WAVS are lightning-fast, lightweight, and easy to develop.

WASI (WebAssembly System Interface) is a standardized API that enables WASM (WebAssembly) modules to interact with a host system in a secure and platform-independent way. It provides WASM modules with a standardized set of APIs to access system resources. For more information, visit the [WASI documentation](https://wasi.dev/).

There are significant advantages in leveraging a WASM/WASI-based platform for AVSs:

- Lightweight execution: Service components are lightweight WASM binaries ideal for high-frequency, low-latency AVS tasks.
- Speed: Components can run in the WASI environment at near-native speeds, providing a significant advantage over Dockerized AVSs.
- Low overhead: Instead of each service needing its own dedicated Docker container, the WAVS runtime provides a computational layer that can be used by many components, saving storage and startup time.
- Dynamic deployment: To upgrade a service, simply upload a new component and update your service metadata to point to the new component. No more downtime or coordination of new binaries among operators.
- Security and separation: The WAVS WASI runtime enforces security by sandboxing service components, allowing them to interact with the host (WAVS) only through explicitly permitted WASI APIs.

### Registry

WAVS uses a registry to store the WASM components. A service like [wa.dev](https://wa.dev) is recommended for proper distribution in production. For more information, visit the [Component page](./handbook/components/component#registry).

### Signing and aggregation

When a service is triggered, each operator registered to the service will run the service component on their machine and generate the result. These results are signed by the operator before being submitted to an aggregator.

For services that submit results on Ethereum, an off-chain aggregator can be used to conserve gas fees. Instead of each individual operator submitting results of a service directly on-chain, operators sign the results and submit them off-chain to an aggregator, which aggregates the results and submits a result to be posted to the chain in a single transaction. Results are signed using an operator's individual private key to produce an signature, which is used to prove that the result is associated with an operator's specific private and public key pair. The aggregator accepts the result submissions from operators, verifies their validity, and compares the responses. If there is a consensus among valid operator results, the results and verified signatures are submitted on-chain as a single transaction. Support for BLS signatures and a decentralized aggregator are currently under development.

To learn more about the aggregator, visit the [Submission and aggregator page](./handbook/submission#aggregator). For more discussion on aggregation considerations, visit the [Design considerations page](./design).

### Submission

A submission contract is the final destination of the results of a service component. Known as a Service Handler, this logic can be any contract as long as it implements the [`handleSignedEnvelope()` function using the `IWavsServiceHandler`](./handbook/submission#submission-contract) interface to validate data and signatures using the service manager.

After the execution of a service component in the WAVS runtime, the results are aggregated in the [aggregator](./handbook/submission#aggregator) and passed to the submission contract. Developers can use this contract to define their own logic for results and implement different rules depending on the specific needs of their service.

To learn more about the submission contract, visit the [Submission page](./handbook/submission).

### Updating a service

Because of the lightweight and portable nature of WebAssembly, WAVS operators only need to run a single Docker image. WAVS provides a runtime for all registered services to run, each sandboxed from the other and from the node's operating system due to the nature of [WASI](#wasm-and-wasi). Operators will need to opt in to running different services by registering to an AVS.

Updates to service logic do not require node upgrades. Instead, developers can dynamically deploy a new service component and update their service manifest. Instead of needing to run a new Docker image every time a service is updated, operators only need to upgrade if there is a breaking change to the WAVS node software itself.
````

## File: docs/index.mdx
````
---
title: WAVS Docs
description: Welcome page with links to WAVS documentation sections
---
<!--docsignore
import { HomeIcon, AppWindow, CircuitBoard, Layers, Microscope, Grid2x2, ChevronRight } from 'lucide-react';
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

<img alt="WAVS" src="https://raw.githubusercontent.com/Lay3rLabs/WAVS-docs/refs/heads/main/public/wavs.png" />

Welcome to the WAVS Docs!

WAVS is a next-generation AVS platform that makes it easy to create, manage, and operate high-performance AVSs. Use this documentation to learn [about WAVS](/overview), [how it works](/how-it-works), and how to [start building your AVS](./tutorial/1-overview).

<!--docsignore
## Get started

<Cards>
  <Card
    icon={<CircuitBoard />}
    href="/overview"
    title="WAVS Overview"
    description="Learn about WAVS"
  />
  <Card
    icon={<Microscope />}
    href="/how-it-works"
    title="How it works"
    description="Explore the inner workings of WAVS"
  />
    <Card
    icon={<ChevronRight />}
    href="/benefits"
    title="WAVS Benefits"
    description="Discover how WAVS revolutionizes AVS creation"
  />
      <Card
    icon={<Layers />}
    href="/tutorial/1-overview"
    title="Build a service"
    description="Follow the WAVS tutorial to build a service"
  />

</Cards>
docsignore-->
````

## File: docs/overview.mdx
````
---
title: Overview
description: Introduction to WAVS platform and its core concepts
---
<!--docsignore
import { HomeIcon, AppWindow, CircuitBoard, Layers, Microscope, Grid2x2, ChevronRight } from 'lucide-react';
import { Callout } from 'fumadocs-ui/components/callout';
import { DocsPage } from 'fumadocs-ui/page';
docsignore-->

<img alt="WAVS" src="https://raw.githubusercontent.com/Lay3rLabs/WAVS-docs/refs/heads/main/public/banners/intro.png" />

## What is WAVS?

WAVS is a [WASI](./how-it-works#wasm-and-wasi) runtime for building AVSs (Autonomous Verifiable Services). With WAVS, you can create, manage, and operate high-performance AVSs using the languages you already know and love (like [Rust, Go, and JavaScript](./handbook/components/component#languages), with more languages like Python coming soon). By providing a base layer of AVS infrastructure, WAVS lets you focus on implementing the core logic of your service. WAVS compiles that logic to [WASM](./how-it-works#wasm-and-wasi), and lets you deploy it as lightweight service components.

Better yet, WAVS solves the trust problem in off-chain compute: it separates services from the operators that run them. Builders create their components, and operators run them in WAVS runtime at near-native speed. Then, operators sign the results of the off-chain computation and place them on-chain. Boom: off-chain compute with on-chain verifiability.

> In simple terms, WAVS streamlines the process of building and managing an AVS.

Finally, WAVS utilizes restaking (via EigenLayer) to secure its AVSs. A service of services, WAVS is composable by nature, allowing an AVS to dynamically run and manage multiple components that work together to build flexible and intelligent applications.


## Use cases

WAVS supports a wide range of AVS use cases, enabling powerful, verifiable off-chain computation across different domains:

- **Decentralized AI**: WAVS unlocks decentralized AI that is [deterministic and verifiable](https://www.layer.xyz/news-and-insights/deterministic-ai), enabling trustless decision-making and autonomous governance through DAO-controlled AI agents.
- **Oracles**: [Create](./tutorial/1-overview) and dynamically deploy new oracles as easily as uploading a component to your service to verifiably bring data from any source on-chain.
- **Zero Knowledge Proofs**: ZK verifiers, ZK Prover Marketplaces, and ZK aggregation layers can be deployed as lightweight WAVS [service components](#service-components), making it simple to build modular and composable proof services.
- **Crosschain Bridges**: Build secure, decentralized bridges with WAVS. Lock assets on one chain, trigger a verifiable service component, and mint them on another—all with trust-minimized execution.
- **Dynamic applications**: WAVS combines on-chain and off-chain services to build a cross-chain, decentralized application layer.
- **Intelligent protocols**: Build protocols that are verifiably aware of on-chain and off-chain events without relying on centralized infrastructure. Compose services and applications to enable complex webs of decentralized transaction flows.
- **TEEs**: WAVS can be used to build TEEs (Trusted Execution Environments) that run off-chain computations in a secure and verifiable manner, ensuring data integrity and confidentiality.

## Building a service

WAVS removes the complexity of building an AVS, making it easy to develop and deploy custom services. With built-in AVS infrastructure and developer tooling, WAVS powers a new multichain ecosystem of composable, decentralized, and verifiable applications.

<Callout title="Learn more" type="info">
The following is a basic overview of a WAVS service. For a more in-depth overview of WAVS, visit the [How it works section](./how-it-works). Check out the WAVS tutorial to learn how to build a service.
</Callout>

This example will cover a basic AVS with three parts: a trigger, a service component, and submission logic.

### Defining triggers

Triggers are the actions or events that prompt your service to be run. Currently, WAVS supports triggers from on-chain events from EVM and Cosmos chains, cron schedules, and block intervals for EVM or Cosmos chains. Triggers can be used to pass arbitrary data as the inputs for service components to be run. Operators running a service listen for specific trigger events and run the corresponding service component.

<img alt="WAVS" src="https://raw.githubusercontent.com/Lay3rLabs/WAVS-docs/refs/heads/main/public/diagrams/trigger.png" />

To learn more about triggers, visit the [triggers page](./handbook/triggers).

### Service components

Service components are the core logic of an AVS. They are written in [Rust, Go, or JavaScript](./handbook/components/component#languages) and compiled to [WASM](./how-it-works#wasm-and-wasi) as lightweight WASI components. WAVS provides a base layer of AVS infrastructure, allowing you to focus solely on the logic of your service.

Service components can contain logic for processing input data from triggers. If a trigger passes data, a service component can use that data as input. For example, a simple service component could contain logic for receiving a number as input and returning the square of that number as output.

<img alt="WAVS" src="https://raw.githubusercontent.com/Lay3rLabs/WAVS-docs/refs/heads/main/public/diagrams/service.png" />

To learn more about service components, visit the [How it works](/how-it-works#service-components) page. Check out the [WAVS tutorial](./tutorial/1-overview) to learn how to create a service component.


### Submission logic

Along with your component, you'll also need to define how the results of your service are submitted on-chain. With WAVS, you can use an [aggregator and submission contract](/how-it-works#submission) to define this logic.


### Run your service

AVS builders define their service in a [service manifest or service.json file](./handbook/service) with a workflow that includes a trigger, service component, and submission logic. Registered operators will then listen for the triggers specified by your service. Once triggered, operators will run your service off-chain, where data from a trigger is passed to a service component and run in a sandboxed WASI environment. Operators sign the result of the service computation and the verified result can be returned as an on-chain response.

<img alt="WAVS" src="https://raw.githubusercontent.com/Lay3rLabs/WAVS-docs/refs/heads/main/public/diagrams/wavs-flow.png" />

With WAVS, service updates are streamlined: updates to services can be made by AVS builders directly without needing to coordinate with operators. Operators only need to upgrade if there is a change to the WAVS node software itself.

## Multichain capability

WAVS is built to be multichain. A service can be triggered by events on one chain, run by operators off-chain, and write verified responses to another chain. This interoperability is what makes WAVS so flexible, creating a decentralized computational layer that can function across multiple chains.

## Composability

WAVS is composable by nature, allowing an AVS to dynamically run and manage multiple workflows that work together to build flexible and intelligent applications. Workflows include a trigger, service component, and submission logic. To [compose services and workflows](./handbook/workflows), the trigger of one workflow can be the submission logic of another workflow. The registry model allows component bytecode to be stored in one location and reused across multiple workflows.

## Security

The WAVS platform is secured via Ethereum restaking on EigenLayer, which provides a base security layer for AVSs built using WAVS. Restaking refers to the utilization of staked Ethereum to secure AVSs by imposing additional slashing terms on the staked Ethereum for operator misbehavior. In this way, the cryptoeconomic security of Ethereum is extended to WAVS AVSs.

## Full-stack decentralization

WAVS enables full-stack decentralization by unifying off-chain computation with on-chain verifiability. The chain layer connects to Ethereum and other chains, while the security layer extends cryptoeconomic security via EigenLayer restaking. At the AVS layer, lightweight WAVS powers WASM-based services to process off-chain computations triggered by on-chain events. Operators validate, sign, and commit the results back on-chain, ensuring verifiability and trust-minimized execution. This architecture makes WAVS a scalable, decentralized framework for full-stack applications.

<img alt="WAVS" src="https://raw.githubusercontent.com/Lay3rLabs/WAVS-docs/refs/heads/main/public/diagrams/security.png" />
````

## File: script/template/.env.example.aggregator
````
# Mnemonic for reference: %%MNEMONIC_REFERENCE%%
WAVS_AGGREGATOR_DATA=~/wavs/aggregator
WAVS_AGGREGATOR_CREDENTIAL=""
WAVS_AGGREGATOR_HD_INDEX=0
````

## File: script/template/.env.example.operator
````
# == PROJECT ==
WAVS_ENV_YOURKEYHERE="00000000000000000000000000000000"

# WAVS
WAVS_DATA=~/wavs/data
WAVS_LOG_LEVEL="info, wavs_aggregator=debug"
WAVS_SUBMISSION_MNEMONIC=""
#WAVS_COSMOS_SUBMISSION_MNEMONIC="cosmos mnemonic here"

# WAVS CLI
WAVS_CLI_DATA=~/wavs/cli
WAVS_CLI_LOG_LEVEL="info, wavs_cli=info, wavs_aggregator=debug"
WAVS_CLI_EVM_CREDENTIAL=""
#WAVS_CLI_COSMOS_CREDENTIAL="cosmos mnemonic here"
````

## File: script/.solhint.json
````json
{
  "rules": {
    "ordering": "off",
    "one-contract-per-file": "off",
    "no-console": "off",
    "style-guide-casing": "off"
  }
}
````

## File: script/avs-signing-key.sh
````bash
#!/bin/bash

export DEFAULT_ENV_FILE=${DEFAULT_ENV_FILE:-"infra/wavs-1/.env"}

SERVICE_INDEX=${SERVICE_INDEX:-0}

SERVICE_ID=`curl -s http://localhost:8000/app | jq -r ".services[${SERVICE_INDEX}].id"`
if [ -z "$SERVICE_ID" ] || [ "$SERVICE_ID" == "null" ]; then
  echo "Error: SERVICE_ID is null or not found for index ${SERVICE_INDEX}."
  return
fi

HD_INDEX=`curl -s http://localhost:8000/service-key/${SERVICE_ID} | jq -rc '.secp256k1.hd_index'`

source ${DEFAULT_ENV_FILE}
export OPERATOR_PRIVATE_KEY=`cast wallet private-key --mnemonic "$WAVS_SUBMISSION_MNEMONIC" --mnemonic-index 0`
export AVS_SIGNING_ADDRESS=`cast wallet address --mnemonic-path "$WAVS_SUBMISSION_MNEMONIC" --mnemonic-index ${HD_INDEX}`

echo "HD_INDEX=${HD_INDEX}"
echo "SERVICE_ID=${SERVICE_ID}"
echo "OPERATOR_PRIVATE_KEY=*HIDDEN*"
echo "AVS_SIGNING_ADDRESS=${AVS_SIGNING_ADDRESS}"
````

## File: script/build_components.sh
````bash
#!/bin/bash
#
# Called from the Makefile to build all (or some) components
#
# ./script/build_components.sh [WASI_BUILD_DIR]
#
# WASI_BUILD_DIR: the directory to build the component in
# e.g. ./script/build_components.sh components/golang-evm-price-oracle
#

# Extract arguments
WASI_BUILD_DIR="$1"

RECIPE="wasi-build"
MAKEFILE_DIRS=`find components/* -maxdepth 1 -name "Makefile" -o -name "makefile"`

for makefile_path in $MAKEFILE_DIRS; do
    if grep -q "^${RECIPE}:" "$makefile_path" 2>/dev/null; then
        if [ "$WASI_BUILD_DIR" != "" ] && [[ "$makefile_path" != *"$WASI_BUILD_DIR"* ]]; then
            continue
        fi;
        parent_dir=$(dirname "$makefile_path")
        make -s -C "$parent_dir" $RECIPE
    else
        echo "Recipe '$RECIPE' not found in $dir"
    fi;
done
````

## File: script/build-service.sh
````bash
#!/bin/bash

# set -x

: '''
# Run:

sh ./build_service.sh

# Overrides:
- FILE_LOCATION: The save location of the configuration file
- TRIGGER_ADDRESS: The address to trigger the service
- SUBMIT_ADDRESS: The address to submit the service
- TRIGGER_EVENT: The event to trigger the service (e.g. "NewTrigger(bytes)")
- FUEL_LIMIT: The fuel limit (wasm compute metering) for the service
- MAX_GAS: The maximum chain gas for the submission Tx
'''

# == Defaults ==

FUEL_LIMIT=${FUEL_LIMIT:-1000000000000}
MAX_GAS=${MAX_GAS:-5000000}
FILE_LOCATION=${FILE_LOCATION:-".docker/service.json"}
TRIGGER_EVENT=${TRIGGER_EVENT:-"NewTrigger(bytes)"}
TRIGGER_CHAIN=${TRIGGER_CHAIN:-"local"}
SUBMIT_CHAIN=${SUBMIT_CHAIN:-"local"}
AGGREGATOR_URL=${AGGREGATOR_URL:-""}
DEPLOY_ENV=${DEPLOY_ENV:-""}
REGISTRY=${REGISTRY:-"wa.dev"}

BASE_CMD="docker run --rm --network host -w /data -v $(pwd):/data ghcr.io/lay3rlabs/wavs:35c96a4 wavs-cli service --json true --home /data --file /data/${FILE_LOCATION}"

if [ -z "$WAVS_SERVICE_MANAGER_ADDRESS" ]; then
    export WAVS_SERVICE_MANAGER_ADDRESS=$(jq -r .addresses.WavsServiceManager ./.nodes/avs_deploy.json)
    if [ -z "$WAVS_SERVICE_MANAGER_ADDRESS" ]; then
        echo "WAVS_SERVICE_MANAGER_ADDRESS is not set. Please set it to the address of the service manager."
        return
    fi
fi


if [ -z "$TRIGGER_ADDRESS" ]; then
    TRIGGER_ADDRESS=`make get-trigger-from-deploy`
fi
if [ -z "$SUBMIT_ADDRESS" ]; then
    SUBMIT_ADDRESS=`make get-submit-from-deploy`
fi
if [ -z "$DEPLOY_ENV" ]; then
    DEPLOY_ENV=$(sh ./script/get-deploy-status.sh)
fi
# === Core ===

TRIGGER_EVENT_HASH=`cast keccak ${TRIGGER_EVENT}`

export SERVICE_ID=`eval "${BASE_CMD} init --name demo" | jq -r .service.id`
echo "Service ID: ${SERVICE_ID}"

WORKFLOW_ID=`eval "$BASE_CMD workflow add" | jq -r .workflow_id`
echo "Workflow ID: ${WORKFLOW_ID}"

eval "$BASE_CMD workflow trigger --id ${WORKFLOW_ID} set-evm --address ${TRIGGER_ADDRESS} --chain-name ${TRIGGER_CHAIN} --event-hash ${TRIGGER_EVENT_HASH}" > /dev/null

# If no aggregator is set, use the default
SUB_CMD="set-evm"
if [ -n "$AGGREGATOR_URL" ]; then
    SUB_CMD="set-aggregator --url ${AGGREGATOR_URL}"
fi
eval "$BASE_CMD workflow submit --id ${WORKFLOW_ID} ${SUB_CMD} --address ${SUBMIT_ADDRESS} --chain-name ${SUBMIT_CHAIN} --max-gas ${MAX_GAS}" > /dev/null

eval "$BASE_CMD workflow component --id ${WORKFLOW_ID} set-source-registry --domain ${REGISTRY} --package ${PKG_NAMESPACE}:${PKG_NAME} --version ${PKG_VERSION}"

eval "$BASE_CMD workflow component --id ${WORKFLOW_ID} permissions --http-hosts '*' --file-system true" > /dev/null
eval "$BASE_CMD workflow component --id ${WORKFLOW_ID} time-limit --seconds 30" > /dev/null
eval "$BASE_CMD workflow component --id ${WORKFLOW_ID} env --values WAVS_ENV_SOME_SECRET" > /dev/null
eval "$BASE_CMD workflow component --id ${WORKFLOW_ID} config --values 'key=value,key2=value2'" > /dev/null
eval "$BASE_CMD workflow component --id ${WORKFLOW_ID} fuel-limit --fuel ${FUEL_LIMIT}" > /dev/null

eval "$BASE_CMD manager set-evm --chain-name ${SUBMIT_CHAIN} --address `cast --to-checksum ${WAVS_SERVICE_MANAGER_ADDRESS}`" > /dev/null
eval "$BASE_CMD validate" > /dev/null

echo "Configuration file created ${FILE_LOCATION}. Watching events from '${TRIGGER_CHAIN}' & submitting to '${SUBMIT_CHAIN}'."
````

## File: script/Common.s.sol
````
// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import {Script} from "forge-std/Script.sol";

/// @dev Struct to store Eigen contracts
struct EigenContracts {
    address delegation_manager;
    address rewards_coordinator;
    address avs_directory;
}

/// @dev Common script for all deployment scripts
contract Common is Script {
    uint256 internal _privateKey =
        vm.envOr("FUNDED_KEY", uint256(0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80));
}
````

## File: script/create-aggregator.sh
````bash
#!/usr/bin/bash

# set -x

# have an optional argument $1, if set, use it as the agg index
# otherwise, use the default of 1
if [ -n "$1" ]; then
    AGGREGATOR_INDEX=$1
fi
if [ -z "$AGGREGATOR_INDEX" ]; then
    AGGREGATOR_INDEX=1
fi

if [ -z "$DEPLOY_ENV" ]; then
    DEPLOY_ENV=$(sh ./script/get-deploy-status.sh)
fi
if [ -z "$RPC_URL" ]; then
    RPC_URL=`sh ./script/get-rpc.sh`
fi

SP=""; if [[ "$(uname)" == *"Darwin"* ]]; then SP=" "; fi

cd $(git rev-parse --show-toplevel) || return

mkdir -p .docker

# == Generate a new aggregator ==
TEMP_FILENAME=".docker/tmp.json"
cast wallet new-mnemonic --json > ${TEMP_FILENAME}
export AGG_MNEMONIC=`jq -r .mnemonic ${TEMP_FILENAME}`
export AGG_PK=`jq -r .accounts[0].private_key ${TEMP_FILENAME}`
AGGREGATOR_ADDR=`cast wallet address $AGG_PK`

# == infra files ==
AGG_LOC=infra/aggregator-${AGGREGATOR_INDEX}
mkdir -p ${AGG_LOC}

ENV_FILENAME="${AGG_LOC}/.env"
cp ./script/template/.env.example.aggregator ${ENV_FILENAME}

sed -i${SP}'' -e "s/^WAVS_AGGREGATOR_CREDENTIAL=.*$/WAVS_AGGREGATOR_CREDENTIAL=\"$AGG_PK\"/" ${ENV_FILENAME}
sed -i${SP}'' -e "s/.%%MNEMONIC_REFERENCE%%$/ $AGG_MNEMONIC/" ${ENV_FILENAME}

cat > "${AGG_LOC}/start.sh" << EOF
#!/bin/bash
cd \$(dirname "\$0") || return

IMAGE=ghcr.io/lay3rlabs/wavs:35c96a4
INSTANCE=wavs-aggregator-${AGGREGATOR_INDEX}
IPFS_GATEWAY=\${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}

docker kill \${INSTANCE} > /dev/null 2>&1 || true
docker rm \${INSTANCE} > /dev/null 2>&1 || true

docker run -d --name \${INSTANCE} --network host --stop-signal SIGKILL --env-file .env --user 1000:1000 -v .:/wavs \
  \${IMAGE} wavs-aggregator --log-level debug --host 0.0.0.0 --port 8001 --ipfs-gateway \${IPFS_GATEWAY}

# give it a chance to start up
sleep 1
EOF

cp wavs.toml ${AGG_LOC}/wavs.toml

if [ "$DEPLOY_ENV" = "LOCAL" ]; then
    # Good DevEx, auto fund the deployer
    cast rpc anvil_setBalance "${AGGREGATOR_ADDR}" '15000000000000000000' --rpc-url ${RPC_URL} > /dev/null

    BAL=`cast balance --ether $AGGREGATOR_ADDR --rpc-url=${RPC_URL}`
    echo "Local aggregator \`${AGGREGATOR_ADDR}\` funded with ${BAL}ether"
else
    # New account on testnet, must be funded externally (i.e. metamask)
    echo "Fund aggregator ${AGGREGATOR_ADDR} with some ETH, or change this value in ${ENV_FILENAME}"
    sleep 5

    while true; do
        BALANCE=`cast balance --ether $AGGREGATOR_ADDR --rpc-url=${RPC_URL}`
        if [ "$BALANCE" != "0.000000000000000000" ]; then
            echo "Account balance is now $BALANCE"
            break
        fi
        echo "      [!] Waiting for balance to be funded by another account to this account..."
        sleep 5
    done
fi
````

## File: script/create-deployer.sh
````bash
#!/usr/bin/bash
# set -e
SP=""; if [[ "$(uname)" == *"Darwin"* ]]; then SP=" "; fi

# if DEPLOY_ENV is not set, grab it from the ./script/get-deploy-status.sh
if [ -z "$DEPLOY_ENV" ]; then
    DEPLOY_ENV=$(sh ./script/get-deploy-status.sh)
fi
if [ -z "$RPC_URL" ]; then
    RPC_URL=`sh ./script/get-rpc.sh`
fi

if [ ! -f .env ]; then
    echo ".env file not found, attempting to copy create"
    cp .env.example .env
    if [ $? -ne 0 ]; then
        echo "Failed to copy .env.example to .env"
        return
    fi
fi

mkdir -p .docker

# Create new deployer
cast wallet new-mnemonic --json > .docker/deployer.json
export DEPLOYER_PK=`jq -r .accounts[0].private_key .docker/deployer.json`
export DEPLOYER_ADDRESS=`cast wallet address $DEPLOYER_PK`
sed -i${SP}'' -e "s/^FUNDED_KEY=.*$/FUNDED_KEY=$DEPLOYER_PK/" .env


if [ "$DEPLOY_ENV" = "LOCAL" ]; then
    # Good DevEx, auto fund the deployer
    cast rpc anvil_setBalance "${DEPLOYER_ADDRESS}" '15000000000000000000' --rpc-url ${RPC_URL} > /dev/null

    BAL=`cast balance --ether $DEPLOYER_ADDRESS --rpc-url=${RPC_URL}`
    echo "Local deployer \`${DEPLOYER_ADDRESS}\` funded with ${BAL}ether"
else
    # New account on testnet, must be funded externally (i.e. metamask)
    echo "Fund deployer ${DEPLOYER_ADDRESS} with some ETH, or change this value in the .env"
    sleep 5

    while true; do
        BALANCE=`cast balance --ether $DEPLOYER_ADDRESS --rpc-url=${RPC_URL}`
        if [ "$BALANCE" != "0.000000000000000000" ]; then
            echo "Deployer balance is now $BALANCE"
            break
        fi
        echo "    [!] Waiting for balance to be funded by another account to this deployer..."
        sleep 5
    done
fi
````

## File: script/create-operator.sh
````bash
#!/bin/bash

SP=""; if [[ "$(uname)" == *"Darwin"* ]]; then SP=" "; fi

cd $(git rev-parse --show-toplevel) || return

mkdir -p .docker

# require a number input as argument 1, if not, require OPERATOR_INDEX env variable
export OPERATOR_INDEX=${OPERATOR_INDEX:-$1}
if [ -z "$OPERATOR_INDEX" ]; then
  echo "Please provide an operator index as the first argument or set OPERATOR_INDEX environment variable."
  return
fi

OPERATOR_LOC=infra/wavs-${OPERATOR_INDEX}


if [ -d "${OPERATOR_LOC}" ] && [ "$(ls -A ${OPERATOR_LOC})" ]; then
  read -p "Directory ${OPERATOR_LOC} already exists and is not empty. Do you want to remove it? (y/n): " -n 1 -r
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo -e "
Removing ${OPERATOR_LOC}"
    docker kill wavs-${OPERATOR_INDEX} > /dev/null 2>&1 || true

    echo "Removing dir ${OPERATOR_LOC} ((may prompt for password))"
    sudo rm -rf ${OPERATOR_LOC}
  else
    echo -e "
Exiting without changes."
    return
  fi
fi

mkdir -p ${OPERATOR_LOC}


ENV_FILENAME="${OPERATOR_LOC}/.env"
cp ./script/template/.env.example.operator ${ENV_FILENAME}


TEMP_FILENAME=".docker/tmp.json"

cast wallet new-mnemonic --json > ${TEMP_FILENAME}
export OPERATOR_MNEMONIC=`jq -r .mnemonic ${TEMP_FILENAME}`
export OPERATOR_PK=`jq -r .accounts[0].private_key ${TEMP_FILENAME}`

sed -i${SP}'' -e "s/^WAVS_SUBMISSION_MNEMONIC=.*$/WAVS_SUBMISSION_MNEMONIC=\"$OPERATOR_MNEMONIC\"/" ${ENV_FILENAME}
sed -i${SP}'' -e "s/^WAVS_CLI_EVM_CREDENTIAL=.*$/WAVS_CLI_EVM_CREDENTIAL=\"$OPERATOR_PK\"/" ${ENV_FILENAME}

rm ${TEMP_FILENAME}


# Create startup script
cat > "${OPERATOR_LOC}/start.sh" << EOF
#!/bin/bash
cd \$(dirname "\$0") || return

IMAGE=ghcr.io/lay3rlabs/wavs:35c96a4
WAVS_INSTANCE=wavs-${OPERATOR_INDEX}
IPFS_GATEWAY=\${IPFS_GATEWAY:-"https://gateway.pinata.cloud/ipfs/"}

docker kill \${WAVS_INSTANCE} > /dev/null 2>&1 || true
docker rm \${WAVS_INSTANCE} > /dev/null 2>&1 || true

docker run -d --rm --name \${WAVS_INSTANCE} --network host --env-file .env -v \$(pwd):/root/wavs \${IMAGE} wavs --home /root/wavs --ipfs-gateway \${IPFS_GATEWAY} --host 0.0.0.0 --log-level info
sleep 0.25

if [ ! "\$(docker ps -q -f name=\${WAVS_INSTANCE})" ]; then
  echo "Container \${WAVS_INSTANCE} is not running. Reason:"
  docker run --rm --name \${WAVS_INSTANCE} --network host --env-file .env -v \$(pwd):/root/wavs \${IMAGE} wavs --home /root/wavs --ipfs-gateway \${IPFS_GATEWAY} --host 0.0.0.0 --log-level info
fi

# give wavs a chance to start up & health check
sleep 3
EOF

cp wavs.toml ${OPERATOR_LOC}/wavs.toml

echo "Operator ${OPERATOR_INDEX} created at ${OPERATOR_LOC}"
````

## File: script/deploy-contracts.sh
````bash
#!/bin/bash

if [ -z "$WAVS_SERVICE_MANAGER_ADDRESS" ]; then
    if [ -f .nodes/avs_deploy.json ]; then
        echo "Using WAVS_SERVICE_MANAGER_ADDRESS from .nodes/avs_deploy.json"
        export WAVS_SERVICE_MANAGER_ADDRESS=$(jq -r '.addresses.WavsServiceManager' .nodes/avs_deploy.json)
    else
        echo "WAVS_SERVICE_MANAGER_ADDRESS is not set."
        return
    fi
fi

forge build
if [ $? -ne 0 ]; then
    echo "Forge build failed. Running 'npm install' and deleting the 'out/' and 'cache/' directory."
    npm install
    rm -rf out/ cache/
    forge build
fi

export DEPLOYER_PK=$(cat .nodes/deployer)

forge create SimpleSubmit --json --broadcast -r ${RPC_URL} --private-key "${DEPLOYER_PK}" --constructor-args "${WAVS_SERVICE_MANAGER_ADDRESS}" > .docker/submit.json
export SERVICE_SUBMISSION_ADDR=`jq -r '.deployedTo' .docker/submit.json`

forge create SimpleTrigger --json --broadcast -r ${RPC_URL} --private-key "${DEPLOYER_PK}" > .docker/trigger.json
export SERVICE_TRIGGER_ADDR=`jq -r '.deployedTo' .docker/trigger.json`

echo "RPC_URL=${RPC_URL}"
echo "WAVS_SERVICE_MANAGER_ADDRESS=${WAVS_SERVICE_MANAGER_ADDRESS}"
echo "SERVICE_SUBMISSION_ADDR=${SERVICE_SUBMISSION_ADDR}"
echo "SERVICE_TRIGGER_ADDR=${SERVICE_TRIGGER_ADDR}"
````

## File: script/deploy-script.sh
````bash
#!/bin/bash
# set -e

if [ ! -d compiled/ ] || [ -z "$(find compiled/ -name '*.wasm')" ]; then
    echo "No WASM files found in compiled/. Building components."
    make wasi-build
fi

if git status --porcelain | grep -q "^.* components/"; then
    echo "Found pending changes in components/*, building"
    WASI_BUILD_DIR=components/evm-price-oracle make wasi-build
fi

### === Deploy Eigenlayer ===
# if RPC_URL is not set, use default by calling command
if [ -z "$RPC_URL" ]; then
    export RPC_URL=$(bash ./script/get-rpc-url.sh)
fi
if [ -z "$AGGREGATOR_URL" ]; then
    export AGGREGATOR_URL=http://127.0.0.1:8001
fi

# local: create deployer & auto fund. testnet: create & iterate check balance
bash ./script/create-deployer.sh
export DEPLOYER_PK=$(cat .nodes/deployer)
sleep 1

## Deploy Eigenlayer from Deployer
COMMAND=deploy make wavs-middleware
sleep 1

### === Deploy Service === ###

# Forge deploy SimpleSubmit & SimpleTrigger
source script/deploy-contracts.sh
sleep 1

### === Deploy Service ===
export COMPONENT_FILENAME=evm_price_oracle.wasm
if [ "$(sh ./script/get-deploy-status.sh)" = "TESTNET" ]; then
    read -p "Enter the component filename (default: ${COMPONENT_FILENAME}): " input_filename
    if [ -n "$input_filename" ]; then
        export COMPONENT_FILENAME="$input_filename"
    fi
fi

export PKG_NAME="evmrustoracle"
if [ "$(sh ./script/get-deploy-status.sh)" = "TESTNET" ]; then
    read -p "Enter the package name (default: ${PKG_NAME}): " input_pkg_name
    if [ -n "$input_pkg_name" ]; then
        export PKG_NAME="$input_pkg_name"
    fi
fi

export PKG_VERSION="0.1.0"
if [ "$(sh ./script/get-deploy-status.sh)" = "TESTNET" ]; then
    read -p "Enter the package version (default: ${PKG_VERSION}): " input_pkg_version
    if [ -n "$input_pkg_version" ]; then
        export PKG_VERSION="$input_pkg_version"
    fi
fi

# ** Testnet Setup: https://wa.dev/account/credentials/new -> warg login
source script/upload-to-wasi-registry.sh || true
sleep 1

# Testnet: set values (default: local if not set)
if [ "$(sh ./script/get-deploy-status.sh)" = "TESTNET" ]; then
    export TRIGGER_CHAIN=holesky
    export SUBMIT_CHAIN=holesky
fi

# Package not found with wa.dev? -- make sure it is public
REGISTRY=${REGISTRY} source ./script/build-service.sh
sleep 1

# === Upload service.json to IPFS ===
# local: 127.0.0.1:5001 | testnet: https://app.pinata.cloud/. set PINATA_API_KEY to JWT token in .env
echo "Uploading to IPFS..."
export ipfs_cid=`SERVICE_FILE=.docker/service.json make upload-to-ipfs`
# LOCAL: http://127.0.0.1:8080 | TESTNET: https://gateway.pinata.cloud/
export IPFS_GATEWAY="$(bash script/get-ipfs-gateway.sh)"
export IPFS_URI="ipfs://${ipfs_cid}"
IPFS_URL="${IPFS_GATEWAY}${ipfs_cid}"
echo "IPFS_URL=${IPFS_URL}"

echo "Querying to verify IPFS upload... (120 second timeout)"
curl ${IPFS_URL} --connect-timeout 120 --max-time 120 --show-error --fail

if [ "$DEPLOYER_PK" ]; then
    echo ""
    echo "Setting service URI on WAVS Service Manager..."
    cast send ${WAVS_SERVICE_MANAGER_ADDRESS} 'setServiceURI(string)' "${IPFS_URI}" -r ${RPC_URL} --private-key ${DEPLOYER_PK}
fi

echo "IPFS_GATEWAY=${IPFS_GATEWAY}"
echo "IPFS_URI=${IPFS_URI}"

sleep 1

### === Create Aggregator ===

bash ./script/create-aggregator.sh 1
IPFS_GATEWAY=${IPFS_GATEWAY} bash ./infra/aggregator-1/start.sh
sleep 1
wget -q --header="Content-Type: application/json" --post-data="{\"uri\": \"${IPFS_URI}\"}" ${AGGREGATOR_URL}/register-service -O -

### === Start WAVS ===
bash ./script/create-operator.sh 1
IPFS_GATEWAY=${IPFS_GATEWAY} bash ./infra/wavs-1/start.sh
sleep 5

# Deploy the service JSON to WAVS so it now watches and submits.
# 'opt in' for WAVS to watch (this is before we register to Eigenlayer)
WAVS_ENDPOINT=http://127.0.0.1:8000 SERVICE_URL=${IPFS_URI} IPFS_GATEWAY=${IPFS_GATEWAY} make deploy-service

### === Register service specific operator ===

# OPERATOR_PRIVATE_KEY, AVS_SIGNING_ADDRESS
SERVICE_INDEX=0 source ./script/avs-signing-key.sh

# TODO: move this check into the middleware (?)
if [ "$(sh ./script/get-deploy-status.sh)" = "TESTNET" ]; then
    export OPERATOR_ADDRESS=$(cast wallet address --private-key ${OPERATOR_PRIVATE_KEY})
    while true; do
        BALANCE=$(cast balance ${OPERATOR_ADDRESS} --rpc-url ${RPC_URL} --ether)
        if [ "$BALANCE" != "0" ]; then
            echo "OPERATOR_ADDRESS has balance: $BALANCE"
            break
        else
            echo "Waiting for ${OPERATOR_ADDRESS} (operator) to have a balance..."
            sleep 5
        fi
    done
fi

export WAVS_SERVICE_MANAGER_ADDRESS=$(jq -r .addresses.WavsServiceManager ./.nodes/avs_deploy.json)
COMMAND="register ${OPERATOR_PRIVATE_KEY} ${AVS_SIGNING_ADDRESS} 0.001ether" make wavs-middleware

# Verify registration
COMMAND="list_operators" PAST_BLOCKS=500 make wavs-middleware

echo "✅ Deployment complete!"
````

## File: script/get-deploy-status.sh
````bash
#!/bin/bash

cd `git rev-parse --show-toplevel` || exit

if [ ! -f .env ]; then
    cp .env.example .env
    if [ $? -ne 0 ]; then
        echo "Failed to copy .env.example to .env"
        return
    fi
fi

# Extract DEPLOY_ENV from the file
DEPLOY_ENV=$(grep "^DEPLOY_ENV=" .env | cut -d '=' -f2)

DEPLOY_ENV=$(echo "$DEPLOY_ENV" | tr '[:lower:]' '[:upper:]')

echo "$DEPLOY_ENV"
````

## File: script/get-ipfs-gateway.sh
````bash
#!/bin/bash

cd `git rev-parse --show-toplevel` || exit

DEPLOY_ENV=$(sh ./script/get-deploy-status.sh)

if [ "$DEPLOY_ENV" = "LOCAL" ]; then
    IPFS_GATEWAY=http://127.0.0.1:8080/ipfs/
elif [ "$DEPLOY_ENV" = "TESTNET" ]; then
    IPFS_GATEWAY=https://gateway.pinata.cloud/ipfs/
else
    echo "Unknown DEPLOY_ENV: $DEPLOY_ENV"
    return
fi

echo "${IPFS_GATEWAY}"
````

## File: script/get-registry.sh
````bash
#!/bin/bash

cd `git rev-parse --show-toplevel` || exit

DEPLOY_ENV=$(sh ./script/get-deploy-status.sh)

if [ "$DEPLOY_ENV" = "LOCAL" ]; then
    REGISTRY=localhost:8090
elif [ "$DEPLOY_ENV" = "TESTNET" ]; then
    REGISTRY=wa.dev
else
    echo "Unknown DEPLOY_ENV: $DEPLOY_ENV"
    return
fi

echo "${REGISTRY}"
````

## File: script/get-rpc.sh
````bash
#!/bin/bash

cd `git rev-parse --show-toplevel` || exit

DEPLOY_ENV=$(sh ./script/get-deploy-status.sh)

if [ "$DEPLOY_ENV" = "LOCAL" ]; then
    RPC_URL=$(grep "^LOCAL_ETHEREUM_RPC_URL=" .env)
elif [ "$DEPLOY_ENV" = "TESTNET" ]; then
    RPC_URL=$(grep "^TESTNET_RPC_URL=" .env)
else
    echo "Unknown DEPLOY_ENV: $DEPLOY_ENV"
    return
fi

echo "${RPC_URL}" | cut -d '=' -f2
````

## File: script/get-wasi-namespace.sh
````bash
#!/bin/bash

if [ -z "$REGISTRY" ]; then
    echo "REGISTRY is not set. Please set the REGISTRY environment variable." && return
fi

# ===

cd `git rev-parse --show-toplevel` || exit

DEPLOY_ENV=$(sh ./script/get-deploy-status.sh)

if [ "$DEPLOY_ENV" = "LOCAL" ]; then
    export PKG_NAMESPACE="example"
    echo ${PKG_NAMESPACE}
    exit 0
else
    read -p "Enter the PKG_NAMESPACE for ${REGISTRY}: " namespace

    export PKG_NAMESPACE="${namespace}"
    echo "${PKG_NAMESPACE}"
fi
````

## File: script/ShowResult.s.sol
````
// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import {SimpleTrigger} from "contracts/WavsTrigger.sol";
import {SimpleSubmit} from "contracts/WavsSubmit.sol";
import {ITypes} from "interfaces/ITypes.sol";
import {Common} from "script/Common.s.sol";
import {console} from "forge-std/console.sol";

/// @dev Script to show the result of a trigger
contract ShowResult is Common {
    function trigger(string calldata serviceTriggerAddr) public view {
        SimpleTrigger triggerInstance = SimpleTrigger(vm.parseAddress(serviceTriggerAddr));
        ITypes.TriggerId triggerId = triggerInstance.nextTriggerId();

        console.log("TriggerID:", ITypes.TriggerId.unwrap(triggerId));
    }

    function data(string calldata serviceHandlerAddr, uint64 triggerId) public view {
        SimpleSubmit submit = SimpleSubmit(vm.parseAddress(serviceHandlerAddr));

        ITypes.TriggerId triggerIdTyped = ITypes.TriggerId.wrap(triggerId);

        bool isValid = submit.isValidTriggerId(triggerIdTyped);
        if(!isValid) {
            console.log("Trigger ID:", triggerId, " is not valid");
        }

        bytes memory triggerData = submit.getData(triggerIdTyped);
        console.log("TriggerID:", triggerId);
        console.log("Data:", string(triggerData));
    }


}
````

## File: script/start_all.sh
````bash
#!/bin/bash

set -e

if [ -f .env ] && grep -q '^TESTNET_RPC_URL=' .env; then
  TESTNET_RPC_URL=$(grep -E '^TESTNET_RPC_URL=' .env | cut -d '=' -f2- | tr -d '"')
else
  rpc_url="https://holesky.drpc.org"
  echo "No TESTNET_RPC_URL found in .env, using default ${rpc_url}"
  TESTNET_RPC_URL=${rpc_url}
fi

PORT=8545
MIDDLEWARE_IMAGE=ghcr.io/lay3rlabs/wavs-middleware:0.4.0
FORK_RPC_URL=${FORK_RPC_URL:-"${TESTNET_RPC_URL}"}
DEPLOY_ENV=$(sh ./script/get-deploy-status.sh)

## == Start watcher ==
rm $LOG_FILE 2> /dev/null || true


## == Base Anvil Testnet Fork ==
if [ "$DEPLOY_ENV" = "TESTNET" ]; then
  echo "Running in testnet mode, nothing to do"
  exit 0
fi

if [ "$DEPLOY_ENV" = "LOCAL" ]; then
  anvil --fork-url ${FORK_RPC_URL} --port ${PORT} &
  anvil_pid=$!
  trap "kill -9 $anvil_pid && echo -e '
Killed anvil'" EXIT
  while ! cast block-number --rpc-url http://localhost:${PORT} > /dev/null 2>&1
  do
    sleep 0.25
  done

  FILES="-f docker-compose.yml -f telemetry/docker-compose.yml"
  docker compose ${FILES} pull
  docker compose ${FILES} up --force-recreate -d
  trap "docker compose ${FILES} down --remove-orphans && docker kill wavs-1 wavs-aggregator-1 > /dev/null 2>&1 && echo -e '
Killed IPFS + Local WARG, and wavs instances'" EXIT

  echo "Started..."
  wait
fi
````

## File: script/Trigger.s.sol
````
// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import {SimpleTrigger} from "contracts/WavsTrigger.sol";
import {ITypes} from "interfaces/ITypes.sol";
import {Common} from "script/Common.s.sol";
import {console} from "forge-std/console.sol";

/// @dev Script to add a new trigger
contract Trigger is Common {
    function run(string calldata serviceTriggerAddr, string calldata coinMarketCapID) public {
        vm.startBroadcast(_privateKey);
        SimpleTrigger trigger = SimpleTrigger(vm.parseAddress(serviceTriggerAddr));

        trigger.addTrigger(coinMarketCapID);
        ITypes.TriggerId triggerId = trigger.nextTriggerId();
        console.log("TriggerId", ITypes.TriggerId.unwrap(triggerId));
        vm.stopBroadcast();
    }
}
````

## File: script/upload-to-wasi-registry.sh
````bash
#!/bin/bash

export REGISTRY=`bash ./script/get-registry.sh`
if [ -z "$REGISTRY" ]; then
    echo "REGISTRY is not set. Please set the REGISTRY environment variable." && return
fi
export PKG_NAMESPACE=`bash ./script/get-wasi-namespace.sh`
if [ -z "$PKG_NAMESPACE" ]; then
    echo "PKG_NAMESPACE is not set. Please set the PKG_NAMESPACE environment variable." && return
fi


if [ -z "$PKG_NAME" ]; then
    echo "PKG_NAME is not set. Please set the PKG_NAME environment variable." && return
fi
if [ -z "$PKG_VERSION" ]; then
    echo "PKG_VERSION is not set. Please set the PKG_VERSION environment variable." && return
fi
if [ -z "$COMPONENT_FILENAME" ]; then
    echo "COMPONENT_FILENAME is not set. Please set the COMPONENT_FILENAME environment variable." && return
fi

# ===

cd `git rev-parse --show-toplevel` || exit

PROTOCOL="https"
if [[ "$REGISTRY" == *"localhost"* ]] || [[ "$REGISTRY" == *"127.0.0.1"* ]]; then
    PROTOCOL="http"
fi
echo "Publishing to registry (${PROTOCOL}://${REGISTRY})..."


output=$(warg publish release --registry ${PROTOCOL}://${REGISTRY} --name ${PKG_NAMESPACE}:${PKG_NAME} --version ${PKG_VERSION} ./compiled/${COMPONENT_FILENAME} 2>&1)
exit_code=$?
warg reset --registry ${PROTOCOL}://${REGISTRY}

# Check for specific error conditions in the output
if [[ $exit_code -ne 0 ]]; then
    if [[ "$output" =~ "failed to prove inclusion" ]]; then
        echo "Package uploaded to local registry successfully..."
    elif [[ "$output" =~ "error sending request for url" ]]; then
        echo "NOTE: Check to make sure you are running the registry locally"
        echo "${output}"
    else
        echo "Unknown error occurred ${output}"
    fi
fi
````

## File: src/common/CmdRunner.sol
````
// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import "forge-std/Script.sol";

contract CmdRunner is Script{
    // `ffi = true` must be set in foundry.toml
    //
    // Run a command and return the output by creating a temporary script with
    // the entire command and running it via bash. This gets around the limits
    // of FFI, such as not being able to pipe between two commands.
    // string memory entry = runCmd(string.concat("curl -s ", url, " | jq -c .tree[0]"));
    function runCmd(string memory cmd) external returns (string memory) {
        string memory script = string.concat(vm.projectRoot(), "/.ffirun.sh");
        // Save the cmd to a file
        vm.writeFile(script, cmd);
        // Run the cmd
        string[] memory exec = new string[](2);
        exec[0] = "bash";
        exec[1] = script;
        string memory result = string(vm.ffi(exec));
        // Delete the file
        vm.removeFile(script);
        // Return the result
        return result;
    }
}
````

## File: src/contracts/WavsSubmit.sol
````
// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import {IWavsServiceManager} from "@wavs/interfaces/IWavsServiceManager.sol";
import {IWavsServiceHandler} from "@wavs/interfaces/IWavsServiceHandler.sol";
import {ITypes} from "interfaces/ITypes.sol";

contract SimpleSubmit is ITypes, IWavsServiceHandler {
    /// @notice Mapping of valid triggers
    mapping(TriggerId _triggerId => bool _isValid) internal _validTriggers;
    /// @notice Mapping of trigger data
    mapping(TriggerId _triggerId => bytes _data) internal _datas;
    /// @notice Mapping of trigger signatures
    mapping(TriggerId _triggerId => SignatureData _signature)
        internal _signatures;

    /// @notice Service manager instance
    IWavsServiceManager private _serviceManager;

    /**
     * @notice Initialize the contract
     * @param serviceManager The service manager instance
     */
    constructor(IWavsServiceManager serviceManager) {
        _serviceManager = serviceManager;
    }

    /// @inheritdoc IWavsServiceHandler
    function handleSignedEnvelope(
        Envelope calldata envelope,
        SignatureData calldata signatureData
    ) external {
        _serviceManager.validate(envelope, signatureData);

        DataWithId memory dataWithId = abi.decode(
            envelope.payload,
            (DataWithId)
        );

        _signatures[dataWithId.triggerId] = signatureData;
        _datas[dataWithId.triggerId] = dataWithId.data;
        _validTriggers[dataWithId.triggerId] = true;
    }

    function isValidTriggerId(
        TriggerId _triggerId
    ) external view returns (bool _isValid) {
        _isValid = _validTriggers[_triggerId];
    }

    function getSignature(
        TriggerId _triggerId
    ) external view returns (SignatureData memory _signature) {
        _signature = _signatures[_triggerId];
    }

    function getData(
        TriggerId _triggerId
    ) external view returns (bytes memory _data) {
        _data = _datas[_triggerId];
    }

    function getServiceManager() external view returns (address) {
        return address(_serviceManager);
    }
}
````

## File: src/contracts/WavsTrigger.sol
````
// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import {ISimpleTrigger} from "interfaces/IWavsTrigger.sol";

contract SimpleTrigger is ISimpleTrigger {
    /// @inheritdoc ISimpleTrigger
    TriggerId public nextTriggerId;

    /// @inheritdoc ISimpleTrigger
    mapping(TriggerId _triggerId => Trigger _trigger) public triggersById;
    /// @notice See ISimpleTrigger.triggerIdsByCreator
    mapping(address _creator => TriggerId[] _triggerIds)
        internal _triggerIdsByCreator;

    /// @inheritdoc ISimpleTrigger
    function addTrigger(string memory _data) external {
        // Get the next trigger id
        nextTriggerId = TriggerId.wrap(TriggerId.unwrap(nextTriggerId) + 1);
        TriggerId _triggerId = nextTriggerId;

        // Create the trigger
        Trigger memory _trigger = Trigger({
            creator: msg.sender,
            data: bytes(_data)
        });

        // Update storages
        triggersById[_triggerId] = _trigger;
        _triggerIdsByCreator[msg.sender].push(_triggerId);

        TriggerInfo memory _triggerInfo = TriggerInfo({
            triggerId: _triggerId,
            creator: _trigger.creator,
            data: _trigger.data
        });

        emit NewTrigger(abi.encode(_triggerInfo));
    }

    /// @inheritdoc ISimpleTrigger
    function getTrigger(
        TriggerId triggerId
    ) external view override returns (TriggerInfo memory _triggerInfo) {
        Trigger storage _trigger = triggersById[triggerId];
        _triggerInfo = TriggerInfo({
            triggerId: triggerId,
            creator: _trigger.creator,
            data: _trigger.data
        });
    }

    /// @inheritdoc ISimpleTrigger
    function triggerIdsByCreator(
        address _creator
    ) external view returns (TriggerId[] memory _triggerIds) {
        _triggerIds = _triggerIdsByCreator[_creator];
    }
}
````

## File: src/interfaces/.solhint.json
````json
{
  "rules": {
    "ordering": "warn",
    "style-guide-casing": [
      "warn",
      {
        "ignoreExternalFunctions": true
      }
    ]
  }
}
````

## File: src/interfaces/ITypes.sol
````
// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

interface ITypes {
    /**
     * @notice Struct to store trigger information
     * @param triggerId Unique identifier for the trigger
     * @param data Data associated with the triggerId
     */
    struct DataWithId {
        TriggerId triggerId;
        bytes data;
    }

    /**
     * @notice Struct to store trigger information
     * @param triggerId Unique identifier for the trigger
     * @param creator Address of the creator of the trigger
     * @param data Data associated with the trigger
     */
    struct TriggerInfo {
        TriggerId triggerId;
        address creator;
        bytes data;
    }

    /**
     * @notice Event emitted when a new trigger is created
     * @param _triggerInfo Encoded TriggerInfo struct
     */
    event NewTrigger(bytes _triggerInfo);

    /// @notice TriggerId is a unique identifier for a trigger
    type TriggerId is uint64;
}
````

## File: src/interfaces/IWavsTrigger.sol
````
// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import {ITypes} from "interfaces/ITypes.sol";

interface ISimpleTrigger is ITypes {
    /**
     * @notice Struct to store trigger information
     * @param creator Address of the creator of the trigger
     * @param data Data associated with the trigger
     */
    struct Trigger {
        address creator;
        bytes data;
    }

    /*///////////////////////////////////////////////////////////////
                            LOGIC
    //////////////////////////////////////////////////////////////*/
    /**
     * @notice Add a new trigger
     * @param _data The request data (bytes)
     */
    function addTrigger(string memory _data) external;

    /**
     * @notice Get a single trigger by triggerId
     * @param _triggerId The identifier of the trigger
     * @return _triggerInfo The trigger info
     */
    function getTrigger(TriggerId _triggerId) external view returns (TriggerInfo memory _triggerInfo);

    /*///////////////////////////////////////////////////////////////
                            VARIABLES
    //////////////////////////////////////////////////////////////*/
    /**
     * @notice Get the next triggerId
     * @return _triggerId The next triggerId
     */
    function nextTriggerId() external view returns (TriggerId _triggerId);

    /**
     * @notice Get a single trigger by triggerId
     * @param _triggerId The identifier of the trigger
     * @return _creator The creator of the trigger
     * @return _data The data of the trigger
     */
    function triggersById(TriggerId _triggerId) external view returns (address _creator, bytes memory _data);

    /**
     * @notice Get all triggerIds by creator
     * @param _creator The address of the creator
     * @return _triggerIds The triggerIds
     */
    function triggerIdsByCreator(address _creator) external view returns (TriggerId[] memory _triggerIds);
}
````

## File: telemetry/docker-compose.yml
````yaml
services:
  # Default all-memory Jaeger
  jaeger:
    image: jaegertracing/jaeger:2.5.0
    container_name: wavs-jaeger
    network_mode: "host"
    stop_signal: SIGKILL
    environment:
      - COLLECTOR_OTLP_ENABLED=true
    ports:
      - "4317:4317" # OTLP gRPC
      - "16686:16686" # Jaeger UI

  # Prometheus is used to display metrics
  prometheus:
    image: prom/prometheus:v3.3.0
    container_name: wavs-prometheus
    network_mode: "host"
    stop_signal: SIGKILL
    ports:
      - "9090:9090" # Prometheus UI and OTLP receiver
    volumes:
      - ./telemetry/prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - "--config.file=/etc/prometheus/prometheus.yml"
      - "--web.enable-otlp-receiver"
````

## File: telemetry/telemetry.md
````markdown
# Telemetry usage

Our Docker Compose configuration now includes:
- **Jaeger all-in-one**: For exporting traces, accessible at [http://localhost:16686](http://localhost:16686).
- **Prometheus**: For collecting and querying metrics, accessible at [http://localhost:9090](http://localhost:9090).

When the log level is set to `debug`, you will notice traces from both `wavs` and `wavs-aggregator` being exported to Jaeger.

For Prometheus:
- Use `{__name__=~".+"}` to query all available metrics.
- The interface supports auto-completion, so typing the name of the specific metric you're looking for will also work.
````

## File: test/unit/WavsTrigger.t.sol
````
// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import {Test} from "forge-std/Test.sol";
import {SimpleTrigger} from "contracts/WavsTrigger.sol";
import {ITypes} from "interfaces/ITypes.sol";

contract TriggerTest is Test {
    SimpleTrigger public simpleTrigger;

    function setUp() public {
        simpleTrigger = new SimpleTrigger();
    }

    function testTrigger() public {
        simpleTrigger.addTrigger("data1");

        ITypes.TriggerId triggerId = ITypes.TriggerId.wrap(1);
        ITypes.TriggerInfo memory trigger = simpleTrigger.getTrigger(triggerId);

        assertEq(trigger.creator, address(this));
        assertEq(trigger.data, "data1");
        assertEq(ITypes.TriggerId.unwrap(trigger.triggerId), ITypes.TriggerId.unwrap(triggerId));
    }
}
````

## File: test/.solhint.json
````json
{
  "rules": {
    "style-guide-casing": [
      "warn",
      {
        "ignorePublicFunctions":true,
        "ignoreExternalFunctions":true,
        "ignoreContracts":true
      }
    ],
    "no-global-import": "off",
    "max-states-count": "off",
    "ordering": "off",
    "one-contract-per-file": "off"
  }
}
````

## File: test_utils/README.md
````markdown
# WAVS Component Test Utilities

This library provides essential validation tools for WAVS components. All components **MUST** pass these tests before running the `make wasi-build` command.

## Overview

The test_utils component is a collection of utilities and validation scripts to ensure WAVS components meet the required standards and follow best practices. It's designed to catch common errors before they cause build failures or runtime issues.

## What It Does

- Validates component structure and implementation
- Checks for common anti-patterns and implementation mistakes
- Provides a standardized way to verify components
- Ensures consistent error handling, data management, and API usage

## Key Features

- Automated code analysis
- Comprehensive validation of ABI encoding/decoding
- Data ownership and cloning validation
- Error handling pattern verification
- Network request and API security validation

## Using the Validation Script

The main validation script can be used to verify any component:

```bash
# Validate a component using the Makefile command
make validate-component COMPONENT=your-component-name

# Or run the script directly
cd test_utils
./validate_component.sh your-component-name
```


## Test Modules

The test utilities are organized into focused modules:

| Module | Description |
|--------|-------------|
| `abi_encoding` | Proper handling of ABI-encoded data, avoiding common String::from_utf8 errors |
| `code_quality` | Code quality checks, including detecting unused imports and other best practices |
| `data_handling` | Correct data ownership, cloning, and avoiding moved value errors |
| `error_handling` | Proper Option/Result handling, avoiding map_err on Option errors |
| `network_requests` | HTTP request setup, error handling, and API key management |
| `solidity_types` | Working with Solidity types, numeric conversions, and struct handling |
| `input_validation` | Input data validation, safe decoding, and defensive programming |

## Common Errors Prevented

These tests help you avoid the following common errors:

1. Using `String::from_utf8` directly on ABI-encoded data
2. Missing Clone derivation on API response structs
3. Using `map_err()` on Option types instead of `ok_or_else()`
4. Improper Rust-Solidity type conversions
5. Ownership issues with collection elements
6. Using `&data.clone()` pattern creating temporary values
7. Missing trait imports causing "no method" errors
8. Ambiguous method calls requiring fully qualified syntax
9. Unused imports cluttering the code
10. Direct version specifications instead of workspace dependencies
````

## File: test_utils/validate_component.sh
````bash
#!/bin/bash
# Component validation script - IMPROVED VERSION
# Runs comprehensive test utilities to validate a component before building
# Catches all common errors that would prevent successful builds or execution

# Don't exit on error, we want to collect all errors
set +e

# Create an array to hold all errors
errors=()
warnings=()

# Function to add an error
add_error() {
    errors+=("$1")
    echo "❌ Error: $1"
}

# Function to add a warning
add_warning() {
    warnings+=("$1")
    echo "⚠️ Warning: $1"
}

if [ -z "$1" ]; then
  echo "Usage: $0 <component-directory-name>"
  echo "Example: $0 eth-price-oracle"
  exit 1
fi

COMPONENT_NAME=$1
COMPONENT_DIR="../components/$COMPONENT_NAME"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Check if component directory exists
if [ ! -d "$COMPONENT_DIR" ]; then
  echo "❌ Error: Component directory $COMPONENT_DIR not found"
  exit 1
fi

echo "🔍 Validating component: $COMPONENT_NAME"

# Print a section header for better organization
print_section() {
  echo
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo "🔍 $1"
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

#=====================================================================================
# ABI ENCODING CHECKS
#=====================================================================================
print_section "ABI ENCODING CHECKS"

# 1. Check for String::from_utf8 usage on ABI data in non-generated files
echo "📝 Checking for common String::from_utf8 misuse..."
grep_result=$(grep -r "String::from_utf8" "$COMPONENT_DIR/src" --include="*.rs" | grep -v "bindings.rs" | grep -v "test" | grep -v "# CORRECT" || true)
if [ ! -z "$grep_result" ]; then
  if grep -r "String::from_utf8.*data" "$COMPONENT_DIR"/src/*.rs | grep -v "bindings.rs" > /dev/null; then
    error_detail=$(grep -r "String::from_utf8.*data" "$COMPONENT_DIR"/src/*.rs | grep -v "bindings.rs")
    add_error "Found String::from_utf8 used directly on ABI-encoded data.
      This will ALWAYS fail with 'invalid utf-8 sequence' because ABI-encoded data is binary.
      Use proper ABI decoding methods instead: 
      1. For function calls with string params: functionCall::abi_decode()
      2. For string params: String::abi_decode()
      $error_detail"
  else
    add_warning "Found String::from_utf8 usage. Ensure it's not being used on ABI-encoded data.
      This can cause runtime errors if used with encoded data. You can ignore this warning if you are using correctly.
      $grep_result"
  fi
fi

# 1b. Check for proper ABI decoding methods
echo "📝 Checking for proper ABI decoding methods..."
if grep -r "TriggerData::Raw" "$COMPONENT_DIR"/src/*.rs > /dev/null || 
   grep -r "cast abi-encode" "$COMPONENT_DIR" > /dev/null; then
  
  # Component deals with ABI-encoded input data
  if ! grep -r "abi_decode" "$COMPONENT_DIR"/src/*.rs > /dev/null && 
     ! grep -r "::abi_decode" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
    add_error "Component appears to handle ABI-encoded input but doesn't use abi_decode methods.
      This will cause runtime errors when processing ABI-encoded data.
      For ABI-encoded input, use proper decoding methods:
      1. <String as SolValue>::abi_decode(&hex_data)
      2. <Type as SolValue>::abi_decode(&data)
      3. functionCall::abi_decode(&data)"
  fi
  
  # Check for Solidity function definitions when receiving function calls
  if grep -r "cast abi-encode \"f(string)" "$COMPONENT_DIR" > /dev/null && 
     ! grep -r "function.*external" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
    add_error "Component receives ABI-encoded function calls but doesn't define Solidity functions.
      This will cause runtime errors when trying to decode function calls.
      Define appropriate Solidity functions to decode inputs, for example:
      sol! {
          function checkBalance(string address) external;
      }"
  fi
fi

#=====================================================================================
# DATA HANDLING CHECKS
#=====================================================================================
print_section "DATA HANDLING CHECKS"

# 2a. Check for proper Clone derivation on API structs used with network requests
echo "📝 Checking for Clone derivation on structs..."
# Look for structs used in HTTP responses
HTTP_USAGE=$(if grep -r "fetch_json\|http_request_get" "$COMPONENT_DIR"/src/*.rs > /dev/null 2>&1; then echo "1"; else echo "0"; fi)

# Find structs with Deserialize but missing Clone
STRUCTS_WITH_DERIVE=$(grep -r -B 2 "struct" "$COMPONENT_DIR/src" | grep "derive" || true)
STRUCTS_WITH_DESERIALIZE=$(echo "$STRUCTS_WITH_DERIVE" | grep "Deserialize" || true)
STRUCTS_WITHOUT_CLONE=$(echo "$STRUCTS_WITH_DESERIALIZE" | grep -v "Clone" || true)

if [ ! -z "$STRUCTS_WITHOUT_CLONE" ]; then
  # Check if any struct without Clone is used more than once
  STRUCT_USAGE_ERROR=false
  
  # Extract struct names from the output
  while read -r line; do
    # Extract struct name using sed - matches "struct Name {"
    STRUCT_LINE=$(echo "$line" | grep -A 1 "derive" || true)
    if [ ! -z "$STRUCT_LINE" ]; then
      STRUCT_NAME=$(echo "$STRUCT_LINE" | grep "struct" | sed -E 's/.*struct\s+([A-Za-z0-9_]+).*/\1/')
      
      if [ ! -z "$STRUCT_NAME" ]; then
        # Count usages of this struct (excluding declaration and imports)
        USAGE_COUNT=$(grep -r "$STRUCT_NAME" "$COMPONENT_DIR"/src/*.rs | grep -v "struct $STRUCT_NAME" | grep -v "use.*$STRUCT_NAME" | wc -l)
        
        # If used multiple times or in JSON handling, it should have Clone
        if [ "$USAGE_COUNT" -gt 2 ] || grep -q "serde_json.*$STRUCT_NAME" "$COMPONENT_DIR"/src/*.rs; then
          STRUCT_USAGE_ERROR=true
          break
        fi
      fi
    fi
  done <<< "$STRUCTS_WITHOUT_CLONE"
  
  # If HTTP request component or multiple usages detected, make it an error
  if [ "$HTTP_USAGE" != "0" ] && [ "$STRUCT_USAGE_ERROR" = true ]; then
    add_error "Found structs with Deserialize but missing Clone derivation that are used multiple times:
    $STRUCTS_WITHOUT_CLONE
  
  Structs used multiple times with API responses MUST derive Clone to prevent ownership errors.
  Fix: Add Clone to the derive list like this:
    #[derive(Serialize, Deserialize, Debug, Clone)]"
  else
    add_warning "Found structs with Deserialize but missing Clone derivation:
    $STRUCTS_WITHOUT_CLONE
  
  Consider adding Clone for consistency:
    #[derive(Serialize, Deserialize, Debug, Clone)]"
  fi
fi

# 2b. Check for temporary clone pattern (&data.clone())
echo "📝 Checking for incorrect &data.clone() pattern..."
TEMP_CLONE_PATTERN=$(grep -r "&.*\.clone()" "$COMPONENT_DIR"/src/*.rs || true)
if [ ! -z "$TEMP_CLONE_PATTERN" ]; then
  add_error "Found dangerous &data.clone() pattern which creates temporary values that are immediately dropped.
      This pattern causes ownership issues because the cloned data is immediately dropped.
      Fix: Create a named variable to hold the cloned data instead:
      WRONG:  let result = std::str::from_utf8(&data.clone());
      RIGHT:  let data_clone = data.clone();
              let result = std::str::from_utf8(&data_clone);
      $TEMP_CLONE_PATTERN"
fi

# 2c. Check for potential "move out of index" errors
echo "📝 Checking for potential 'move out of index' errors..."
MOVE_OUT_INDEX=$(grep -r "\[.*\]\..*" "$COMPONENT_DIR"/src/*.rs | grep -v "\.clone()" | grep -v "\.as_ref()" | grep -v "&" | grep -v "bindings.rs" || true)
if [ ! -z "$MOVE_OUT_INDEX" ]; then
  add_error "Found potential 'move out of index' errors - accessing collection elements without cloning.
      When accessing fields from elements in a collection, you should clone the field to avoid
      moving out of the collection, which would make the collection unusable afterward.
      WRONG:  let field = collection[0].field; // This moves the field out of the collection
      RIGHT:  let field = collection[0].field.clone(); // This clones the field
      $MOVE_OUT_INDEX"
fi

#=====================================================================================
# ERROR HANDLING CHECKS
#=====================================================================================
print_section "ERROR HANDLING CHECKS"

# 3a. Check for map_err on Option types - focus only on get_evm_chain_config specifically
echo "📝 Checking for map_err on Option types..."
MAP_ERR_CHAIN_CONFIG=$(grep -r "get_evm_chain_config" "$COMPONENT_DIR"/src/*.rs | grep "map_err" | grep -v "ok_or_else" 2>/dev/null || true)

if [ ! -z "$MAP_ERR_CHAIN_CONFIG" ]; then
  add_error "Found map_err used directly on get_evm_chain_config which returns Option, not Result.
      Option types don't have map_err method - it's only available on Result types.
      WRONG:  get_evm_chain_config(\"ethereum\").map_err(|e| e.to_string())?
      RIGHT:  get_evm_chain_config(\"ethereum\").ok_or_else(|| \"Failed to get config\".to_string())?
      $MAP_ERR_CHAIN_CONFIG"
fi

#=====================================================================================
# IMPORT CHECKS
#=====================================================================================
print_section "IMPORT CHECKS"

# 4a. Check for proper import of essential traits and types
echo "📝 Checking for essential imports..."
if grep -r "FromStr" "$COMPONENT_DIR"/src/*.rs > /dev/null && ! grep -r "use std::str::FromStr" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  FROMSTR_USAGE=$(grep -r "FromStr" "$COMPONENT_DIR"/src/*.rs | grep -v "use std::str::FromStr" || true)
  add_error "Found FromStr usage but std::str::FromStr is not imported.
      This will cause a compile error when using methods like from_str or parse<Type>().
      Fix: Add 'use std::str::FromStr;' to your imports.
      $FROMSTR_USAGE"
fi

# 4b. Check for min function usage without import
if grep -r "min(" "$COMPONENT_DIR"/src/*.rs > /dev/null && ! grep -r "use std::cmp::min" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  MIN_USAGE=$(grep -r "min(" "$COMPONENT_DIR"/src/*.rs | grep -v "use std::cmp::min" || true)
  add_error "Found min function usage but std::cmp::min is not imported.
      This will cause a compile error when using min().
      Fix: Add 'use std::cmp::min;' to your imports.
      $MIN_USAGE"
fi

# 4c. Check for TxKind import issues
if grep -r "alloy_rpc_types::eth::TxKind" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  TXKIND_USAGE=$(grep -r "alloy_rpc_types::eth::TxKind" "$COMPONENT_DIR"/src/*.rs || true)
  add_error "Found incorrect TxKind import path. Use alloy_primitives::TxKind instead of alloy_rpc_types::eth::TxKind.
      This is a critical error that will prevent component compilation.
      Fix: 1. Add 'use alloy_primitives::{Address, TxKind, U256};' (or add TxKind to existing import)
           2. Replace 'alloy_rpc_types::eth::TxKind::Call' with 'TxKind::Call'
      $TXKIND_USAGE"
fi

# 4d. Check for TxKind usage without import
if grep -r "::Call" "$COMPONENT_DIR"/src/*.rs > /dev/null && ! grep -r "use.*TxKind" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  CALL_USAGE=$(grep -r "::Call" "$COMPONENT_DIR"/src/*.rs | grep -v "use.*TxKind" || true)
  add_error "Found TxKind usage but TxKind is not properly imported.
      Fix: Add 'use alloy_primitives::TxKind;' to your imports.
      $CALL_USAGE"
fi

# 4e. Check for block_on usage without the correct import - improved to handle grouped imports
echo "📝 Checking for block_on import..."
if grep -r "block_on" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  # Check both formats: direct import and grouped import
  DIRECT_IMPORT=$(grep -r "use wstd::runtime::block_on" "$COMPONENT_DIR"/src/*.rs || true)
  GROUPED_IMPORT=$(grep -r "use wstd::{.*runtime::block_on" "$COMPONENT_DIR"/src/*.rs || true)
  RUNTIME_IMPORT=$(grep -r "use wstd::.*runtime" "$COMPONENT_DIR"/src/*.rs || true)
  
  if [ -z "$DIRECT_IMPORT" ] && [ -z "$GROUPED_IMPORT" ] && [ -z "$RUNTIME_IMPORT" ]; then
    BLOCK_ON_USAGE=$(grep -r "block_on" "$COMPONENT_DIR"/src/*.rs || true)
    add_error "Found block_on usage but wstd::runtime::block_on is not imported.
      This will cause a compile error when using async functions.
      Fix: Add 'use wstd::runtime::block_on;' to your imports.
      $BLOCK_ON_USAGE"
  fi
fi

# 4f. Check for HTTP function imports
if grep -r "http_request_" "$COMPONENT_DIR"/src/*.rs > /dev/null || grep -r "fetch_json" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  # Check for both direct import and grouped import patterns
  DIRECT_HTTP_IMPORT=$(grep -r "use wavs_wasi_utils::http::" "$COMPONENT_DIR"/src/*.rs || true)
  GROUPED_HTTP_IMPORT=$(grep -r "use wavs_wasi_utils::{.*http::{.*fetch_json\|.*http_request_" "$COMPONENT_DIR"/src/*.rs || true)
  
  if [ -z "$DIRECT_HTTP_IMPORT" ] && [ -z "$GROUPED_HTTP_IMPORT" ]; then
    HTTP_USAGE=$(grep -r "http_request_\|fetch_json" "$COMPONENT_DIR"/src/*.rs || true)
    add_error "Found HTTP function usage but wavs_wasi_utils::http is not imported.
      Fix: Add 'use wavs_wasi_utils::http::{fetch_json, http_request_get};' to your imports.
      $HTTP_USAGE"
  fi
fi

# 4g. Check for SolCall trait missing when using abi_encode
if grep -r "abi_encode" "$COMPONENT_DIR"/src/*.rs > /dev/null && ! grep -r "use.*SolCall" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  if grep -r "Call.*abi_encode" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
    CALL_ABI_USAGE=$(grep -r "Call.*abi_encode" "$COMPONENT_DIR"/src/*.rs || true)
    add_error "Found Call::abi_encode usage but SolCall trait is not imported.
      Function calls require the SolCall trait for encoding.
      Fix: Add 'use alloy_sol_types::{SolCall, SolValue};' to your imports.
      $CALL_ABI_USAGE"
  fi
fi

# After the existing import checks, add:
echo "📝 Checking for missing dependencies..."
# Get all local module names (mod foo;) from src/*.rs
LOCAL_MODS=$(grep -h -E '^mod ' "$COMPONENT_DIR"/src/*.rs | sed -E 's/^mod ([a-zA-Z0-9_]+);/\1/' | sort | uniq)
# Add known local modules
LOCAL_MODS="$LOCAL_MODS trigger bindings"
# Get all imports from the code, extract just the crate names
IMPORTS=$(grep -h -r "^use" "$COMPONENT_DIR"/src/*.rs | \
  sed -E 's/^use[[:space:]]+//' | \
  sed -E 's/ as [^;]+//' | \
  sed -E 's/[{].*//' | \
  sed -E 's/;.*//' | \
  cut -d: -f1 | \
  awk -F'::' '{print $1}' | \
  grep -vE '^(crate|self|super|std|core|wavs_wasi_utils|wstd)$' | \
  sort | uniq)

# Check each import against Cargo.toml dependencies
for import in $IMPORTS; do
  # Skip empty lines
  if [[ -z "$import" ]]; then
    continue
  fi
  # Skip local modules
  if echo "$LOCAL_MODS" | grep -wq "$import"; then
    continue
  fi
  # Convert import name to Cargo.toml format (replace underscores with hyphens)
  cargo_name=$(echo "$import" | tr '_' '-')
  # Check if the import is in Cargo.toml (either directly or as a workspace dependency)
  if ! grep -q "$cargo_name.*=.*{.*workspace.*=.*true" "$COMPONENT_DIR/Cargo.toml" && ! grep -q "$cargo_name.*=.*\"" "$COMPONENT_DIR/Cargo.toml"; then
    add_error "Import '$import' is used but not found in Cargo.toml dependencies.
        Add it to your [dependencies] section in Cargo.toml and to [workspace.dependencies] in the root Cargo.toml."
  fi
done

#=====================================================================================
# COMPONENT STRUCTURE CHECKS 
#=====================================================================================
print_section "COMPONENT STRUCTURE CHECKS"

# 5a. Check for proper export! macro usage and syntax
echo "📝 Checking for proper component export..."
if ! grep -r "export!" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  add_error "export! macro not found. Components must use export! macro.
      Fix: Add 'export!(YourComponent with_types_in bindings);' to your component."
fi

# 5b. Check for correct export! macro syntax with with_types_in
if grep -r "export!" "$COMPONENT_DIR"/src/*.rs > /dev/null && ! grep -r "export!.*with_types_in bindings" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  EXPORT_USAGE=$(grep -r "export!" "$COMPONENT_DIR"/src/*.rs || true)
  add_error "Incorrect export! macro syntax. Use 'export!(YourComponent with_types_in bindings)' instead of just 'export!(YourComponent)'.
      Fix: Update to 'export!(YourComponent with_types_in bindings);'
      $EXPORT_USAGE"
fi

# 5c. Check for TriggerAction structure usage issues
echo "📝 Checking for TriggerAction structure usage..."
if grep -r "trigger.trigger_data" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  TRIGGER_DATA_USAGE=$(grep -r "trigger.trigger_data" "$COMPONENT_DIR"/src/*.rs || true)
  add_error "Component accesses non-existent 'trigger_data' field on TriggerAction. Use 'trigger.data' instead.
      $TRIGGER_DATA_USAGE"
fi

# 5d. Check for incorrect match pattern on trigger.data (treating it as Option)
if grep -r -A 5 -B 2 "match trigger.data" "$COMPONENT_DIR"/src/*.rs 2>/dev/null | grep -q "Some(" &&
   grep -r -A 8 -B 2 "match trigger.data" "$COMPONENT_DIR"/src/*.rs 2>/dev/null | grep -q "None =>"; then
  TRIGGER_MATCH=$(grep -r -A 5 -B 2 "match trigger.data" "$COMPONENT_DIR"/src/*.rs || true)
  add_error "Component incorrectly treats 'trigger.data' as an Option<TriggerData>, but it's a TriggerData.
      The field is not optional - don't match against Some/None patterns.
      $TRIGGER_MATCH"
fi

# 5e. Check for Guest trait implementation
if ! grep -r "impl Guest for" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  add_error "Guest trait implementation not found. Components must implement the Guest trait.
      Fix: Add 'impl Guest for YourComponent { fn run(trigger: TriggerAction) -> Result<Option<WasmResponse>, String> { ... } }'"
fi

# 5f. Check for run function with correct signature - improved to accept variations in naming/qualification
if ! grep -r "fn run(.*TriggerAction.*) -> .*Result<Option<WasmResponse>, String>" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  add_error "run function with correct result signature not found.
      The run function must return std::result::Result<Option<WasmResponse>, String>"
fi

#=====================================================================================
# SECURITY CHECKS 
#=====================================================================================
print_section "SECURITY CHECKS"

# 6a. Check for hardcoded API keys
echo "📝 Checking for hardcoded API keys..."
API_KEYS=$(grep -r "key=.*[0-9a-zA-Z]\{8,\}" "$COMPONENT_DIR" --include="*.rs" || true)
if [ ! -z "$API_KEYS" ]; then
  add_error "Found possible hardcoded API key. Use environment variables instead.
      Fix: Use std::env::var(\"WAVS_ENV_YOUR_API_KEY\") to get API keys from environment variables.
      $API_KEYS"
fi

# 6b. Check for other potential hardcoded secrets
OTHER_SECRETS=$(grep -r "token=\|secret=\|password=" "$COMPONENT_DIR" --include="*.rs" | grep "[0-9a-zA-Z]\{8,\}" || true)
if [ ! -z "$OTHER_SECRETS" ]; then
  add_error "Found possible hardcoded secret. Use environment variables instead.
      Fix: Use std::env::var(\"WAVS_ENV_YOUR_SECRET\") to get secrets from environment variables.
      $OTHER_SECRETS"
fi

#=====================================================================================
# DEPENDENCIES CHECKS
#=====================================================================================
print_section "DEPENDENCIES CHECKS"

# 7. Check for proper workspace dependency usage
echo "📝 Checking for proper workspace dependency usage..."
VERSION_NUMBERS=$(grep -r "version = \"[0-9]" "$COMPONENT_DIR/Cargo.toml" || true)
if [ ! -z "$VERSION_NUMBERS" ]; then
  add_error "Found direct version numbers in Cargo.toml. Use workspace = true instead.
      Fix: Replace version numbers with { workspace = true } for all dependencies.
      WRONG:  some-crate = \"0.1.0\"
      RIGHT:  some-crate = { workspace = true }
      $VERSION_NUMBERS"
fi

#=====================================================================================
# CODE QUALITY CHECKS
#=====================================================================================
print_section "CODE QUALITY CHECKS"

# 8. Check for unused imports with cargo check
echo "📝 Checking for unused imports and code issues..."
cd "$SCRIPT_DIR/.."
COMPONENT_NAME_SIMPLE=$(basename "$COMPONENT_DIR")

# Run cargo check and capture any errors (not just warnings)
CARGO_OUTPUT=$(cargo check -p "$COMPONENT_NAME_SIMPLE" 2>&1)
CARGO_ERRORS=$(echo "$CARGO_OUTPUT" | grep -i "error:" | grep -v "generated file bindings.rs" || true)

if [ ! -z "$CARGO_ERRORS" ]; then
  add_error "cargo check found compilation errors:
  $CARGO_ERRORS"
fi

# Show warnings but don't fail on them
CARGO_WARNINGS=$(echo "$CARGO_OUTPUT" | grep -i "warning:" | grep -v "profiles for the non root package" || true)
if [ ! -z "$CARGO_WARNINGS" ]; then
  add_warning "cargo check found warnings that might indicate issues:
  $CARGO_WARNINGS"
fi

cd "$SCRIPT_DIR"

#=====================================================================================
# SOLIDITY TYPES CHECKS
#=====================================================================================
print_section "SOLIDITY TYPES CHECKS"

# 9a. Check for sol! macro usage without proper import
echo "📝 Checking for sol! macro imports..."
if grep -r "sol!" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  if ! grep -r "use alloy_sol_types::sol" "$COMPONENT_DIR"/src/*.rs > /dev/null && ! grep -r "use alloy_sol_macro::sol" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
    SOL_USAGE=$(grep -r "sol!" "$COMPONENT_DIR"/src/*.rs || true)
    add_error "Found sol! macro usage but neither alloy_sol_types::sol nor alloy_sol_macro::sol is imported.
      Fix: Add 'use alloy_sol_types::sol;' to your imports.
      $SOL_USAGE"
  fi
fi

# 9b. Check for solidity module structure
echo "📝 Checking for proper solidity module structure..."
if grep -r "sol::" "$COMPONENT_DIR"/src/*.rs > /dev/null && ! grep -r "mod solidity" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  SOL_NAMESPACE=$(grep -r "sol::" "$COMPONENT_DIR"/src/*.rs || true)
  add_error "Found 'sol::' namespace usage without defining a 'solidity' module.
      Fix: Create a proper module structure like:
      mod solidity {
          use alloy_sol_types::sol;
          sol! { /* your solidity types */ }
      }
      $SOL_NAMESPACE"
fi

# 9c. Check for string literals assigned to String type fields in structs
echo "📝 Checking for string literal to String conversions..."
# Look for patterns like 'field: "string literal",' in struct initializations
# Only check lib.rs to avoid auto-generated bindings.rs
if [ -f "$COMPONENT_DIR/src/lib.rs" ]; then
  STRING_FIELDS=$(grep -A 20 "pub struct" "$COMPONENT_DIR/src/lib.rs" | grep -E "^\s*pub\s+[a-zA-Z0-9_]+:\s+String," | sed -E 's/^\s*pub\s+([a-zA-Z0-9_]+):\s+String,.*/\1/' || true)
  
  if [ ! -z "$STRING_FIELDS" ]; then
    # For each string field, check for literals without to_string()
    for FIELD in $STRING_FIELDS; do
      # Skip if field name is empty or contains special characters
      if [[ "$FIELD" =~ ^[a-zA-Z0-9_]+$ ]]; then
        # Look for patterns like 'field: "literal",' without to_string()
        STRING_LITERAL_USAGE=$(grep -r "$FIELD: \"" "$COMPONENT_DIR"/src/lib.rs | grep -v "\.to_string()" || true)
        
        if [ ! -z "$STRING_LITERAL_USAGE" ]; then
          add_error "Found string literals assigned directly to String type fields without .to_string() conversion:
          $STRING_LITERAL_USAGE
          
          This will cause a type mismatch error because &str cannot be assigned to String.
          Fix: Always convert string literals to String type using .to_string():
          WRONG:  field: \"literal string\",
          RIGHT:  field: \"literal string\".to_string(),"
          break
        fi
      fi
    done
  fi
fi

#=====================================================================================
# STRING SAFETY CHECKS
#=====================================================================================
print_section "STRING SAFETY CHECKS"

# 10a. Check for unbounded string.repeat operations
echo "📝 Checking for string capacity overflow risks..."

# First, collect all .repeat() calls - simpler approach to catch all possible cases
REPEAT_CALLS=$(grep -r "\.repeat(" "$COMPONENT_DIR"/src/*.rs || true)

if [ ! -z "$REPEAT_CALLS" ]; then
  # Look for any .repeat() calls with potentially unsafe variables
  RISKY_REPEAT_PATTERNS="decimals\|padding\|len\|size\|count\|width\|height\|indent\|offset\|spaces\|zeros\|chars\|digits"
  
  # Check for specific safety patterns
  SAFETY_PATTERNS="std::cmp::min\|::min(\|min(\|// SAFE:"
  
  # Check if any .repeat call doesn't use a safety bound
  UNSAFE_REPEATS=$(echo "$REPEAT_CALLS" | grep -i "$RISKY_REPEAT_PATTERNS" | grep -v "$SAFETY_PATTERNS" || true)
  
  if [ ! -z "$UNSAFE_REPEATS" ]; then
    add_error "Found potentially unbounded string.repeat operations:
$UNSAFE_REPEATS

This can cause capacity overflow errors. Options to fix:
  1. Add a direct safety check: \".repeat(std::cmp::min(variable, 100))\"
  2. Use a bounded variable: \"let safe_value = std::cmp::min(variable, MAX_SIZE); .repeat(safe_value)\"
  3. Add a safety comment if manually verified: \"// SAFE: bounded by check above\""
  fi
fi

#=====================================================================================
# NETWORK REQUEST CHECKS
#=====================================================================================
print_section "NETWORK REQUEST CHECKS"

# 11a. Check for proper block_on usage with async functions
echo "📝 Checking for proper async handling..."
if grep -r "async fn" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
  if ! grep -r "block_on" "$COMPONENT_DIR"/src/*.rs > /dev/null; then
    ASYNC_USAGE=$(grep -r "async fn" "$COMPONENT_DIR"/src/*.rs || true)
    add_error "Found async functions but no block_on usage.
      Async functions must be called with block_on in component run functions:
      block_on(async { make_request().await })
      $ASYNC_USAGE"
  fi
fi

#=====================================================================================
# FINAL SUCCESS MESSAGE
#=====================================================================================
print_section "VALIDATION SUMMARY"

# Check if there are any errors or warnings
ERROR_COUNT=${#errors[@]}
WARNING_COUNT=${#warnings[@]}

if [ $ERROR_COUNT -gt 0 ]; then
  echo "❌ Component validation failed with $ERROR_COUNT errors and $WARNING_COUNT warnings."
  echo 
  echo "⚠️  YOU MUST FIX ALL ERRORS BEFORE RUNNING 'make wasi-build'."
  echo "    Failure to fix these issues will result in build or runtime errors."
  exit 1
else
  if [ $WARNING_COUNT -gt 0 ]; then
    echo "⚠️  Component validation passed with $WARNING_COUNT warnings."
    echo "    Consider fixing these warnings to improve your component's reliability."
  else
    echo "✅ Component validation checks complete! No errors or warnings found."
  fi
  
  echo "🚀 Component is ready for building. Run the following command to build:"
  echo "    cd ../.. && make wasi-build"
fi

# After all static checks, add:
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "🔍 CARGO CHECK (compilation test)"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
cargo check --manifest-path "$(pwd)/../components/$COMPONENT_NAME/Cargo.toml" --target wasm32-wasip1
````

## File: tools/upgrade.sh
````bash
#!/bin/bash

set -e

# Take first argument as the version to upgrade to
VERSION=$1

if [ -z "$VERSION" ]; then
    echo "Usage: $0 <version>"
    exit 1
fi

# conditional sudo, just for docker
if groups | grep -q docker; then
  SUDO="";
else
  SUDO="sudo";
fi

# pull this version to ensure we have it
if ! ${SUDO} docker pull ghcr.io/lay3rlabs/wavs:${VERSION}; then
    echo "Invalid WAVS version, cannot pull ghcr.io/lay3rlabs/wavs:${VERSION}"
    exit 1
fi

# Update Makefile
sed -E -i "s/ghcr.io\/lay3rlabs\/wavs:[^ ]+/ghcr.io\/lay3rlabs\/wavs:${VERSION}/g" Makefile

# Update docker-compose.yml
sed -E -i "s/ghcr.io\/lay3rlabs\/wavs:[^\"]+/ghcr.io\/lay3rlabs\/wavs:${VERSION}/g" docker-compose.yml

# Update Cargo.toml (for crates dependencies)
sed -E -i "s/wavs-wasi-utils = \"[^\"]+/wavs-wasi-utils = \"${VERSION}/g" Cargo.toml

# Update [package.metadata.component] in components/*/Cargo.toml (for wit)
sed -E -i "s/wavs:worker\/layer-trigger-world@[^\"]+/wavs:worker\/layer-trigger-world@${VERSION}/g" components/*/Cargo.toml

# Rebuild with cargo component build in order to update bindings and Cargo.lock
rm components/*/src/bindings.rs
make wasi-build
````

## File: .env.example
````
DEPLOY_ENV=LOCAL
METADATA_URI=https://raw.githubusercontent.com/Lay3rLabs/wavs-foundry-template/refs/heads/main/metadata.json
LOCAL_ETHEREUM_RPC_URL=http://localhost:8545

CHAIN_ID=17000
TESTNET_RPC_URL=https://1rpc.io/holesky

# this key requires funds. used as the admin / deployer of contracts and core contracts.
FUNDED_KEY=

LST_CONTRACT_ADDRESS=0x3F1c547b21f65e10480dE3ad8E19fAAC46C95034
LST_STRATEGY_ADDRESS=0x7D704507b76571a51d9caE8AdDAbBFd0ba0e63d3

# https://app.pinata.cloud/developers/api-keys, JWT token
PINATA_API_KEY=
ETHERSCAN_API_KEY=foobar
````

## File: .gitignore
````
# general compile
/target
out/
cache/
broadcast/
node_modules/

# WAVS
.env
compiled/*.wasm
.docker/*.json
.docker/*.log
wavs:worker*.wit
wavs:worker*.wasm

# WAVS infra
.nodes
infra/*

# Tools
**/.claude/settings.local.json
````

## File: .solhint.json
````json
{
  "extends": "solhint:recommended",
  "rules": {
    "compiler-version": ["warn"],
    "quotes": "off",
    "func-visibility": ["warn", { "ignoreConstructors": true }],
    "no-inline-assembly": "off",
    "no-empty-blocks": "off",
    "private-vars-leading-underscore": ["warn", { "strict": false }],
    "ordering": "warn",
    "avoid-low-level-calls": "off",
    "named-parameters-mapping": "warn"
  }
}
````

## File: Cargo-component.lock
````
# This file is automatically generated by cargo-component.
# It is not intended for manual editing.
version = 1

[[package]]
name = "wavs:worker"

[[package.version]]
requirement = "^0.4.0"
version = "0.4.0"
digest = "sha256:3530635218173131d0af9f114f61d97f08f080b3e25f1daacb15dc6dafa302ec"
````

## File: Cargo.toml
````toml
[workspace]
members = ["components/evm-price-oracle"]
resolver = "2"

[workspace.package]
edition = "2021"
version = "0.4.0"
license = "MIT"
authors = ["Lay3r Labs Team"]
repository = "https://github.com/Lay3rLabs/wavs"
rust-version = "1.80.0"

[workspace.dependencies]
# WASI
wit-bindgen-rt = { version = "0.42.1", features = ["bitflags"] }
wit-bindgen = "0.42.1"
wstd = "0.5.3"
wasi = "0.14.1"
wavs-wasi-utils = "0.4.0"

# Other
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
anyhow = "1.0.98"

## Alloy
alloy-sol-macro = { version = "1.0.0", features = ["json"] }
alloy-sol-types = "1.0.0"
alloy-network = "0.15.10"
alloy-primitives = "1.0.0"
alloy-provider = { version = "0.15.10", default-features = false, features = [
    "rpc-api",
] }
alloy-rpc-types = "0.15.10"
alloy-contract = "0.15.10"
````

## File: claude.md
````markdown
# WAVS Component Creation Guide

You specialize in creating WAVS (WASI AVS) components. Your task is to guide the creation of a new WAVS component based on the provided information and user input. Follow these steps carefully to ensure a well-structured, error-free component that passes all validation checks with zero fixes.

## Component Structure

A WAVS component needs:
1. `Cargo.toml` - Dependencies configuration
2. `src/lib.rs` - Component implementation logic goes here
3. `src/trigger.rs` - trigger handling logic
4. `src/bindings.rs` - Auto-generated, never edit
5. `Makefile` - Do not edit
6. `config.json` - Only edit the name

## Creating a Component

### 1. Cargo.toml Template

```toml
[package]
name = "your-component-name"
edition.workspace = true
version.workspace = true
authors.workspace = true
rust-version.workspace = true
repository.workspace = true

[dependencies]
# Core dependencies (always needed)
wit-bindgen-rt ={ workspace = true}
wavs-wasi-utils = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
alloy-sol-macro = { workspace = true }
wstd = { workspace = true }
alloy-sol-types = { workspace = true }
anyhow = { workspace = true }

# Add for blockchain interactions
alloy-primitives = { workspace = true }
alloy-provider = { workspace = true }
alloy-rpc-types = { workspace = true }
alloy-network = { workspace = true }
alloy-contract = { workspace = true }

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "s"
debug = false
strip = true
lto = true

[package.metadata.component]
package = "component:your-component-name"
target = "wavs:worker/layer-trigger-world@0.4.0-beta.4"
```

CRITICAL: Never use direct version numbers - always use `{ workspace = true }`.
IMPORTANT! Always add your component to workspace members in the root Cargo.toml

### 2. Component Implementation (lib.rs)

#### Basic Structure

```rust
mod trigger;
use trigger::{decode_trigger_event, encode_trigger_output, Destination};
use wavs_wasi_utils::{
    evm::alloy_primitives::hex,
    http::{fetch_json, http_request_get},
};
pub mod bindings;  // Never edit bindings.rs!
use crate::bindings::{export, Guest, TriggerAction, WasmResponse};
use alloy_sol_types::SolValue;
use serde::{Deserialize, Serialize};
use wstd::{http::HeaderValue, runtime::block_on};
use anyhow::Result;

struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<WasmResponse>, String> {
        let (trigger_id, req, dest) = 
            decode_trigger_event(action.data).map_err(|e| e.to_string())?;
            
        // Decode trigger data inline - handles hex string input
        let request_input = {
            // First, convert the input bytes to a string to check if it's a hex string
            let input_str = String::from_utf8(req.clone())
                .map_err(|e| format!("Input is not valid UTF-8: {}", e))?;

            // Check if it's a hex string (starts with "0x")
            let hex_data = if input_str.starts_with("0x") {
                // Decode the hex string to bytes
                hex::decode(&input_str[2..])
                    .map_err(|e| format!("Failed to decode hex string: {}", e))?
            } else {
                // If it's not a hex string, assume the input is already binary data
                req.clone()
            };

            // Now ABI decode the binary data as a string parameter
            <String as SolValue>::abi_decode(&hex_data)
                .map_err(|e| format!("Failed to decode input as ABI string: {}", e))?
        };
        println!("Decoded string input: {}", request_input);
            
        // Process the decoded data here
        let result = process_data(request_input)?;
        
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &result)),
            Destination::CliOutput => Some(WasmResponse { payload: result.into(), ordering: None }),
        };
        Ok(output)
    }
}

// Example processing function - replace with your actual logic
fn process_data(input: String) -> Result<Vec<u8>, String> {
    // Your processing logic here
    Ok(input.as_bytes().to_vec())
}
```

#### Trigger Event Handling (trigger.rs)

```rust
use crate::bindings::wavs::worker::layer_types::{
    TriggerData, TriggerDataEvmContractEvent, WasmResponse,
};
use alloy_sol_types::SolValue;
use anyhow::Result;
use wavs_wasi_utils::decode_event_log_data;

pub enum Destination {
    Ethereum,
    CliOutput,
}

pub fn decode_trigger_event(trigger_data: TriggerData) -> Result<(u64, Vec<u8>, Destination)> {
    match trigger_data {
        TriggerData::EvmContractEvent(TriggerDataEvmContractEvent { log, .. }) => {
            let event: solidity::NewTrigger = decode_event_log_data!(log)?;
            let trigger_info = <solidity::TriggerInfo as SolValue>::abi_decode(&event._triggerInfo)?;
            Ok((trigger_info.triggerId, trigger_info.data.to_vec(), Destination::Ethereum))
        }
        TriggerData::Raw(data) => Ok((0, data.clone(), Destination::CliOutput)),
        _ => Err(anyhow::anyhow!("Unsupported trigger data type")),
    }
}

pub fn encode_trigger_output(trigger_id: u64, output: impl AsRef<[u8]>) -> WasmResponse {
    WasmResponse {
        payload: solidity::DataWithId {
            triggerId: trigger_id,
            data: output.as_ref().to_vec().into(),
        }
        .abi_encode(),
        ordering: None,
    }
}

pub mod solidity {
    use alloy_sol_macro::sol;
    pub use ITypes::*;
    sol!("../../src/interfaces/ITypes.sol");

    // trigger contract function that encodes string input
    sol! {
        function addTrigger(string data) external;
    }
}
```

## Critical Components

### 1. ABI Handling

NEVER use `String::from_utf8` on ABI-encoded data. This will ALWAYS fail with "invalid utf-8 sequence".

```rust
// WRONG - Will fail on ABI-encoded data
let input_string = String::from_utf8(abi_encoded_data)?;

// CORRECT - Use proper ABI decoding with hex string support
let request_input = {
    // First, convert the input bytes to a string to check if it's a hex string
    let input_str = String::from_utf8(req.clone())
        .map_err(|e| format!("Input is not valid UTF-8: {}", e))?;

    // Check if it's a hex string (starts with "0x")
    let hex_data = if input_str.starts_with("0x") {
        // Decode the hex string to bytes
        hex::decode(&input_str[2..])
            .map_err(|e| format!("Failed to decode hex string: {}", e))?
    } else {
        // If it's not a hex string, assume the input is already binary data
        req.clone()
    };

    // Now ABI decode the binary data as a string parameter
    <String as SolValue>::abi_decode(&hex_data)
        .map_err(|e| format!("Failed to decode input as ABI string: {}", e))?
};

// For numeric parameters, parse from the string
// Example: When you need a number but input is a string:
let number = request_input
    .trim()
    .parse::<u64>()
    .map_err(|_| format!("Invalid number: {}", request_input))?;

// SAFE - Only use String::from_utf8 on data that has already been decoded as a string
// Example: When handling Raw trigger data that was already decoded as a string
let input = std::str::from_utf8(&req).map_err(|e| e.to_string())?;
```

### 2. Data Structure Ownership

ALWAYS derive `Clone` for API response data structures. If fields may be missing, also use `Option<T>`, `#[serde(default)]`, and `Default`:

```rust
#[derive(Debug, Serialize, Deserialize, Clone, Default)]
#[serde(default)]
pub struct ResponseData {
    field1: Option<String>,
    field2: Option<u64>,
    // other fields
}
```

ALWAYS clone data before use to avoid ownership issues:

```rust
// WRONG – creates a temporary that is dropped immediately
let result = process_data(&data.clone());

// CORRECT – clone into a named variable
let data_clone = data.clone();
let result = process_data(&data_clone);
```


### 3. Network Requests

```rust
use wstd::runtime::block_on;
use wstd::http::HeaderValue;
use wavs_wasi_utils::http::{fetch_json, http_request_get, http_request_post_json};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone, Default)]
pub struct ApiResponse {
    #[serde(default)]
    field1: Option<String>,
    #[serde(default)]
    field2: Option<u64>,
}

async fn make_request() -> Result<ApiResponse, String> {
    let url = format!("https://api.example.com/endpoint?param={}", param);
    
    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("User-Agent", HeaderValue::from_static("Mozilla/5.0"));
    
    let response: ApiResponse = fetch_json(req).await.map_err(|e| e.to_string())?;
    Ok(response)
}

fn process_data() -> Result<ApiResponse, String> {
    block_on(async move { make_request().await })
}

// For POST requests with JSON data, use http_request_post_json(url, &data) instead of http_request_get
```

### 4. Option/Result Handling

```rust
// WRONG - Option types don't have map_err
let config = get_evm_chain_config("ethereum").map_err(|e| e.to_string())?;

// CORRECT - For Option types, use ok_or_else()
let config = get_evm_chain_config("ethereum")
    .ok_or_else(|| "Failed to get chain config".to_string())?;

// CORRECT - For Result types, use map_err()
let balance = fetch_balance(address).await
    .map_err(|e| format!("Balance fetch failed: {}", e))?;
```

### 5. Blockchain Interactions

```rust
use alloy_network::Ethereum;
use alloy_primitives::{Address, TxKind, U256};
use alloy_provider::{Provider, RootProvider};
use alloy_rpc_types::TransactionInput;
use std::str::FromStr; // Required for parsing addresses
use crate::bindings::host::get_evm_chain_config;
use wavs_wasi_utils::evm::new_evm_provider;

async fn query_blockchain(address_str: &str) -> Result<ResponseData, String> {
    // Parse address
    let address = Address::from_str(address_str)
        .map_err(|e| format!("Invalid address format: {}", e))?;
    
    // Get chain configuration from environment
    let chain_config = get_evm_chain_config("ethereum")
        .ok_or_else(|| "Failed to get chain config".to_string())?;
    
    // Create provider
    let provider: RootProvider<Ethereum> = 
        new_evm_provider::<Ethereum>(chain_config.http_endpoint.unwrap());
    
    // Create contract call
    let contract_call = IERC20::balanceOfCall { owner: address };
    let tx = alloy_rpc_types::eth::TransactionRequest {
        to: Some(TxKind::Call(contract_address)),
        input: TransactionInput { 
            input: Some(contract_call.abi_encode().into()), 
            data: None 
        },
        ..Default::default()
    };
    
    // Execute call
    let result = provider.call(tx).await.map_err(|e| e.to_string())?;
    let balance: U256 = U256::from_be_slice(&result);
    
    Ok(ResponseData { /* your data here */ })
}
```

### 6. Numeric Type Handling

```rust
// WRONG - Using .into() for numeric conversions between types
let temp_uint: U256 = temperature.into(); // DON'T DO THIS

// CORRECT - String parsing method works reliably for all numeric types
let temperature: u128 = 29300;
let temperature_uint256 = temperature.to_string().parse::<U256>().unwrap();

// CORRECT - Always use explicit casts between numeric types
let decimals: u8 = decimals_u32 as u8;

// CORRECT - Handling token decimals correctly
let mut divisor = U256::from(1);
for _ in 0..decimals {
    divisor = divisor * U256::from(10);
}
let formatted_amount = amount / divisor;
```

## Component Examples by Task

Here are templates for common WAVS component tasks:

### 1. Token Balance Checker

```rust
// IMPORTS
use alloy_network::Ethereum;
use alloy_primitives::{Address, TxKind, U256};
use alloy_provider::{Provider, RootProvider};
use alloy_rpc_types::TransactionInput;
use alloy_sol_types::{sol, SolCall, SolValue};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::str::FromStr;
use wavs_wasi_utils::{
    evm::{alloy_primitives::hex, new_evm_provider},
};
use wstd::runtime::block_on;

pub mod bindings;
mod trigger;
use trigger::{decode_trigger_event, encode_trigger_output, Destination};
use crate::bindings::host::get_evm_chain_config;
use crate::bindings::wavs::worker::layer_types::{TriggerData, TriggerDataEvmContractEvent};
use crate::bindings::{export, Guest, TriggerAction, WasmResponse};

// TOKEN INTERFACE
sol! {
    interface IERC20 {
        function balanceOf(address owner) external view returns (uint256);
        function decimals() external view returns (uint8);
    }
}

// FIXED CONTRACT ADDRESS
const TOKEN_CONTRACT_ADDRESS: &str = "0x..."; // Your token contract address

// RESPONSE STRUCTURE - MUST DERIVE CLONE
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TokenBalanceData {
    wallet: String,
    balance_raw: String,
    balance_formatted: String,
    token_contract: String,
}

// COMPONENT IMPLEMENTATION
struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<WasmResponse>, String> {
        let (trigger_id, req, dest) = 
            decode_trigger_event(action.data).map_err(|e| e.to_string())?;
        
        // Decode trigger data inline - handles hex string input
        let wallet_address_str = {
            // First, convert the input bytes to a string to check if it's a hex string
            let input_str = String::from_utf8(req.clone())
                .map_err(|e| format!("Input is not valid UTF-8: {}", e))?;

            // Check if it's a hex string (starts with "0x")
            let hex_data = if input_str.starts_with("0x") {
                // Decode the hex string to bytes
                hex::decode(&input_str[2..])
                    .map_err(|e| format!("Failed to decode hex string: {}", e))?
            } else {
                // If it's not a hex string, assume the input is already binary data
                req.clone()
            };

            // Now ABI decode the binary data as a string parameter
            <String as SolValue>::abi_decode(&hex_data)
                .map_err(|e| format!("Failed to decode input as ABI string: {}", e))?
        };
        
        // Check token balance
        let res = block_on(async move {
            let balance_data = get_token_balance(&wallet_address_str).await?;
            serde_json::to_vec(&balance_data).map_err(|e| e.to_string())
        })?;
        
        // Return result based on destination
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
            Destination::CliOutput => Some(WasmResponse { payload: res.into(), ordering: None }),
        };
        Ok(output)
    }
}

// BALANCE CHECKER IMPLEMENTATION
async fn get_token_balance(wallet_address_str: &str) -> Result<TokenBalanceData, String> {
    // Parse wallet address
    let wallet_address = Address::from_str(wallet_address_str)
        .map_err(|e| format!("Invalid wallet address: {}", e))?;
    
    // Parse token contract address
    let token_address = Address::from_str(TOKEN_CONTRACT_ADDRESS)
        .map_err(|e| format!("Invalid token address: {}", e))?;
    
    // Get Ethereum provider
    let chain_config = get_evm_chain_config("ethereum")
        .ok_or_else(|| "Failed to get Ethereum chain config".to_string())?;
    
    let provider: RootProvider<Ethereum> = 
        new_evm_provider::<Ethereum>(chain_config.http_endpoint.unwrap());
    
    // Get token balance
    let balance_call = IERC20::balanceOfCall { owner: wallet_address };
    let tx = alloy_rpc_types::eth::TransactionRequest {
        to: Some(TxKind::Call(token_address)),
        input: TransactionInput { input: Some(balance_call.abi_encode().into()), data: None },
        ..Default::default()
    };
    
    let result = provider.call(tx).await.map_err(|e| e.to_string())?;
    let balance_raw: U256 = U256::from_be_slice(&result);
    
    // Get token decimals
    let decimals_call = IERC20::decimalsCall {};
    let tx_decimals = alloy_rpc_types::eth::TransactionRequest {
        to: Some(TxKind::Call(token_address)),
        input: TransactionInput { input: Some(decimals_call.abi_encode().into()), data: None },
        ..Default::default()
    };
    
    let result_decimals = provider.call(tx_decimals).await.map_err(|e| e.to_string())?;
    let decimals: u8 = result_decimals[31]; // Last byte for uint8
    
    // Format balance
    let formatted_balance = format_token_amount(balance_raw, decimals);
    
    // Return data
    Ok(TokenBalanceData {
        wallet: wallet_address_str.to_string(),
        balance_raw: balance_raw.to_string(),
        balance_formatted: formatted_balance,
        token_contract: TOKEN_CONTRACT_ADDRESS.to_string(),
    })
}
```

### 2. API Data Fetcher

Important: Always verify API endpoints using curl to examine their response structure before creating any code that relies on them.

```rust
// IMPORTS
use alloy_sol_types::{sol, SolCall, SolValue};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use wavs_wasi_utils::{
    evm::alloy_primitives::hex,
    http::{fetch_json, http_request_get},
};
use wstd::{http::HeaderValue, runtime::block_on};

pub mod bindings;
mod trigger;
use trigger::{decode_trigger_event, encode_trigger_output, Destination};
use crate::bindings::wavs::worker::layer_types::{TriggerData, TriggerDataEvmContractEvent};
use crate::bindings::{export, Guest, TriggerAction, WasmResponse};

// RESPONSE STRUCTURE - MUST DERIVE CLONE
// IMPORTANT: Always Use #[serde(default)] and Option<T> for fields from external APIs. They might be missing or inconsistent
#[derive(Debug, Serialize, Deserialize, Clone, Default)]
pub struct ApiResponse {
    // Use Option<T> for fields that might be missing in some responses
    #[serde(default)] 
    field1: Option<String>,
    #[serde(default)]
    field2: Option<u64>,
    // other fields
}

// RESULT DATA STRUCTURE - MUST DERIVE CLONE
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ResultData {
    input_param: String,
    result: String,
}

// COMPONENT IMPLEMENTATION
struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<WasmResponse>, String> {
        // Decode trigger data
        let (trigger_id, req, dest) = 
            decode_trigger_event(action.data).map_err(|e| e.to_string())?;
        
        // Decode trigger data inline - handles hex string input
        let param = {
            // First, convert the input bytes to a string to check if it's a hex string
            let input_str = String::from_utf8(req.clone())
                .map_err(|e| format!("Input is not valid UTF-8: {}", e))?;

            // Check if it's a hex string (starts with "0x")
            let hex_data = if input_str.starts_with("0x") {
                // Decode the hex string to bytes
                hex::decode(&input_str[2..])
                    .map_err(|e| format!("Failed to decode hex string: {}", e))?
            } else {
                // If it's not a hex string, assume the input is already binary data
                req.clone()
            };

            // Now ABI decode the binary data as a string parameter
            <String as SolValue>::abi_decode(&hex_data)
                .map_err(|e| format!("Failed to decode input as ABI string: {}", e))?
        };
        
        // Make API request
        let res = block_on(async move {
            let api_data = fetch_api_data(&param).await?;
            serde_json::to_vec(&api_data).map_err(|e| e.to_string())
        })?;
        
        // Return result based on destination
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
            Destination::CliOutput => Some(WasmResponse { payload: res.into(), ordering: None }),
        };
        Ok(output)
    }
}

// API FETCHER IMPLEMENTATION
async fn fetch_api_data(param: &str) -> Result<ResultData, String> {
    // Get API key from environment (IMPORTANT! you must add this variable to your .env file. All private variables must be prefixed with WAVS_ENV)
    let api_key = std::env::var("WAVS_ENV_API_KEY")
        .map_err(|_| "Failed to get API_KEY from environment variables".to_string())?;
    
    // Create API URL
    let url = format!(
        "https://api.example.com/endpoint?param={}&apikey={}",
        param, api_key
    );
    
    // Create request with headers
    let mut req = http_request_get(&url)
        .map_err(|e| format!("Failed to create request: {}", e))?;
    
    req.headers_mut().insert("Accept", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("Content-Type", HeaderValue::from_static("application/json"));
    req.headers_mut().insert("User-Agent", HeaderValue::from_static("Mozilla/5.0"));
    
    // Make API request
    let api_response: ApiResponse = fetch_json(req).await
        .map_err(|e| format!("Failed to fetch data: {}", e))?;
    
    // Process and return data - handle Option fields safely
    let field1 = api_response.field1.unwrap_or_else(|| "unknown".to_string());
    let field2 = api_response.field2.unwrap_or(0);
    
    Ok(ResultData {
        input_param: param.to_string(),
        result: format!("{}: {}", field1, field2),
    })
}
```

### 3. NFT Ownership Checker

```rust
// IMPORTS
use alloy_network::Ethereum;
use alloy_primitives::{Address, TxKind, U256};
use alloy_provider::{Provider, RootProvider};
use alloy_rpc_types::TransactionInput;
use alloy_sol_types::{sol, SolCall, SolValue};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::str::FromStr;
use wavs_wasi_utils::{
    evm::{alloy_primitives::hex, new_evm_provider},
};
use wstd::runtime::block_on;

pub mod bindings;
mod trigger;
use trigger::{decode_trigger_event, encode_trigger_output, Destination};
use crate::bindings::host::get_evm_chain_config;
use crate::bindings::wavs::worker::layer_types::{TriggerData, TriggerDataEvmContractEvent};
use crate::bindings::{export, Guest, TriggerAction, WasmResponse};

// NFT INTERFACE
sol! {
    interface IERC721 {
        function balanceOf(address owner) external view returns (uint256);
        function ownerOf(uint256 tokenId) external view returns (address);
    }
}

// FIXED CONTRACT ADDRESS
const NFT_CONTRACT_ADDRESS: &str = "0xbd3531da5cf5857e7cfaa92426877b022e612cf8"; // Bored Ape contract

// RESPONSE STRUCTURE - MUST DERIVE CLONE
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct NftOwnershipData {
    wallet: String,
    owns_nft: bool,
    balance: String,
    nft_contract: String,
    contract_name: String,
}

// COMPONENT IMPLEMENTATION
struct Component;
export!(Component with_types_in bindings);

impl Guest for Component {
    fn run(action: TriggerAction) -> std::result::Result<Option<WasmResponse>, String> {
        // Decode trigger data
        let (trigger_id, req, dest) = 
            decode_trigger_event(action.data).map_err(|e| e.to_string())?;
        
        // Decode trigger data inline - handles hex string input
        let wallet_address_str = {
            // First, convert the input bytes to a string to check if it's a hex string
            let input_str = String::from_utf8(req.clone())
                .map_err(|e| format!("Input is not valid UTF-8: {}", e))?;

            // Check if it's a hex string (starts with "0x")
            let hex_data = if input_str.starts_with("0x") {
                // Decode the hex string to bytes
                hex::decode(&input_str[2..])
                    .map_err(|e| format!("Failed to decode hex string: {}", e))?
            } else {
                // If it's not a hex string, assume the input is already binary data
                req.clone()
            };

            // Now ABI decode the binary data as a string parameter
            <String as SolValue>::abi_decode(&hex_data)
                .map_err(|e| format!("Failed to decode input as ABI string: {}", e))?
        };
        
        // Check NFT ownership
        let res = block_on(async move {
            let ownership_data = check_nft_ownership(&wallet_address_str).await?;
            serde_json::to_vec(&ownership_data).map_err(|e| e.to_string())
        })?;
        
        // Return result based on destination
        let output = match dest {
            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),
            Destination::CliOutput => Some(WasmResponse { payload: res.into(), ordering: None }),
        };
        Ok(output)
    }
}

// NFT OWNERSHIP CHECKER IMPLEMENTATION
async fn check_nft_ownership(wallet_address_str: &str) -> Result<NftOwnershipData, String> {
    // Parse wallet address
    let wallet_address = Address::from_str(wallet_address_str)
        .map_err(|e| format!("Invalid wallet address: {}", e))?;
    
    // Parse NFT contract address
    let nft_address = Address::from_str(NFT_CONTRACT_ADDRESS)
        .map_err(|e| format!("Invalid NFT contract address: {}", e))?;
    
    // Get Ethereum provider
    let chain_config = get_evm_chain_config("ethereum")
        .ok_or_else(|| "Failed to get Ethereum chain config".to_string())?;
    
    let provider: RootProvider<Ethereum> = 
        new_evm_provider::<Ethereum>(chain_config.http_endpoint.unwrap());
    
    // Check NFT balance
    let balance_call = IERC721::balanceOfCall { owner: wallet_address };
    let tx = alloy_rpc_types::eth::TransactionRequest {
        to: Some(TxKind::Call(nft_address)),
        input: TransactionInput { input: Some(balance_call.abi_encode().into()), data: None },
        ..Default::default()
    };
    
    let result = provider.call(tx).await.map_err(|e| e.to_string())?;
    let balance: U256 = U256::from_be_slice(&result);
    
    // Determine if wallet owns at least one NFT
    let owns_nft = balance > U256::ZERO;
    
    // Return data
    Ok(NftOwnershipData {
        wallet: wallet_address_str.to_string(),
        owns_nft,
        balance: balance.to_string(),
        nft_contract: NFT_CONTRACT_ADDRESS.to_string(),
        contract_name: "BAYC".to_string(),
    })
}
```


## Component Creation Process

### Phase 1: Planning

When you ask me to create a WAVS component, I'll follow this systematic process to ensure it works perfectly on the first try:

1. **Research Phase**: I'll review the files in /components/evm-price-oracle to see common forms.
2. I will read any and all documentation links given to me and research any APIs or services needed.
3. I'll read `/test_utils/validate_component.sh` to see what validation checks I need to pass.
4. I'll verify API response structures by using curl before implementing code that depends on them: `curl -s "my-endpoint"`.
5.  I'll create a file called plan.md with an overview of the component I will make. I'll do this before actually creating the lib.rs file. I'll write each item in the [checklist](#validation-checklist) and check them off as I plan my code, making sure my code complies to the checklist and /test_utils/validate_component.sh. Each item must be checked and verified. I will list out all imports I will need. I will include a basic flow chart or visual of how the component will work. I will put plan.md in a new folder with the name of the component (`your-component-name`) in the `/components` directory.


### Phase 2: Implementation

After being 100% certain that my idea for a component will work without any errors on the build and completing all planning steps, I will:

1. Check for errors before coding.

2. Copy the bindings, makefile (update filename in makefile), and config.json using the following command (bindings will be written over during the build):

   ```bash
   mkdir -p components/your-component-name/src && \
   cp components/evm-price-oracle/src/bindings.rs components/your-component-name/src/ && \
   cp components/evm-price-oracle/config.json components/your-component-name/ && \
   cp components/evm-price-oracle/Makefile components/your-component-name/
   ```

3.  Then, I will create trigger.rs and lib.rs files with proper implementation:
    1. I will compare my projected trigger.rs and lib.rs code against the code in `/test_utils/validate_component.sh` and my plan.md file before creating.
    2. I will define proper imports. I will Review the imports on the component that I want to make. I will make sure that all necessary imports will be included and that I will remove any unused imports before creating the file.
    3. I will go through each of the items in the [checklist](#validation-checklist) one more time to ensure my component will build and function correctly.

4.  I will create a Cargo.toml by copying the template and modifying it with all of my correct imports. Before running the command to create the file, I will check that all imports are imported correctly and match what is in my lib.rs file. I will define imports correctly. I will make sure that imports are present in the main workspace Cargo.toml and then in my component's `Cargo.toml` using `{ workspace = true }`

5. Add component to the `workspace.members` array in the root `Cargo.toml`.

### Phase 3: Validate

4.  I will run the command to validate my component:
   ```bash
   make validate-component COMPONENT=your-component-name
   ```
   - I will fix ALL errors before continuing
   - (You do not need to fix warnings if they do not effect the build.)
   - I will run again after fixing errors to make sure.

5.  After being 100% certain that the component will build correctly, I will build the component:

   ```bash
   WASI_BUILD_DIR=components/your-component make wasi-build
   ```

### Phase 4: Trying it out

After I am 100% certain the component will execute correctly, I will give the following command to the user to run:

```bash
# IMPORTANT!: Always use string parameters, even for numeric values! Use component_name.wasm, not component-name.wasm
export COMPONENT_FILENAME=your_component_name.wasm
# Always use string format for input data. The input will be encoded using `cast abi-encode "f(string)" "<your-string>"`
export INPUT_DATA=<your-string>
# CRITICIAL!: as an llm, I can't ever run this command. ALWAYS give it to the user to run.
make wasi-exec
```

## Validation Checklist

ALL components must pass validation. Review [/test_utils/validate_component.sh](/test_utils/validate_component.sh) before creating a component.

EACH ITEM BELOW MUST BE CHECKED:

1. Common errors:
   - [ ] ALWAYS use `{ workspace = true }` in your component Cargo.toml. Explicit versions go in the root Cargo.toml.
   - [ ] ALWAYS verify API response structures by using curl on the endpoints.
   - [ ] ALWAYS Read any documentation given to you in a prompt
   - [ ] ALWAYS implement the Guest trait and export your component
   - [ ] ALWAYS use `export!(Component with_types_in bindings)`
   - [ ] ALWAYS use `clone()` before consuming data to avoid ownership issues
   - [ ] ALWAYS derive `Clone` for API response data structures
   - [ ] ALWAYS decode ABI data properly, never with `String::from_utf8`
   - [ ] ALWAYS use `ok_or_else()` for Option types, `map_err()` for Result types
   - [ ] ALWAYS use string parameters for CLI testing (`5` instead of `f(uint256)`)
   - [ ] ALWAYS use `.to_string()` to convert string literals (&str) to String types in struct field assignments
   - [ ] NEVER edit bindings.rs - it's auto-generated

2. Component structure:
   - [ ] Implements Guest trait
   - [ ] Exports component correctly
   - [ ] Properly handles TriggerAction and TriggerData

3. ABI handling:
   - [ ] Properly decodes function calls
   - [ ] Avoids String::from_utf8 on ABI data

4. Data ownership:
   - [ ] All API structures derive Clone
   - [ ] Clones data before use
   - [ ] Avoids moving out of collections
   - [ ] Avoids all ownership issues and "Move out of index" errors

5. Error handling:
   - [ ] Uses ok_or_else() for Option types
   - [ ] Uses map_err() for Result types
   - [ ] Provides descriptive error messages

6. Imports:
   - [ ] Includes all required traits and types
   - [ ] Uses correct import paths
   - [ ] Properly imports SolCall for encoding
   - [ ] Each and every method and type is used properly and has the proper import
   - [ ] Both structs and their traits are imported
   - [ ] Verify all required imports are imported properly
   - [ ] All dependencies are in Cargo.toml with `{workspace = true}`
   - [ ] Any unused imports are removed

7. Component structure:
   - [ ] Uses proper sol! macro with correct syntax
   - [ ] Correctly defines Solidity types in solidity module
   - [ ] Implements required functions

8. Security:
   - [ ] No hardcoded API keys or secrets
   - [ ] Uses environment variables for sensitive data

9.  Dependencies:
   - [ ] Uses workspace dependencies correctly
   - [ ] Includes all required dependencies

10. Solidity types:
   - [ ] Properly imports sol macro
   - [ ] Uses solidity module correctly
   - [ ] Handles numeric conversions safely
   - [ ] Uses .to_string() for all string literals in struct initialization

11. Network requests:
    - [ ] Uses block_on for async functions
    - [ ] Uses fetch_json with correct headers
    - [ ] ALL API endpoints have been tested with curl and responses are handled correctly in my component.
    - [ ] IMPORTANT! Always use #[serde(default)] and Option<T> for fields from external APIs.

With this guide, you should be able to create any WAVS component that passes validation, builds without errors, and executes correctly.
````

## File: docker-compose.yml
````yaml
###################################
#
# make start-all-local
#
###################################

# docker volume rm $(docker volume ls -q -f "dangling=true")


services:
  warg-server:
    image: "ghcr.io/reecepbcups/warg-registry:v0.9.3"
    container_name: "warg-server"
    platform: linux/amd64
    environment:
      WARG_OPERATOR_KEY: ecdsa-p256:I+UlDo0HxyBBFeelhPPWmD+LnklOpqZDkrFP5VduASk=
      WARG_NAMESPACE: example
      WKG_REGISTRY: http://localhost:5000
      WARG_CONTENT_BASE_URL: http://localhost:8090
      WARG_LISTEN: 0.0.0.0:8090
      WARG_VERBOSE: 1
    ports:
      - 8090:8090
    command: ["--rm"]

  ipfs:
    image: ipfs/kubo:v0.34.1
    container_name: ipfs
    network_mode: host
    ports:
      - "4001:4001"
      - "4001:4001/udp"
      - "8080:8080"
      - "5001:5001"
    stop_signal: SIGKILL
    command: daemon
    restart: unless-stopped
````

## File: foundry.toml
````toml
[profile.default]
src = 'src'
out = 'out'
libs = ['lib']
solidity_version = '0.8.22'
evm_version = 'shanghai'
# via_ir = true
ffi = false # false by default for security reasons
fs_permissions = [{ access = "read-write", path = "./" },]

# See more config options https://github.com/foundry-rs/foundry/tree/master/config
````

## File: LICENSE
````
Copyright 2025 Layer Labs

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
````

## File: Makefile
````
#!/usr/bin/make -f

# Check if user is in docker group to determine if sudo is needed
SUDO := $(shell if groups | grep -q docker; then echo ''; else echo 'sudo'; fi)

# Define common variables
CARGO=cargo
INPUT_DATA?=1
COMPONENT_FILENAME?=evm_price_oracle.wasm
CREDENTIAL?=""
DOCKER_IMAGE?=ghcr.io/lay3rlabs/wavs:35c96a4
MIDDLEWARE_DOCKER_IMAGE?=ghcr.io/lay3rlabs/wavs-middleware:0.4.1
IPFS_ENDPOINT?=http://127.0.0.1:5001
RPC_URL?=http://127.0.0.1:8545
SERVICE_FILE?=.docker/service.json
SERVICE_SUBMISSION_ADDR?=`jq -r .deployedTo .docker/submit.json`
SERVICE_TRIGGER_ADDR?=`jq -r .deployedTo .docker/trigger.json`
WASI_BUILD_DIR ?= ""
ENV_FILE?=.env
WAVS_CMD ?= $(SUDO) docker run --rm --network host $$(test -f ${ENV_FILE} && echo "--env-file ./${ENV_FILE}") -v $$(pwd):/data ${DOCKER_IMAGE} wavs-cli
WAVS_ENDPOINT?="http://127.0.0.1:8000"
-include ${ENV_FILE}

# Default target is build
default: build

## build: building the project
build: _build_forge wasi-build

## wasi-build: building WAVS wasi components | WASI_BUILD_DIR
wasi-build:
	@echo "🔨 Building WASI components..."
	@./script/build_components.sh $(WASI_BUILD_DIR)
	@echo "✅ WASI build complete"

## wasi-exec: executing the WAVS wasi component(s) with ABI function | COMPONENT_FILENAME, INPUT_DATA
wasi-exec: pull-image
	@$(WAVS_CMD) exec --log-level=info --data /data/.docker --home /data \
	--component "/data/compiled/$(COMPONENT_FILENAME)" \
	--input $(shell cast abi-encode "f(string)" "${INPUT_DATA}") \

## wasi-exec-fixed: the same as wasi-exec, except uses a fixed input as bytes (used in Go & TS components) | COMPONENT_FILENAME, INPUT_DATA
wasi-exec-fixed: pull-image
	@$(WAVS_CMD) exec --log-level=info --data /data/.docker --home /data \
	--component "/data/compiled/$(COMPONENT_FILENAME)" \
	--input `cast format-bytes32-string $(INPUT_DATA)`

## clean: cleaning the project files
clean: clean-docker
	@forge clean
	@$(CARGO) clean
	@rm -rf cache
	@rm -rf out
	@rm -rf broadcast

## clean-docker: remove unused docker containers
clean-docker:
	@$(SUDO) docker rm -v $(shell $(SUDO) docker ps -a --filter status=exited -q) > /dev/null 2>&1 || true


## validate-component: validate a WAVS component against best practices
validate-component:
	@if [ -z "$(COMPONENT)" ]; then \
		echo "Usage: make validate-component COMPONENT=your-component-name"; \
		echo "Example: make validate-component COMPONENT=eth-price-oracle"; \
		exit 1; \
	fi
	@if [ ! -d "./components/$(COMPONENT)" ]; then \
		echo "Error: Component directory ./components/$(COMPONENT) not found"; \
		exit 1; \
	fi
	@if [ ! -d "./test_utils" ]; then \
		echo "Error: Test utilities not found. Please ensure test_utils exists."; \
		exit 1; \
	fi
	@cd test_utils && ./validate_component.sh $(COMPONENT)


## fmt: formatting solidity and rust code
fmt:
	@forge fmt --check
	@$(CARGO) fmt

## test: running tests
test:
	@forge test

## setup: install initial dependencies
setup: check-requirements
	@echo "📦 Installing dependencies..."
	@echo "  • Installing Forge dependencies..."
	@forge install > /dev/null 2>&1
	@echo "  • Installing npm dependencies..."
	@npm install > /dev/null 2>&1
	@echo "✅ Dependencies installed"

## start-all-local: starting anvil and core services (like IPFS for example)
start-all-local: clean-docker setup-env
	@sh ./script/start_all.sh

## get-trigger-from-deploy: getting the trigger address from the script deploy
get-trigger-from-deploy:
	@jq -r '.deployedTo' "./.docker/trigger.json"

## get-submit-from-deploy: getting the submit address from the script deploy
get-submit-from-deploy:
	@jq -r '.deployedTo' "./.docker/submit.json"

## wavs-cli: running wavs-cli in docker
wavs-cli:
	@$(WAVS_CMD) $(filter-out $@,$(MAKECMDGOALS))

## upload-component: uploading the WAVS component | COMPONENT_FILENAME, WAVS_ENDPOINT
upload-component:
	@if [ -z "${COMPONENT_FILENAME}" ]; then \
		echo "❌ Error: COMPONENT_FILENAME is not set"; \
		echo "💡 Set it with: export COMPONENT_FILENAME=evm_price_oracle.wasm"; \
		echo "📖 See 'make help' for more info"; \
		exit 1; \
	fi
	@echo "📤 Uploading component: ${COMPONENT_FILENAME}..."
	@wget --post-file=./compiled/${COMPONENT_FILENAME} --header="Content-Type: application/wasm" -O - ${WAVS_ENDPOINT}/upload | jq -r .digest
	@echo "✅ Component uploaded successfully"

IPFS_GATEWAY?="https://ipfs.io/ipfs"
## deploy-service: deploying the WAVS component service json | SERVICE_URL, CREDENTIAL, WAVS_ENDPOINT
deploy-service:
# this wait is required to ensure the WAVS service has time to service check
	@if [ -z "${SERVICE_URL}" ]; then \
		echo "❌ Error: SERVICE_URL is not set"; \
		echo "💡 Set it with: export SERVICE_URL=<ipfs-or-http-url>"; \
		echo "📖 See 'make help' for more info"; \
		exit 1; \
	fi
	@if [ -n "${WAVS_ENDPOINT}" ]; then \
		echo "🔍 Checking WAVS service at ${WAVS_ENDPOINT}..."; \
		if [ "$$(curl -s -o /dev/null -w "%{http_code}" ${WAVS_ENDPOINT}/app)" != "200" ]; then \
			echo "❌ WAVS service not reachable at ${WAVS_ENDPOINT}"; \
			echo "💡 Re-try running in 1 second, if not then validate the wavs service is online / started."; \
			exit 1; \
		fi; \
		echo "✅ WAVS service is running"; \
	fi
	@echo "🚀 Deploying service from: ${SERVICE_URL}..."
	@$(WAVS_CMD) deploy-service --service-url ${SERVICE_URL} --log-level=debug --data /data/.docker --home /data $(if $(WAVS_ENDPOINT),--wavs-endpoint $(WAVS_ENDPOINT),) $(if $(IPFS_GATEWAY),--ipfs-gateway $(IPFS_GATEWAY),)
	@echo "✅ Service deployed successfully"

## get-trigger: get the trigger id | SERVICE_TRIGGER_ADDR, RPC_URL
get-trigger:
	@forge script ./script/ShowResult.s.sol ${SERVICE_TRIGGER_ADDR} --sig 'trigger(string)' --rpc-url $(RPC_URL) --broadcast

TRIGGER_ID?=1
## show-result: showing the result | SERVICE_SUBMISSION_ADDR, TRIGGER_ID, RPC_URL
show-result:
	@forge script ./script/ShowResult.s.sol ${SERVICE_SUBMISSION_ADDR} ${TRIGGER_ID} --sig 'data(string,uint64)' --rpc-url $(RPC_URL) --broadcast


PINATA_API_KEY?=""
## upload-to-ipfs: uploading the a service config to IPFS | SERVICE_FILE, [PINATA_API_KEY]
upload-to-ipfs:
	@if [ `sh script/get-deploy-status.sh` = "LOCAL" ]; then \
		curl -X POST "http://127.0.0.1:5001/api/v0/add?pin=true" -H "Content-Type: multipart/form-data" -F file=@${SERVICE_FILE} | jq -r .Hash; \
	else \
		if [ -z "${PINATA_API_KEY}" ]; then \
			echo "Error: PINATA_API_KEY is not set. Please set it to your Pinata API key -- https://app.pinata.cloud/developers/api-keys."; \
			exit 1; \
		fi; \
		curl -X POST --url https://uploads.pinata.cloud/v3/files --header "Authorization: Bearer ${PINATA_API_KEY}" --header 'Content-Type: multipart/form-data' --form file=@${SERVICE_FILE} --form network=public --form name=service-`date +"%b-%d-%Y"`.json | jq -r .data.cid; \
	fi

COMMAND?=""
PAST_BLOCKS?=500
wavs-middleware:
	@docker run --rm --network host --env-file ${ENV_FILE} \
		$(if ${WAVS_SERVICE_MANAGER_ADDRESS},-e WAVS_SERVICE_MANAGER_ADDRESS=${WAVS_SERVICE_MANAGER_ADDRESS}) \
		$(if ${PAST_BLOCKS},-e PAST_BLOCKS=${PAST_BLOCKS}) \
		-v ./.nodes:/root/.nodes ${MIDDLEWARE_DOCKER_IMAGE} ${COMMAND}

## update-submodules: update the git submodules
update-submodules:
	@git submodule update --init --recursive

# Declare phony targets
.PHONY: build clean fmt bindings test

.PHONY: help
help: Makefile
	@echo
	@echo " Choose a command run"
	@echo
	@sed -n 's/^##//p' $< | column -t -s ':' |  sed -e 's/^/ /'
	@echo

# helpers
_build_forge:
	@forge build

.PHONY: setup-env
setup-env:
	@if [ ! -f ${ENV_FILE} ]; then \
		if [ -f .env.example ]; then \
			echo "Creating ${ENV_FILE} file from .env.example..."; \
			cp .env.example ${ENV_FILE}; \
			echo "${ENV_FILE} file created successfully!"; \
		fi; \
	fi

pull-image:
	@if ! docker image inspect ${DOCKER_IMAGE} &>/dev/null; then \
		echo "Image ${DOCKER_IMAGE} not found. Pulling..."; \
		$(SUDO) docker pull ${DOCKER_IMAGE}; \
	fi

# check versions

## check-requirements: verify system requirements are installed
check-requirements:
	@echo "🔍 Validating system requirements..."
	@$(MAKE) check-node check-jq check-cargo check-docker
	@echo "✅ All requirements satisfied"

check-command:
	@command -v $(1) > /dev/null 2>&1 || (echo "❌ $(1) not found. Please install $(1), reference the System Requirements section"; exit 1)

check-command-with-help:
	@command -v $(1) > /dev/null 2>&1 || \
		(echo "❌ $(1) not found"; echo "💡 Install: $(2)"; exit 1)

.PHONY: check-node
check-node:
	@$(call check-command-with-help,node,"curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash && nvm install --lts")
	@NODE_VERSION=$$(node --version); \
	MAJOR_VERSION=$$(echo $$NODE_VERSION | sed 's/^v\([0-9]*\)\..*/\1/'); \
	if [ $$MAJOR_VERSION -lt 21 ]; then \
		echo "❌ Node.js version $$NODE_VERSION is less than required v21"; \
		echo "💡 Upgrade with: nvm install --lts"; \
		exit 1; \
	fi

.PHONY: check-jq
check-jq:
	@$(call check-command-with-help,jq,"brew install jq (macOS) or apt install jq (Linux)")

.PHONY: check-cargo
check-cargo:
	@$(call check-command-with-help,cargo,"curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh")

.PHONY: check-docker
check-docker:
	@$(call check-command-with-help,docker,"https://docs.docker.com/get-docker/")
````

## File: metadata.json
````json
{
    "name": "WAVS Template App",
    "website": "https://github.com/Lay3rLabs/wavs-foundry-template",
    "description": "Yet another Amazing App built with WAVS",
    "logo": "https://www.wavs.xyz/favicon.png",
    "twitter": "https://x.com/LayerOnEth"
  }
````

## File: natspec-smells.config.js
````javascript
/**
 * List of supported options: https://github.com/defi-wonderland/natspec-smells?tab=readme-ov-file#options
 */

/** @type {import('@defi-wonderland/natspec-smells').Config} */
module.exports = {
  include: 'src/**/*.sol',
  exclude: '(test|scripts)/**/*.sol',
};
````

## File: package.json
````json
{
  "name": "wavs-foundry-template",
  "version": "0.4.0",
  "license": "MIT",
  "scripts": {
    "build": "forge build",
    "coverage": "forge coverage --report summary --report lcov --match-path 'test/unit/*'",
    "deploy:local": "forge script Deploy ${SERVICE_MANAGER} --sig 'run(string)' --rpc-url http://localhost:8545 --broadcast -vvvvv",
    "lint:check": "yarn lint:sol && forge fmt --check",
    "lint:fix": "sort-package-json && forge fmt && yarn lint:sol --fix",
    "lint:natspec": "npx @defi-wonderland/natspec-smells --config natspec-smells.config.js",
    "lint:sol": "solhint 'src/**/*.sol' 'script/**/*.sol' 'test/**/*.sol'",
    "test": "forge test -vvv",
    "test:integration": "forge test --match-contract Integration -vvv",
    "test:unit": "forge test --match-contract Unit -vvv",
    "claude-code": "docker compose -f .claude/docker-compose.claude.yml run --rm --remove-orphans -it claude-code-sandbox bash -c 'claude; exec'",
    "claude-code:unrestricted": "docker compose -f .claude/docker-compose.claude.yml run --rm --remove-orphans -it claude-code-sandbox bash -c 'claude --dangerously-skip-permissions; exec'"
  },
  "lint-staged": {
    "*.{js,css,md,ts,sol}": "forge fmt",
    "(src|test|script)/**/*.sol": "yarn lint:sol",
    "package.json": "sort-package-json"
  },
  "dependencies": {
    "@commitlint/cli": "19.3.0",
    "@commitlint/config-conventional": "19.2.2",
    "@defi-wonderland/natspec-smells": "1.1.6",
    "@openzeppelin/contracts": "^5.2.0",
    "forge-std": "github:foundry-rs/forge-std#v1.9.6",
    "@wavs/solidity": "0.4.0",
    "lint-staged": ">=10",
    "solhint-community": "4.0.0",
    "sort-package-json": "2.10.0"
  }
}
````

## File: README.md
````markdown
# [WAVS](https://docs.wavs.xyz) Monorepo Template

**Template for getting started with developing WAVS applications**

A template for developing WebAssembly AVS applications using Rust and Solidity, configured for Windows *WSL*, Linux, and MacOS. The sample oracle service fetches the current price of a cryptocurrency from [CoinMarketCap](https://coinmarketcap.com) and saves it on chain via the operators.

**Languages**
 * [Rust (this example)](./components/evm-price-oracle/)
 * [Go](./components/golang-evm-price-oracle/README.md)
 * [JS / TS](./components/js-evm-price-oracle/README.md)

## System Requirements

<details>
<summary>Core (Docker, Compose, Make, JQ, Node v21+, Foundry)</summary>

## Ubuntu Base
- **Linux**: `sudo apt update && sudo apt install build-essential`

### Docker

If prompted, remove container with `sudo apt remove containerd.io`.

- **MacOS**: `brew install --cask docker`
- **Linux**: `sudo apt -y install docker.io`
- **Windows WSL**: [docker desktop wsl](https://docs.docker.com/desktop/wsl/#turn-on-docker-desktop-wsl-2) & `sudo chmod 666 /var/run/docker.sock`
- [Docker Documentation](https://docs.docker.com/get-started/get-docker/)

> **Note:** `sudo` is only used for Docker-related commands in this project. If you prefer not to use sudo with Docker, you can add your user to the Docker group with:
> ```bash
> sudo groupadd docker && sudo usermod -aG docker $USER
> ```
> After adding yourself to the group, log out and back in for changes to take effect.

### Docker Compose
- **MacOS**: Already installed with Docker installer
> `sudo apt remove docker-compose-plugin` may be required if you get a `dpkg` error
- **Linux + Windows WSL**: `sudo apt-get install docker-compose-v2`
- [Compose Documentation](https://docs.docker.com/compose/)

### Make
- **MacOS**: `brew install make`
- **Linux + Windows WSL**: `sudo apt -y install make`
- [Make Documentation](https://www.gnu.org/software/make/manual/make.html)

### JQ
- **MacOS**: `brew install jq`
- **Linux + Windows WSL**: `sudo apt -y install jq`
- [JQ Documentation](https://jqlang.org/download/)

### Node.js
- **Required Version**: v21+
- [Installation via NVM](https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating)

```bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash
nvm install --lts
```

### Foundry
```bash docci-ignore
curl -L https://foundry.paradigm.xyz | bash && $HOME/.foundry/bin/foundryup
```

</details>

<details>

<summary>Rust v1.85+</summary>

### Rust Installation

```bash docci-ignore
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

rustup toolchain install stable
rustup target add wasm32-wasip2
```

### Upgrade Rust

```bash docci-ignore
# Remove old targets if present
rustup target remove wasm32-wasi || true
rustup target remove wasm32-wasip1 || true

# Update and add required target
rustup update stable
rustup target add wasm32-wasip2
```

</details>

<details>
<summary>Cargo Components</summary>

### Install Cargo Components

On Ubuntu LTS, if you later encounter errors like:

```bash
wkg: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.38' not found (required by wkg)
wkg: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.39' not found (required by wkg)
```

If GLIB is out of date. Consider updating your system using:
```bash
sudo do-release-upgrade
```


```bash docci-ignore
# Install required cargo components
# https://github.com/bytecodealliance/cargo-component#installation
cargo install cargo-binstall
cargo binstall cargo-component wasm-tools warg-cli wkg --locked --no-confirm --force

# Configure default registry
# Found at: $HOME/.config/wasm-pkg/config.toml
wkg config --default-registry wa.dev

# Allow publishing to a registry
#
# if WSL: `warg config --keyring-backend linux-keyutils`
warg key new
```

</details>

## Create Project

```bash docci-ignore
# if foundry is not installed:
# `curl -L https://foundry.paradigm.xyz | bash && $HOME/.foundry/bin/foundryup`
forge init --template Lay3rLabs/wavs-foundry-template my-wavs --branch 0.4
```

> \[!TIP]
> Run `make help` to see all available commands and environment variable overrides.

### Solidity

Install the required packages to build the Solidity contracts. This project supports both [submodules](./.gitmodules) and [npm packages](./package.json).

```bash
# Install packages (npm & submodules)
make setup

# Build the contracts
forge build

# Run the solidity tests
forge test
```

## Build WASI components

Now build the WASI components into the `compiled` output directory.

> \[!WARNING]
> If you get: `error: no registry configured for namespace "wavs"`
>
> run, `wkg config --default-registry wa.dev`

> \[!WARNING]
> If you get: `failed to find the 'wasm32-wasip1' target and 'rustup' is not available`
>
> `brew uninstall rust` & install it from <https://rustup.rs>

```bash
# Remove `WASI_BUILD_DIR` to build all components.
WASI_BUILD_DIR=components/evm-price-oracle make wasi-build
```

## Testing the Price Feed Component Locally

How to test the component locally for business logic validation before on-chain deployment. An ID of 1 for the oracle component is Bitcoin.

```bash
# Rust & Typescript components
INPUT_DATA="1" COMPONENT_FILENAME=evm_price_oracle.wasm make wasi-exec
INPUT_DATA="1" COMPONENT_FILENAME=js_evm_price_oracle.wasm make wasi-exec

# Golang
INPUT_DATA="1" COMPONENT_FILENAME=golang_evm_price_oracle.wasm make wasi-exec-fixed
```

Expected output:

```shell docci-ignore
input id: 1
resp_data: PriceFeedData {
    symbol: "BTC",
    timestamp: "2025-04-01T00:00:00.000Z",
    price: 82717.27035239758
}
INFO Fuel used: 653415

Result (hex encoded):
7b2273796d626f6c223a22425443222c2274696d657374616d70223a22323032352d30342d30315430303a34...

Result (utf8):
{"symbol":"BTC","timestamp":"2025-04-01T00:00:00.000Z","price":82717.27035239758}
```

## WAVS

> \[!NOTE]
> If you are running on a Mac with an ARM chip, you will need to do the following:
> - Set up Rosetta: `softwareupdate --install-rosetta`
> - Enable Rosetta (Docker Desktop: Settings -> General -> enable "Use Rosetta for x86_64/amd64 emulation on Apple Silicon")
>
> Configure one of the following networking:
> - Docker Desktop: Settings -> Resources -> Network -> 'Enable Host Networking'
> - `brew install chipmk/tap/docker-mac-net-connect && sudo brew services start chipmk/tap/docker-mac-net-connect`

## Start Environment

Start an Ethereum node (anvil), the WAVS service, and deploy [EigenLayer](https://www.eigenlayer.xyz/) contracts to the local network.

### Enable Telemetry (optional)

Set Log Level:
  - Open the `.env` file.
  - Set the `log_level` variable for wavs to debug to ensure detailed logs are captured.

> \[!NOTE]
To see details on how to access both traces and metrics, please check out [Telemetry Documentation](telemetry/telemetry.md).

### Start the backend

```bash docci-background docci-delay-after=5
# This must remain running in your terminal. Use another terminal to run other commands.
# You can stop the services with `ctrl+c`. Some MacOS terminals require pressing it twice.
cp .env.example .env

# update the .env for either LOCAL or TESTNET

# Starts anvil + IPFS, WARG, Jaeger, and prometheus.
make start-all-local
```

## WAVS Deployment Script

This script automates the complete WAVS deployment process in a single command:

### What It Does

1. **Build Check**: Rebuilds WebAssembly component if changes detected
2. **Create Deployer**: Sets up and funds deployer account
3. **Deploy Eigenlayer**: Deploys service manager contract
4. **Deploy Contracts**: Creates trigger and submission contracts
5. **Upload Component**: Publishes WebAssembly component to WASI registry
6. **Build Service**: Creates service configuration
7. **Upload to IPFS**: Stores service metadata on IPFS
8. **Set Service URI**: Registers IPFS URI with service manager
9. **Start Aggregator**: Launches result aggregation service
10. **Start WAVS**: Launches operator service with readiness check
11. **Deploy Service**: Configures WAVS to monitor trigger events
12. **Generate Keys**: Creates operator signing keys
13. **Register Operator**: Registers with Eigenlayer AVS (0.001 ETH stake)
14. **Verify Registration**: Confirms operator registration

### Result

A fully operational WAVS service that monitors blockchain events, executes WebAssembly components, and submits verified results on-chain.

```bash
export RPC_URL=`bash ./script/get-rpc.sh`
export AGGREGATOR_URL=http://127.0.0.1:8001

bash ./script/deploy-script.sh
```


## Trigger the Service

Anyone can now call the [trigger contract](./src/contracts/WavsTrigger.sol) which emits the trigger event WAVS is watching for from the previous step. WAVS then calls the service and saves the result on-chain.

```bash
# Rust & Typescript - request BTC from CMC
export INPUT_DATA=`cast abi-encode "addTrigger(string)" "1"`

# Golang uses the raw value
# export INPUT_DATA="1"

# Get the trigger address from previous Deploy forge script
export SERVICE_TRIGGER_ADDR=`make get-trigger-from-deploy`
# Execute on the trigger contract, WAVS will pick this up and submit the result
# on chain via the operators.

# uses FUNDED_KEY as the executor (local: anvil account)
source .env
export RPC_URL=`sh ./script/get-rpc.sh`

forge script ./script/Trigger.s.sol ${SERVICE_TRIGGER_ADDR} ${INPUT_DATA} --sig 'run(string,string)' --rpc-url ${RPC_URL} --broadcast
```

## Show the result

Query the latest submission contract id from the previous request made.

```bash docci-delay-per-cmd=2 docci-output-contains="1"
RPC_URL=${RPC_URL} make get-trigger
```

```bash docci-delay-per-cmd=2 docci-output-contains="BTC"
TRIGGER_ID=1 RPC_URL=${RPC_URL} make show-result
```

## AI Coding Agents

This template contains rulefiles for building components with Claude Code and Cursor. Read the [AI-powered component creation guide](./docs/handbook/ai.mdx) for usage instructions.

### Claude Code

To spin up a sandboxed instance of [Claude Code](https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview) in a Docker container that only has access to this project's files, run the following command:

```bash docci-ignore
npm run claude-code
# or with no restrictions (--dangerously-skip-permissions)
npm run claude-code:unrestricted
```
````

## File: remappings.txt
````
@openzeppelin-contracts=node_modules/@openzeppelin/contracts/
forge-std=node_modules/forge-std/src
@wavs=node_modules/@wavs/solidity/contracts
contracts/=src/contracts
common/=src/common
interfaces/=src/interfaces
````

## File: rustfmt.toml
````toml
use_small_heuristics = "Max"
use_field_init_shorthand = true

# See more keys and their definitions at https://rust-lang.github.io/rustfmt

# # unstable - require nightly rustfmt
# imports_granularity = "Crate"
# wrap_comments = true
# comment_width = 100
# # ignore automatically generated bindings
# ignore = ["crates/bindings/"]
````

## File: wavs.toml
````toml
# This configuration file contains settings for all WAVS components:
# - General settings (shared across all processes)
# - WAVS server-specific settings
# - CLI-specific settings
# - Aggregator-specific settings
#
# Environment variable overrides follow these patterns:
# - WAVS server settings: WAVS_<UPPERCASE_KEY>
# - CLI settings: WAVS_CLI_<UPPERCASE_KEY>
# - Aggregator settings: WAVS_AGGREGATOR_<UPPERCASE_KEY>
#
# For arrays, use a comma-separated list in a single string:
# e.g., WAVS_LOG_LEVEL="info, wavs=debug" or WAVS_CORS_ALLOWED_ORIGINS="https://example.com, https://example2.com"

# ----------------------------
# Default settings (shared)
# ----------------------------
# The log level, in the format of tracing directives. Default is ["info"]
# See https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html#directives
[default]
log_level = ["info", "wavs=debug"]

# Those configs are global and shared between wavs and aggregator
# jaeger = "http://localhost:4317"
# prometheus = "http://localhost:9090"


# ----------------------------
# Chain configurations
# ----------------------------

# == Ethereum chains ==

# Mainnet
[default.chains.evm.ethereum]
chain_id = "1"
ws_endpoint = "wss://eth.drpc.org"
http_endpoint = "https://eth.drpc.org"

[default.chains.evm.base]
chain_id = "8453"
ws_endpoint = "wss://base.drpc.org"
http_endpoint = "https://base.drpc.org"

[default.chains.evm.optimism]
chain_id = "10"
ws_endpoint = "wss://optimism.drpc.org"
http_endpoint = "https://optimism.drpc.org"

[default.chains.evm.arbitrum]
chain_id = "42161"
ws_endpoint = "wss://arbitrum.drpc.org"
http_endpoint = "https://arbitrum.drpc.org"

# Local / Testnet
[default.chains.evm.local]
chain_id = "31337"
ws_endpoint = "ws://localhost:8545"
http_endpoint = "http://localhost:8545"
poll_interval_ms = 7000

[default.chains.evm.local2]
chain_id = "31338"
ws_endpoint = "ws://localhost:8645"
http_endpoint = "http://localhost:8645"
poll_interval_ms = 7000

[default.chains.evm.sepolia]
chain_id = "11155111"
ws_endpoint = "wss://ethereum-sepolia-rpc.publicnode.com"
http_endpoint = "https://ethereum-sepolia-rpc.publicnode.com"

[default.chains.evm.holesky]
chain_id = "17000"
ws_endpoint = "wss://ethereum-holesky-rpc.publicnode.com"
http_endpoint = "https://ethereum-holesky-rpc.publicnode.com"

[default.chains.evm.holesky-fork]
chain_id = "17000"
ws_endpoint = "ws://localhost:8545"
http_endpoint = "http://localhost:8545"
poll_interval_ms = 7000

# == Cosmos chains ==

[default.chains.cosmos.neutron]
chain_id = "pion-1"
bech32_prefix = "neutron"
rpc_endpoint = "https://rpc-falcron.pion-1.ntrn.tech"
grpc_endpoint = "http://grpc-falcron.pion-1.ntrn.tech:80"
gas_price = 0.0053
gas_denom = "untrn"

# ----------------------------
# WAVS specific settings
# ----------------------------
[wavs]

# The directory to store the data. Default is "/var/wavs"
data = "~/wavs"

cors_allowed_origins = [
    "https://lay3rlabs.github.io/*",
    "http://localhost:*",
    "http://127.0.0.1:*",
]

# The port on which the server will listen.
# port = 8000

# The host to serve on. Default is localhost
# host = "localhost"

# WAVS-specific chain overrides (if needed)
# Example:
# [wavs.chains.evm.local]
# chain_id = "31337"
# ws_endpoint = "ws://localhost:8545"
# http_endpoint = "http://localhost:8545"

# ----------------------------
# CLI specific settings
# ----------------------------
[cli]
# The directory to store the data. Default is "/var/wavs-cli"
data = "~/wavs/cli"

# wavs_endpoint = "http://localhost:8000"

# ----------------------------
# Aggregator specific settings
# ----------------------------
[aggregator]
# The directory to store the data. Default is "/var/wavs-aggregator"
data = "~/wavs"

cors_allowed_origins = [
    "https://lay3rlabs.github.io/*",
    "http://localhost:*",
    "http://127.0.0.1:*",
]

# Aggregator-specific chain overrides (if needed)
# Example:
# [aggregator.chains.evm.local]
# chain_id = "31337"
# ws_endpoint = "ws://localhost:8545"
# http_endpoint = "http://localhost:8545"
````
